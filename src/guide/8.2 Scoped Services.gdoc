기본적으로 서비스 메소드들은 동기화되지 않는다. 서비스의 어떤 함수도 동시에concurrent 실행할 수 있도록 고려되지 않았다. 하지만 서비스는 싱글톤이고 동시에 접근될 수 있기 때문에 서비스에 상태를 저장할때는 주의해야 한다. 하지만 손 쉽게 읽기만 사용하고 서비스에 절대로 상태를 저장하지 않는 것이 더 낫다.

서비스를 다른 스콥에 넣어서 이 행동을 변경할 수 있다. 지원되는 스콥은 다음과 같다:

* prototype - 서비스는 항상 생성되어 다른 클래스로 주입된다.
* request - 서비스는 매 요청마다 생성된다.
* flash - 서비스는 현재 요청부터 다음 요청까지만 생성된다.
* flow - 서비스는 웹 플로우의 flow 스콥에 따라 생성되고 해제된다.
* conversation - 서비스는 웹 플로우의 conversation 스콥에 따라 생성되고 해제된다. 이 스콥은 루트 플로우와 이 것의 모든 서브 플로우들까지 포함된 스콥이다.
* session - 사용자 세션마다 서비스가 생성된다.
* singleton(기본값) - 서비스의 인스턴스는 단 한개만 존재할 수 있다.

{note}
서비스가 flash, flow, conversation 스콥에 해당되면 java.io.Serializable를 구현해야 하고 웹 플로우([Web Flow|guide:webflow]) 컨텍스트에서만 사용할 수 있다.
{note}
      
스콥을 변경하려면 클래스에 정적 프로퍼티 scope을 추가하고 위에 설명한 것들 중에서 하나로 값을 설정한다:

{code:java}
static scope = "flow"
{code}

