<html>
	<head>
		  <title>The Grails Framework 1.0 - Reference Documentation</title>
		  <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Style" charset="utf-8">	
	</head>
    <body class="body">
		<div id="header">
				<div class="images"><br><br>
				   <a href="http://grails.org"  target="_blank"><img alt="The Grails Framework" src="../img/grails.png" width="300" border="0"></a>
				   <span style="right:30px; top:20px; position:absolute;">
					<a href="../index.html" target="_top">프레임형식 보기</a> | <a href="index.html" target="_top">프레임없이 보기</a><br><br>
					<a alt="G2One - The Groovy/Grails Company" href="http://g2one.com" target="_blank"><img src="../img/g2one.png" width="130" border="0"></a>
					</span>					
				</div>
				<div class="message">See the light - agile, industrial strength, rapid web application development made easy</div>
				<h1>The Grails Framework - Reference Documentation</h1>
				<p><strong>저자:</strong> Graeme Rocher, Marc Palmer</p>
				<p><strong>번역:</strong> 박창우, 최용재, 이성환</p>
				<p><strong>버전:</strong> 1.0</p>				
				<em>이 문서의 사본은 여러분의 개인적인 사용이나 다른이에게 배포하는데 사용될 수 있으며, 이 사본들에 대해서 여러분은 어떠한 비용도 지불하지 않고, 이 저작권에 대한 알리는 사항을 포함하여 문서상으로나 온라인 문서로 제공될 수 있다.</em>
		</div>                       
		
		<div id="toc">  
			<h2>Table of Contents</h2>
			<div class="tocItem" style="margin-left:0px"><a href="#1. Introduction">1. Introduction</a></div><div class="tocItem" style="margin-left:0px"><a href="#2. Getting Started">2. Getting Started</a></div><div class="tocItem" style="margin-left:10px"><a href="#2.1 Downloading and Installing">2.1 Downloading and Installing</a></div><div class="tocItem" style="margin-left:10px"><a href="#2.2 Creating an Application">2.2 Creating an Application</a></div><div class="tocItem" style="margin-left:10px"><a href="#2.3 A Hello World Example">2.3 A Hello World Example</a></div><div class="tocItem" style="margin-left:10px"><a href="#2.4 Getting Set-up in an IDE">2.4 Getting Set-up in an IDE</a></div><div class="tocItem" style="margin-left:10px"><a href="#2.5 Convention over Configuration">2.5 Convention over Configuration</a></div><div class="tocItem" style="margin-left:10px"><a href="#2.6 Running an Application">2.6 Running an Application</a></div><div class="tocItem" style="margin-left:10px"><a href="#2.7 Testing an Application">2.7 Testing an Application</a></div><div class="tocItem" style="margin-left:10px"><a href="#2.8 Deploying an Application">2.8 Deploying an Application</a></div><div class="tocItem" style="margin-left:10px"><a href="#2.9 Supported Java EE Containers">2.9 Supported Java EE Containers</a></div><div class="tocItem" style="margin-left:10px"><a href="#2.10 Creating Artefacts">2.10 Creating Artefacts</a></div><div class="tocItem" style="margin-left:10px"><a href="#2.11 Generating an Application">2.11 Generating an Application</a></div><div class="tocItem" style="margin-left:0px"><a href="#3. Configuration">3. Configuration</a></div><div class="tocItem" style="margin-left:10px"><a href="#3.1 Basic Configuration">3.1 Basic Configuration</a></div><div class="tocItem" style="margin-left:20px"><a href="#3.1.1 Built in options">3.1.1 Built in options</a></div><div class="tocItem" style="margin-left:20px"><a href="#3.1.2 Logging">3.1.2 Logging</a></div><div class="tocItem" style="margin-left:10px"><a href="#3.2 Environments">3.2 Environments</a></div><div class="tocItem" style="margin-left:10px"><a href="#3.3 The DataSource">3.3 The DataSource</a></div><div class="tocItem" style="margin-left:20px"><a href="#3.3.1 DataSources and Environments">3.3.1 DataSources and Environments</a></div><div class="tocItem" style="margin-left:20px"><a href="#3.3.2 JNDI DataSources">3.3.2 JNDI DataSources</a></div><div class="tocItem" style="margin-left:20px"><a href="#3.3.3 Automatic Database Migration">3.3.3 Automatic Database Migration</a></div><div class="tocItem" style="margin-left:10px"><a href="#3.4 Externalized Configuration">3.4 Externalized Configuration</a></div><div class="tocItem" style="margin-left:10px"><a href="#3.5 Versioning">3.5 Versioning</a></div><div class="tocItem" style="margin-left:10px"><a href="#3.6 Deployment">3.6 Deployment</a></div><div class="tocItem" style="margin-left:0px"><a href="#4. The Command Line">4. The Command Line</a></div><div class="tocItem" style="margin-left:10px"><a href="#4.1 Creating Gant Scripts">4.1 Creating Gant Scripts</a></div><div class="tocItem" style="margin-left:10px"><a href="#4.2 Re-using Grails scripts">4.2 Re-using Grails scripts</a></div><div class="tocItem" style="margin-left:10px"><a href="#4.3 Hooking into Events">4.3 Hooking into Events</a></div><div class="tocItem" style="margin-left:10px"><a href="#4.4 Ant and Maven">4.4 Ant and Maven</a></div><div class="tocItem" style="margin-left:0px"><a href="#5. Object Relational Mapping (GORM)">5. Object Relational Mapping (GORM)</a></div><div class="tocItem" style="margin-left:10px"><a href="#5.1 Quick Start Guide">5.1 Quick Start Guide</a></div><div class="tocItem" style="margin-left:20px"><a href="#5.1.1 Basic CRUD">5.1.1 Basic CRUD</a></div><div class="tocItem" style="margin-left:10px"><a href="#5.2 Domain Modelling in GORM">5.2 Domain Modelling in GORM</a></div><div class="tocItem" style="margin-left:20px"><a href="#5.2.1 Association in GORM">5.2.1 Association in GORM</a></div><div class="tocItem" style="margin-left:30px"><a href="#5.2.1.1 One-to-one">5.2.1.1 One-to-one</a></div><div class="tocItem" style="margin-left:30px"><a href="#5.2.1.2 One-to-many">5.2.1.2 One-to-many</a></div><div class="tocItem" style="margin-left:30px"><a href="#5.2.1.3 Many-to-many">5.2.1.3 Many-to-many</a></div><div class="tocItem" style="margin-left:20px"><a href="#5.2.2 Composition in GORM">5.2.2 Composition in GORM</a></div><div class="tocItem" style="margin-left:20px"><a href="#5.2.3 Inheritance in GORM">5.2.3 Inheritance in GORM</a></div><div class="tocItem" style="margin-left:20px"><a href="#5.2.4 Sets, Lists and Maps">5.2.4 Sets, Lists and Maps</a></div><div class="tocItem" style="margin-left:10px"><a href="#5.3 Persistence Basics">5.3 Persistence Basics</a></div><div class="tocItem" style="margin-left:20px"><a href="#5.3.1 Saving and Updating">5.3.1 Saving and Updating</a></div><div class="tocItem" style="margin-left:20px"><a href="#5.3.2 Deleting Objects">5.3.2 Deleting Objects</a></div><div class="tocItem" style="margin-left:20px"><a href="#5.3.3 Understanding Cascading Updates and Deletes">5.3.3 Understanding Cascading Updates and Deletes</a></div><div class="tocItem" style="margin-left:20px"><a href="#5.3.4 Eager and Lazy Fetching">5.3.4 Eager and Lazy Fetching</a></div><div class="tocItem" style="margin-left:20px"><a href="#5.3.5 Pessimistic and Optimistic Locking">5.3.5 Pessimistic and Optimistic Locking</a></div><div class="tocItem" style="margin-left:10px"><a href="#5.4 Querying with GORM">5.4 Querying with GORM</a></div><div class="tocItem" style="margin-left:20px"><a href="#5.4.1 Dynamic Finders">5.4.1 Dynamic Finders</a></div><div class="tocItem" style="margin-left:20px"><a href="#5.4.2 Criteria">5.4.2 Criteria</a></div><div class="tocItem" style="margin-left:20px"><a href="#5.4.3 Hibernate Query Language (HQL)">5.4.3 Hibernate Query Language (HQL)</a></div><div class="tocItem" style="margin-left:10px"><a href="#5.5 Advanced GORM Features">5.5 Advanced GORM Features</a></div><div class="tocItem" style="margin-left:20px"><a href="#5.5.1 Events and Auto Timestamping">5.5.1 Events and Auto Timestamping</a></div><div class="tocItem" style="margin-left:20px"><a href="#5.5.2 Custom ORM Mapping">5.5.2 Custom ORM Mapping</a></div><div class="tocItem" style="margin-left:30px"><a href="#5.5.2.1 Table and Column Names">5.5.2.1 Table and Column Names</a></div><div class="tocItem" style="margin-left:30px"><a href="#5.5.2.2 Caching Strategy">5.5.2.2 Caching Strategy</a></div><div class="tocItem" style="margin-left:30px"><a href="#5.5.2.3 Inheritance Strategies">5.5.2.3 Inheritance Strategies</a></div><div class="tocItem" style="margin-left:30px"><a href="#5.5.2.4 Custom Database Identity">5.5.2.4 Custom Database Identity</a></div><div class="tocItem" style="margin-left:30px"><a href="#5.5.2.5 Composite Primary Keys">5.5.2.5 Composite Primary Keys</a></div><div class="tocItem" style="margin-left:30px"><a href="#5.5.2.6 Database Indices">5.5.2.6 Database Indices</a></div><div class="tocItem" style="margin-left:30px"><a href="#5.5.2.7 Optimistic Locking and Versioning">5.5.2.7 Optimistic Locking and Versioning</a></div><div class="tocItem" style="margin-left:30px"><a href="#5.5.2.8 Eager and Lazy Fetching">5.5.2.8 Eager and Lazy Fetching</a></div><div class="tocItem" style="margin-left:10px"><a href="#5.6 Programmatic Transactions">5.6 Programmatic Transactions</a></div><div class="tocItem" style="margin-left:10px"><a href="#5.7 GORM and Constraints">5.7 GORM and Constraints</a></div><div class="tocItem" style="margin-left:0px"><a href="#6. The Web Layer">6. The Web Layer</a></div><div class="tocItem" style="margin-left:10px"><a href="#6.1 Controllers">6.1 Controllers</a></div><div class="tocItem" style="margin-left:20px"><a href="#6.1.1 Understanding Controllers and Actions">6.1.1 Understanding Controllers and Actions</a></div><div class="tocItem" style="margin-left:20px"><a href="#6.1.2 Controllers and Scopes">6.1.2 Controllers and Scopes</a></div><div class="tocItem" style="margin-left:20px"><a href="#6.1.3 Models and Views">6.1.3 Models and Views</a></div><div class="tocItem" style="margin-left:20px"><a href="#6.1.4 Redirects and Chaining">6.1.4 Redirects and Chaining</a></div><div class="tocItem" style="margin-left:20px"><a href="#6.1.5 Controller Interceptors">6.1.5 Controller Interceptors</a></div><div class="tocItem" style="margin-left:20px"><a href="#6.1.6 Data Binding">6.1.6 Data Binding</a></div><div class="tocItem" style="margin-left:20px"><a href="#6.1.7 XML and JSON Responses">6.1.7 XML and JSON Responses</a></div><div class="tocItem" style="margin-left:20px"><a href="#6.1.8 Uploading Files">6.1.8 Uploading Files</a></div><div class="tocItem" style="margin-left:20px"><a href="#6.1.9 Command Objects">6.1.9 Command Objects</a></div><div class="tocItem" style="margin-left:10px"><a href="#6.2 Groovy Server Pages">6.2 Groovy Server Pages</a></div><div class="tocItem" style="margin-left:20px"><a href="#6.2.1 GSP Basics">6.2.1 GSP Basics</a></div><div class="tocItem" style="margin-left:30px"><a href="#6.2.1.1 Variables and Scopes">6.2.1.1 Variables and Scopes</a></div><div class="tocItem" style="margin-left:30px"><a href="#6.2.1.2 Logic and Iteration">6.2.1.2 Logic and Iteration</a></div><div class="tocItem" style="margin-left:30px"><a href="#6.2.1.3 Page Directives">6.2.1.3 Page Directives</a></div><div class="tocItem" style="margin-left:30px"><a href="#6.2.1.4 Expressions">6.2.1.4 Expressions</a></div><div class="tocItem" style="margin-left:20px"><a href="#6.2.2 GSP Tags">6.2.2 GSP Tags</a></div><div class="tocItem" style="margin-left:30px"><a href="#6.2.2.1 Variables and Scopes">6.2.2.1 Variables and Scopes</a></div><div class="tocItem" style="margin-left:30px"><a href="#6.2.2.2 Logic and Iteration">6.2.2.2 Logic and Iteration</a></div><div class="tocItem" style="margin-left:30px"><a href="#6.2.2.3 Search and Filtering">6.2.2.3 Search and Filtering</a></div><div class="tocItem" style="margin-left:30px"><a href="#6.2.2.4 Links and Resources">6.2.2.4 Links and Resources</a></div><div class="tocItem" style="margin-left:30px"><a href="#6.2.2.5 Forms and Fields">6.2.2.5 Forms and Fields</a></div><div class="tocItem" style="margin-left:30px"><a href="#6.2.2.6 Tags as Method Calls">6.2.2.6 Tags as Method Calls</a></div><div class="tocItem" style="margin-left:20px"><a href="#6.2.3 Views and Templates">6.2.3 Views and Templates</a></div><div class="tocItem" style="margin-left:20px"><a href="#6.2.4 Layouts with Sitemesh">6.2.4 Layouts with Sitemesh</a></div><div class="tocItem" style="margin-left:10px"><a href="#6.3 Tag Libraries">6.3 Tag Libraries</a></div><div class="tocItem" style="margin-left:20px"><a href="#6.3.1 Simple Tags">6.3.1 Simple Tags</a></div><div class="tocItem" style="margin-left:20px"><a href="#6.3.2 Logical Tags">6.3.2 Logical Tags</a></div><div class="tocItem" style="margin-left:20px"><a href="#6.3.3 Iterative Tags">6.3.3 Iterative Tags</a></div><div class="tocItem" style="margin-left:20px"><a href="#6.3.4 Tag Namespaces">6.3.4 Tag Namespaces</a></div><div class="tocItem" style="margin-left:10px"><a href="#6.4 URL Mappings">6.4 URL Mappings</a></div><div class="tocItem" style="margin-left:20px"><a href="#6.4.1 Mapping to Controllers and Actions">6.4.1 Mapping to Controllers and Actions</a></div><div class="tocItem" style="margin-left:20px"><a href="#6.4.2 Embedded Variables">6.4.2 Embedded Variables</a></div><div class="tocItem" style="margin-left:20px"><a href="#6.4.3 Mapping to Views">6.4.3 Mapping to Views</a></div><div class="tocItem" style="margin-left:20px"><a href="#6.4.4 Mapping to Response Codes">6.4.4 Mapping to Response Codes</a></div><div class="tocItem" style="margin-left:20px"><a href="#6.4.5 Mapping to HTTP methods">6.4.5 Mapping to HTTP methods</a></div><div class="tocItem" style="margin-left:20px"><a href="#6.4.6 Mapping Wildcards">6.4.6 Mapping Wildcards</a></div><div class="tocItem" style="margin-left:20px"><a href="#6.4.7 Automatic Link Re-Writing">6.4.7 Automatic Link Re-Writing</a></div><div class="tocItem" style="margin-left:20px"><a href="#6.4.8 Applying Constraints">6.4.8 Applying Constraints</a></div><div class="tocItem" style="margin-left:10px"><a href="#6.5 Web Flow">6.5 Web Flow</a></div><div class="tocItem" style="margin-left:20px"><a href="#6.5.1 Start and End States">6.5.1 Start and End States</a></div><div class="tocItem" style="margin-left:20px"><a href="#6.5.2 Action States and View States">6.5.2 Action States and View States</a></div><div class="tocItem" style="margin-left:20px"><a href="#6.5.3 Flow Execution Events">6.5.3 Flow Execution Events</a></div><div class="tocItem" style="margin-left:20px"><a href="#6.5.4 Flow Scopes">6.5.4 Flow Scopes</a></div><div class="tocItem" style="margin-left:20px"><a href="#6.5.5 Data Binding and Validation">6.5.5 Data Binding and Validation</a></div><div class="tocItem" style="margin-left:20px"><a href="#6.5.6 Subflows and Conversations">6.5.6 Subflows and Conversations</a></div><div class="tocItem" style="margin-left:10px"><a href="#6.6 Filters">6.6 Filters</a></div><div class="tocItem" style="margin-left:20px"><a href="#6.6.1 Applying Filters">6.6.1 Applying Filters</a></div><div class="tocItem" style="margin-left:20px"><a href="#6.6.2 Filter Types">6.6.2 Filter Types</a></div><div class="tocItem" style="margin-left:20px"><a href="#6.6.3 Filter Capabilities">6.6.3 Filter Capabilities</a></div><div class="tocItem" style="margin-left:10px"><a href="#6.7 Ajax">6.7 Ajax</a></div><div class="tocItem" style="margin-left:20px"><a href="#6.7.1 Ajax using Prototype">6.7.1 Ajax using Prototype</a></div><div class="tocItem" style="margin-left:30px"><a href="#6.7.1.1 Remoting Linking">6.7.1.1 Remoting Linking</a></div><div class="tocItem" style="margin-left:30px"><a href="#6.7.1.2 Updating Content">6.7.1.2 Updating Content</a></div><div class="tocItem" style="margin-left:30px"><a href="#6.7.1.3 Remote Form Submission">6.7.1.3 Remote Form Submission</a></div><div class="tocItem" style="margin-left:30px"><a href="#6.7.1.4 Ajax Events">6.7.1.4 Ajax Events</a></div><div class="tocItem" style="margin-left:20px"><a href="#6.7.2 Ajax with Dojo">6.7.2 Ajax with Dojo</a></div><div class="tocItem" style="margin-left:20px"><a href="#6.7.3 Ajax with GWT">6.7.3 Ajax with GWT</a></div><div class="tocItem" style="margin-left:20px"><a href="#6.7.4 Ajax on the Server">6.7.4 Ajax on the Server</a></div><div class="tocItem" style="margin-left:10px"><a href="#6.8 Content Negotiation">6.8 Content Negotiation</a></div><div class="tocItem" style="margin-left:0px"><a href="#7. Validation">7. Validation</a></div><div class="tocItem" style="margin-left:10px"><a href="#7.1 Declaring Constraints">7.1 Declaring Constraints</a></div><div class="tocItem" style="margin-left:10px"><a href="#7.2 Validating Constraints">7.2 Validating Constraints</a></div><div class="tocItem" style="margin-left:10px"><a href="#7.3 Validation on the Client">7.3 Validation on the Client</a></div><div class="tocItem" style="margin-left:10px"><a href="#7.4 Validation and Internationalization">7.4 Validation and Internationalization</a></div><div class="tocItem" style="margin-left:0px"><a href="#8. The Service Layer">8. The Service Layer</a></div><div class="tocItem" style="margin-left:10px"><a href="#8.1 Declarative Transactions">8.1 Declarative Transactions</a></div><div class="tocItem" style="margin-left:10px"><a href="#8.2 Scoped Services">8.2 Scoped Services</a></div><div class="tocItem" style="margin-left:10px"><a href="#8.3 Dependency Injection and Services">8.3 Dependency Injection and Services</a></div><div class="tocItem" style="margin-left:10px"><a href="#8.4 Using Services from Java">8.4 Using Services from Java</a></div><div class="tocItem" style="margin-left:0px"><a href="#9. Testing">9. Testing</a></div><div class="tocItem" style="margin-left:10px"><a href="#9.1 Unit Testing">9.1 Unit Testing</a></div><div class="tocItem" style="margin-left:10px"><a href="#9.2 Integration Testing">9.2 Integration Testing</a></div><div class="tocItem" style="margin-left:10px"><a href="#9.3 Functional Testing">9.3 Functional Testing</a></div><div class="tocItem" style="margin-left:0px"><a href="#10. Internationalization">10. Internationalization</a></div><div class="tocItem" style="margin-left:10px"><a href="#10.1 Understanding Message Bundles">10.1 Understanding Message Bundles</a></div><div class="tocItem" style="margin-left:10px"><a href="#10.2 Changing Locales">10.2 Changing Locales</a></div><div class="tocItem" style="margin-left:10px"><a href="#10.3 Reading Messages">10.3 Reading Messages</a></div><div class="tocItem" style="margin-left:0px"><a href="#11. Security">11. Security</a></div><div class="tocItem" style="margin-left:10px"><a href="#11.1 Securing Against Attacks">11.1 Securing Against Attacks</a></div><div class="tocItem" style="margin-left:10px"><a href="#11.2 Encoding and Decoding Strings">11.2 Encoding and Decoding Strings</a></div><div class="tocItem" style="margin-left:10px"><a href="#11.3 Authentication">11.3 Authentication</a></div><div class="tocItem" style="margin-left:10px"><a href="#11.4 Security Plug-ins">11.4 Security Plug-ins</a></div><div class="tocItem" style="margin-left:20px"><a href="#11.4.1 Acegi">11.4.1 Acegi</a></div><div class="tocItem" style="margin-left:20px"><a href="#11.4.2 JSecurity">11.4.2 JSecurity</a></div><div class="tocItem" style="margin-left:0px"><a href="#12. Plug-ins">12. Plug-ins</a></div><div class="tocItem" style="margin-left:10px"><a href="#12.1 Creating and Installing Plug-ins">12.1 Creating and Installing Plug-ins</a></div><div class="tocItem" style="margin-left:10px"><a href="#12.2 Understanding a Plug-ins Structure">12.2 Understanding a Plug-ins Structure</a></div><div class="tocItem" style="margin-left:10px"><a href="#12.3 Providing Basic Artefacts">12.3 Providing Basic Artefacts</a></div><div class="tocItem" style="margin-left:10px"><a href="#12.4 Evaluating Conventions">12.4 Evaluating Conventions</a></div><div class="tocItem" style="margin-left:10px"><a href="#12.5 Hooking into Build Events">12.5 Hooking into Build Events</a></div><div class="tocItem" style="margin-left:10px"><a href="#12.6 Hooking into Runtime Configuration">12.6 Hooking into Runtime Configuration</a></div><div class="tocItem" style="margin-left:10px"><a href="#12.7 Adding Dynamic Methods at Runtime">12.7 Adding Dynamic Methods at Runtime</a></div><div class="tocItem" style="margin-left:10px"><a href="#12.8 Participating in Auto Reload Events">12.8 Participating in Auto Reload Events</a></div><div class="tocItem" style="margin-left:10px"><a href="#12.9 Understanding Plug-in Load Order">12.9 Understanding Plug-in Load Order</a></div><div class="tocItem" style="margin-left:0px"><a href="#13. Web Services">13. Web Services</a></div><div class="tocItem" style="margin-left:10px"><a href="#13.1 REST">13.1 REST</a></div><div class="tocItem" style="margin-left:10px"><a href="#13.2 SOAP">13.2 SOAP</a></div><div class="tocItem" style="margin-left:10px"><a href="#13.3 RSS and Atom">13.3 RSS and Atom</a></div><div class="tocItem" style="margin-left:0px"><a href="#14. Grails and Spring">14. Grails and Spring</a></div><div class="tocItem" style="margin-left:10px"><a href="#14.1 The Underpinnings of Grails">14.1 The Underpinnings of Grails</a></div><div class="tocItem" style="margin-left:10px"><a href="#14.2 Configuring Additional Beans">14.2 Configuring Additional Beans</a></div><div class="tocItem" style="margin-left:10px"><a href="#14.3 Runtime Spring with the Beans DSL">14.3 Runtime Spring with the Beans DSL</a></div><div class="tocItem" style="margin-left:10px"><a href="#14.4 Property Placeholder Configuration">14.4 Property Placeholder Configuration</a></div><div class="tocItem" style="margin-left:10px"><a href="#14.5 Property Override Configuration">14.5 Property Override Configuration</a></div><div class="tocItem" style="margin-left:0px"><a href="#15. Grails and Hibernate">15. Grails and Hibernate</a></div><div class="tocItem" style="margin-left:10px"><a href="#15.1 Mapping with Hibernate Annotations">15.1 Mapping with Hibernate Annotations</a></div><div class="tocItem" style="margin-left:10px"><a href="#15.2 Further Reading">15.2 Further Reading</a></div><div class="tocItem" style="margin-left:0px"><a href="#16. Scaffolding">16. Scaffolding</a></div>
		</div>     
		<div id="content">
			<h1><a name="1. Introduction">1. Introduction</a></h1>오늘날의 현재 자바 웹 개발은 필요 이상으로 너무 복잡하다. 요즘 자바진영에 있는 대부분의 웹 프레임워크들은 지나치게 복잡하고, DRY(Don't Repeat Yourself)의 원칙을 따르고 있지않다.<p class="paragraph"/>Rails, Django, TurboGear같은 동적 프레임워크는 웹 어플리케이션을 좀 더 현대적으로 생각해 볼 수 있게 해주었다. Grails는 이러한 개념위에 탄생했고 자바 플랫폼에서 웹 어플리케이션을 개발하는 일을 획기적으로 단순화시킨다. 하지만 Grails가 다른 프레임워크와의 차이점은 Spring이나 Hibernate같이 구현된 자바 기술을 활용하여 구현됐다는 점이다.<p class="paragraph"/>Grails는 풀스택 프레임워크다. 그리고 Grails의 핵심기술 및 Grails의 플러그인을 이용해서 웹 개발이라는 퍼즐을 풀려한다. 그 안에는 다음과 같은 것을 포함한다.
<ul class="star">
<li><a href="http://www.hibernate.org" target="blank">Hibernate</a>를 기반으로 만들어진 손쉽게 사용할 수 있는 ORM</li>
<li>GSP(Groovy Server Pages)라 불리는 풍부한 뷰 기술</li>
<li><a href="http://www.springframework.org" target="blank">Spring</a> 에서 사용된 MVC모델의 컨트롤러 레이어.</li>
<li>Groovy로 강력해진 <a href="http://groovy.codehaus.org/Gant" target="blank">Gant</a> 를 이용한 명령줄 스크립트 환경</li>
<li>실행 중 로드를 기본으로 지원하는&#60;sup&#62;configured&#60;/sup&#62; Jetty 컨테이너의 탑재</li>
<li><a href="http://www.springframework.org" target="blank">Spring</a> 컨테이너에의한 의존성 주입&#60;sup&#62;Dependency injection&#60;/sup&#62;</li>
<li>Spring의 MessageSource 개념에 기반한 국제화 지원(i18n)</li>
<li>Spring의 트랜잭션 추상화 기능에 기반한 트랜잭션 서비스 레이어</li>
</ul><p class="paragraph"/>이 모든 것을 <a href="http://groovy.codehaus.org" target="blank">Groovy</a> 언어와 DSL(Domain Specific Languages)를 통해서 사용하기 쉽게 만들었다.<p class="paragraph"/>이 문서는 당신이 Grails를 시작하고, 또 Grails 프레임워크로 웹 어플리케이션을 만들 수 있도록 안내할 것이다.<h1><a name="2. Getting Started">2. Getting Started</a></h1><h2><a name="2.1 Downloading and Installing">2.1 Downloading and Installing</a></h2>Grails를 시작하고 작동시키기 위해서 처음해야 하는 일은 배포본을 설치하는 것이다. 천천히 다음 단계들을 따라하라.
<ul class="star">
<li>Grails의 바이너리 배포본을 <a href=":http://grails.org/Download">다운</a> 받고, 원하는 위치에 다운받은 zip파일의 압축을 푼다.</li>
<li>zip파일의 압축을 푼곳으로 GRAILS_HOME이라는 환경변수를 설정한다.</li>
<ul class="star">
<li>Unix/Linux 환경에서는 일반적으로 프로필 파일에 <code>export GRAILS_HOME=/path/to/grails</code> 와 같은 것을 추가시키는 방법을 사용한다.</li>
<li>윈도우 환경에서는 일반적으로 내 <code>컴퓨터/속성/고급/환경변수</code> 에서 설정한다.</li>
</ul>
<li>이제 당신의 <code>PATH</code> 변수에 Grails의 <code>bin</code> 디렉토리를 설정해야한다.</li>
<ul class="star">
<li>Unix/Linux 환경에서는 <code>export PATH="$PATH:$GRAILS_HOME/bin"</code>를 실행하는 것으로 설정할 수 있다.</li>
<li>윈도우즈 환경에서는 내 컴퓨터/속성/환경변수에 있는 <code>Path</code> 환경변수를 수정함으로써 설정 할 수 있다.</li>
</ul></ul><p class="paragraph"/>만약 Grails가 정상적으로 동작한다면 당신은 터미널 윈도우에서 grails를 타이핑하고서, 다음과 같은 결과물을 볼 수 있다.<p class="paragraph"/><pre class="bq"><code>
Welcome to Grails 1.0 - http://grails.org/
Licensed under Apache Standard License 2.0
Grails home is set to: /Developer/grails-1.0
No script name specified. Use 'grails help' for more info</code></pre><p class="paragraph"/><h2><a name="2.2 Creating an Application">2.2 Creating an Application</a></h2>
Grails 어플리케이션을 생성하려면 먼저 다음과 같은 <code>grails</code> 명령어의 사용법에 익숙해질 필요가 있다.<p class="paragraph"/><div class="code"><pre>grails &#91;command name&#93;</pre></div><p class="paragraph"/>이제 create-app 명령어를 사용하여 어플리케이션을 생성할 수 있다.<p class="paragraph"/>tc.
grails create-app helloworld<p class="paragraph"/>
이 명령어는 현재 디렉토리 위치에 프로젝트를 담고있는 새로운 디렉토리를 만들어 줄 것이다. 당신은 이제 터미널에서 이 디렉토리를 돌아다녀야 한다:<p class="paragraph"/><pre class="bq"><code>
cd helloworld</code></pre><p class="paragraph"/><h2><a name="2.3 A Hello World Example">2.3 A Hello World Example</a></h2>전형적인 "hello world!" 예제 프로그램을 구현하기 위해서는 <a href="../ref/Command Line/create-controller.html" class="commandLine">create-controller</a> 명령어를 사용한다.<p class="paragraph"/><pre class="bq"><code>
grails create-controller hello  </code></pre><p class="paragraph"/>이것은 <code>grails-app/controllers</code> 디렉토리 안에 <code>HelloController.groovy</code> 라는 새로운 컨트롤러를 생성할 것이다(더 많은 정보를 원한다면 <a href="../guide/single.html#6.1 Controllers" class="guide">컨트롤러</a> 절을 보라.)<p class="paragraph"/>컨트롤러는 웹 요청들을 처리할 수 있다. 그리고 다음과 같이 구현하여 "hello world!"라는 메시지를 출력할 수 있다.<p class="paragraph"/><div class="code"><pre>class HelloController &#123;<p class="paragraph"/>    def world = &#123;
            render <span class="java&#45;quote">"Hello World!"</span>
     &#125; 
&#125;</pre></div><p class="paragraph"/>다했다. 이제 또 다른 명령어인 <a href="../ref/Command Line/run-app.html" class="commandLine">run-app</a>로 컨테이너를 실행시킨다.<p class="paragraph"/><pre class="bq"><code>
grails run-app</code></pre><p class="paragraph"/>이 명령어로 8080포트로 서버를 실행시키고나서 <code>http://localhost:8080/helloworld</code> 와 같은 URL로 해당 어플리케이션에 접속할 수 있다.<p class="paragraph"/>결과는 다음의 스크린샷과 같이 나올 것이다.<p class="paragraph"/><img border="0" class="center" src="../img/intropage.png"></img><p class="paragraph"/>이 것은 <code>web-app/index.gsp</code> 로 렌더링된 Grails의 소개페이지이다. 이 페이지에는 컨트롤러들이 보여질 것이고 컨트롤러의 링크를 클릭하면 브라우저 윈도우에 "Hello World!"라고 출력되는 것을 보게 될 것이다.
<h2><a name="2.4 Getting Set-up in an IDE">2.4 Getting Set-up in an IDE</a></h2><h4>IntelliJ IDEA</h4><p class="paragraph"/>현재 굉장히 성숙하고, 풍부한 기능을 가진 Groovy&#38;Grails IDE는 <a href="http://www.jetbrains.com/idea" target="blank">IntelliJ IDEA 7.0</a> 과 <a href="http://www.jetbrains.net/confluence/display/GRVY/Groovy+Home" target="blank">JetGroovy</a> 플러그인이다. Grails 개발팀은 커다란 프로젝트를 위해서 다른 IDE 환경을 넘어선 IDEA를 추천한다.<p class="paragraph"/><h4>TextMate</h4><p class="paragraph"/>Grails는 단순함에 초첨이 맞춰져 있기 때문에 단순한 텍스트 편집기를 사용하는 것도 가능하다. Mac의 <a href="http://macromates.com/" target="blank">TextMate</a> 에는 우수한 Groovy/Grails 번들을 가졌다. <a href="http://wiki.macromates.com/Main/SubversionCheckout" target="blank">Texmate bundles SVN</a>에서 이용할 수 있다.<p class="paragraph"/><h4>Eclipse</h4><p class="paragraph"/><a href="http://www.eclipse.org/" target="blank">Eclipse</a> 위해서 여기에 또 문법 강조와 코드 완성등을 해주는 <a href="http://groovy.codehaus.org/Eclipse+Plugin" target="blank">Groovy Eclipse Plugin</a> 이 있다.<p class="paragraph"/><blockquote class="note">
이 Groovy 이클립스 플러그인은 자주 변한다. 그 변화의 <a href="http://grails.org/Eclipse+IDE+Integration" target="blank">자세한 사항</a>은 Grails 위키에서 알 수 있다.
</blockquote><p class="paragraph"/>Grails는 자동적으로 이클립스의 <code>.project</code> 파일과 <code>classpath</code> 파일을 만든다. 그리고 "Package Explorer"창에서 오른쪽 버튼을 클릭을 하여 "Import"를 선택한 후 "Existing projext into Workspace"에서 그레일즈 프로젝트가 있는 곳을 "Browse"하는 것으로 Grails 프로젝트를 추가시킬 수 있다.<p class="paragraph"/>그리고 "Finish"를 누른 다음에 나오는 "Ok"를 클릭하면 프로젝트는 설치된다.<p class="paragraph"/>또한 Grails는 적당한 이클립스 실행 설정을 자동으로 셋업한다. 이것은 이클립스의 "Run"메뉴를 통해서 접근이 가능하다.
<h2><a name="2.5 Convention over Configuration">2.5 Convention over Configuration</a></h2>Grails는 "설정보다 관례"를 사용한다. 이 것은 이름과 파일의 위치를 명시적으로 설정하는 하지 않고 Grails가 제공하는 디렉토리 구조에 익숙해져야 하는 것을 의미한다.<p class="paragraph"/>여기에 Grails의 상세 내역과 관련된 링크가 있다.
<ul class="star">
<li><code>grails-app</code> - 그루비 소스코드의 최상위 레벨의 디렉토리</li>
<ul class="star">
<li><code>conf</code> - <a href="../guide/single.html#3. Configuration" class="guide">설정 소스</a>.</li>
<li><code>controllers</code> - MVC에서 C인 <a href="../guide/single.html#6.1 Controllers" class="guide">웹 컨트롤러</a></li>
<li><code>domain</code> - The <a href="../guide/single.html#5. Object Relational Mapping (GORM)" class="guide">어플리케이션의 도메인</a>.</li>
<li><code>i18n</code> - <a href="../guide/single.html#10. Internationalization" class="guide">국제화 (i18n)</a> 를 위한 지원.</li>
<li><code>services</code> - <a href="../guide/single.html#8. The Service Layer" class="guide">서비스 계층</a>.</li>
<li><code>taglib</code> - <a href="../guide/single.html#6.3 Tag Libraries" class="guide">태그 라이브러리</a>.</li>
<li><code>views</code> - <a href="../guide/single.html#6.2 Groovy Server Pages" class="guide">Groovy 서버 페이지</a>.</li>
</ul>
<li><code>scripts</code> - <a href="../guide/single.html#4. The Command Line" class="guide">Gant 스크립트</a>.</li>
<li><code>src</code> - 지원 소스 코드</li>
<ul class="star">
<li><code>groovy</code> - 기타 Groovy 소스</li>
<li><code>java</code> - 기타 Java 소스</li>
</ul>
<li><code>test</code>  - <a href="../guide/single.html#9. Testing" class="guide">단위/통합 테스트</a>.</li>
</ul><p class="paragraph"/><h2><a name="2.6 Running an Application">2.6 Running an Application</a></h2>Grails 어플리케이션은 <a href="../ref/Command Line/run-app.html" class="commandLine">run-app</a> 명령어를 사용해서 Jetty 서버에서 돌아갈 수 있다. Jetty서버는 기본적으로 8080포트를 사용한다.<p class="paragraph"/><div class="code"><pre>grails run&#45;app</pre></div><p class="paragraph"/><code>server.port</code> 인자를 이용해서 다른 포트를 사용할 수 있다.<p class="paragraph"/><div class="code"><pre>grails &#45;Dserver.port=8090 run&#45;app</pre></div><p class="paragraph"/><a href="../ref/Command Line/run-app.html" class="commandLine">run-app</a> 에 대한 더 많은 정보는 레퍼런스 가이드에서 얻을 수 있다.
<h2><a name="2.7 Testing an Application">2.7 Testing an Application</a></h2>Grails의 <code>create-*</code>형식의 명령어들은 t<code>est/integration</code> 디렉토리에 통합 테스트들을 자동적으로 만든다. 물론 <a href="../guide/single.html#9. Testing" class="guide">테스트</a> 에 대한 장에서 설명하는 정보와 테스트 로직에 부합하도록 내용을 채우는 일은 당신의 몫이다. 하지만 만약 테스트를 실행하기를 원한다면 당신은 다음과 같이 <a href="../ref/Command Line/test-app.html" class="commandLine">test-app</a> 명령어를 사용할 수 있다.<p class="paragraph"/><div class="code"><pre>grails test&#45;app</pre></div><p class="paragraph"/>Grails는 <a href="../ref/Command Line/test-app.html" class="commandLine">test-app</a> 명령어와 동일하게 동작하는 Ant의 <code>build.xml</code> 파일을 자동으로 만들어준다.<p class="paragraph"/>
<div class="code"><pre>ant test</pre></div><p class="paragraph"/>이것을 통해 CruiseControl같은 지속적 통합(continuous integration) 플랫폼을 유용하게 사용할 수 있다<h2><a name="2.8 Deploying an Application">2.8 Deploying an Application</a></h2>Grails 어플리케이션은 WAR(Web Application Archieves) 파일로 설치할 수 있다. <a href="../ref/Command Line/war.html" class="commandLine">war</a> 명령어를 사용하여 만들 수 있다:<p class="paragraph"/><div class="code"><pre>grails war</pre></div><p class="paragraph"/>프로젝트 루트에 WAR파일이 생성될 것이다. 이제 각 컨테이너의 사용법에 따라 설치할 수 있다.<p class="paragraph"/><blockquote class="warning">
결코 Grails의 <a href="../ref/Command Line/run-app.html" class="commandLine">run-app</a> 명령을 사용하여 실제로 서비스하지 말아라. Grails의 이 명령어는 서버 성능이나 확장성이 중요한 런타임에도 자동으로 reload 하도록 설정돼 있다.
</blockquote><p class="paragraph"/>Grails를 설치할때에는 컨테이너의 JVM에 충분히 메모리를 할당하고 <code>-server</code> 옵션을 사용해야 한다. 다음은 권장하는 VM 옵션들이다.<p class="paragraph"/><div class="code"><pre>&#45;server &#45;Xmx512M</pre></div><h2><a name="2.9 Supported Java EE Containers">2.9 Supported Java EE Containers</a></h2>Grails는 다음과 같이 꽤 많은 컨테이너들을 지원한다.
<ul class="star">
<li>Tomcat 5.5</li>
<li>Tomcat 6.0</li>
<li>GlassFish v1 (Sun AS 9.0)</li>
<li>GlassFish v2 (Sun AS 9.1)</li>
<li>Sun App Server 8.2</li>
<li>Websphere 6.1</li>
<li>Websphere 5.1</li>
<li>Resin 3.2</li>
<li>Oracle AS</li>
<li>JBoss 4.2</li>
<li>Jetty 6.1</li>
<li>Jetty 5</li>
<li>Weblogic 7/8/9/10</li>
</ul><p class="paragraph"/>몇몇 컨테이너들는 버그가 있지만 대부분의 경우에는 잘 동작한다. <a href="http://grails.org/Deployment" target="blank">설치에 관한 문제</a>는 Grails 위키에서 찾을 수 있다.<p class="paragraph"/>Some containers have bugs however, which in most cases can be worked around. A <a href="http://grails.org/Deployment" target="blank">list of known deployment issues</a> can be found on the Grails wiki.<h2><a name="2.10 Creating Artefacts">2.10 Creating Artefacts</a></h2>Grails는 <a href="../ref/Command Line/create-controller.html" class="commandLine">create-controller</a>, <a href="../ref/Command Line/create-domain-class.html" class="commandLine">create-domain-class</a> 등과 같은 편리한 명령어를 지원한다. 이 것들은 컨트롤러를 생성하거나 다른 타입의 아티펙트들을 만들어줄 것이다.<p class="paragraph"/><blockquote class="note">
여기에 있는 것이 전부가 아니다. IDE나 익숙한 텍스트 편집기를 바로 사용하는 것도 쉽다.
</blockquote><p class="paragraph"/>예를 들어 다음과 같이 어플리케이션을 만들 때 기본적으로 필요한 <a href="../guide/single.html#5. Object Relational Mapping (GORM)" class="guide">도메인 모델</a>을 만든다:<p class="paragraph"/><div class="code"><pre>grails create&#45;domain&#45;class book</pre></div><p class="paragraph"/>도메인 클래스가 grails-app/domain/Book.groovy 파일이 만들어진다. 그 내용은 다음과 같다:<p class="paragraph"/><div class="code"><pre>class Book &#123;	
&#125;</pre></div><p class="paragraph"/>Grails에는 많은 <code>create-*</code> 와 같은 명령어가 있다. 이 것들은 명령줄 레퍼런스 가이드에서 찾아볼 수 있다.
<h2><a name="2.11 Generating an Application">2.11 Generating an Application</a></h2>Grails를 시작할 때 어플리케이션의 뼈대를 만들어주는 <a href="../guide/single.html#16. Scaffolding" class="guide">스케폴드</a> 라는 특징은 매우 유용하다. <code>generate-*</code> 명령어들 중에서 하나를 사용하여 만들 수 있고 <a href="../ref/Command Line/generate-all.html" class="commandLine">generate-all</a> 을 사용하면 관계된 <a href="../guide/single.html#6.1 Controllers" class="guide">컨트롤러</a> 와 <a href="../guide/single.html#6.2 Groovy Server Pages" class="guide">뷰</a> 가 생성될 것이다.<p class="paragraph"/><div class="code"><pre>grails generate&#45;all Book</pre></div><p class="paragraph"/><h1><a name="3. Configuration">3. Configuration</a></h1>"설정보다 관례"를 지향하는 프레임워크에서 이런 주제를 다루는게 이상하게 보일 것이다. 하지만 설정할 것이 있긴 있기 때문에 이에 대해 짚고 넘어갈 필요가 있다.<p class="paragraph"/>실제로 Grails를 전혀 설정하지 않고서도 개발할 수 있다. Grails에는 내장 컨테이너와 HSQLDB라는 메모리 데이터베이스가 탑재돼 있어서 데이터베이스 설정조차 필요없다.<p class="paragraph"/>하지만 때가 되면 실제 데이터베이스를 사용하고 싶어질 것이고 그 방법은 이 장에서 설명한다.<h2><a name="3.1 Basic Configuration">3.1 Basic Configuration</a></h2>일반적인 설정을 위해서 grails는 <code>grails-app/conf/Config.groovy</code> 라는 파일을 제공한다. 이 파일은 groovy의 <a href="http://groovy.codehaus.org/ConfigSlurper를" target="blank">ConfigSlurper</a> 사용한다. ConfigSlurper는 순수 groovy로 만들어졌다는 것을 제외하고는 자바 프로퍼티 파일과 매우 유사하다. 따라서 적절한 자바 타입과 변수를 재사용 할 수 있다.<p class="paragraph"/>예를 들어, 다음과 같이 설정을 추가할 수 있다:<p class="paragraph"/><div class="code"><pre>foo.bar.hello = <span class="java&#45;quote">"world"</span></pre></div><p class="paragraph"/>그리고 나서 어플리케이션에서 두 가지 방법으로 이 설정에 접근할 수 있다. 컨트롤러나 태그라이브러리에서 사용가능한 <a href="../api/org/codehaus/groovy/grails/commons/GrailsApplication.html" class="api">GrailsApplication</a> 객체를 통해서 접근하는 것이 가장 일반적이다:<p class="paragraph"/><div class="code"><pre>assert <span class="java&#45;quote">"world"</span> == grailsApplication.config.foo.bar.hello</pre></div><p class="paragraph"/>두번째 방법으로 설정 객체를 참조하고 있는 <a href="../api/org/codehaus/groovy/grails/commons/ConfigurationHolder.html" class="api">ConfigurationHolder</a> 사용할 수도 있다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> org.codehaus.groovy.grails.commons.&#42;
&#8230;
def config = ConfigurationHolder.config
assert <span class="java&#45;quote">"world"</span> == config.foo.bar.hello</pre></div>
<h2><a name="3.1.1 Built in options">3.1.1 Built in options</a></h2>Grails는 다음과 같은 설정 옵션을 제공한다.
<ul class="star">
<li>grails.config.locations - 프로퍼티 파일이나 추가할 Grails의 설정 파일의 위치를 나타낸다. 추가된 Grails의 설정 파일은 메인 설정파일과 통합돼야 한다.</li>
<li>grails.enable.native2ascii - 만약 Grails의 i18n 프로퍼티 파일의 native2ascii 전환이 필요없다면 false로 세팅하라</li>
<li>grails.views.default.codec - GSP를 위한 기본 인코딩을 지정한다. - 'none', 'html', 'base64'중에 하나로 설정할 수 있다. (기본은 'none'이다.) XSS 공격의 위험을 줄이려면 'html'로 바꿔라.</li>
<li>grails.views.gsp.encoding - GSP 소스파일에서 사용되는 파일 인코딩 (기본적으로 'utf-8'로 되어있다)</li>
<li>grails.war.destFile - <a href="../ref/Command Line/war.html" class="commandLine">war</a> 명령어로 WAR 파일을 생성 할 장소를 지정한다.</li>
<li>grails.mime.file.extensions - Content Negotiation의 마임 타입에서 사용할 파일 확장자를 지정한다.</li>
<li>grails.mime.types - Grails에서 Content Negotiation에 사용할 MIME 타입을 맵 형식으로 지정한다.</li>
<li><code>grails.serverURL</code> - 서버의 도메인 이름을 포함한 URL의 절대경로 서버 주소. 예, grails.serverURL="http://my.yourportal.com" . <a href="../ref/Tags/createLink.html" class="Tags">createLink</a> 참조.</li>
</ul><p class="paragraph"/><h2><a name="3.1.2 Logging">3.1.2 Logging</a></h2><h4>Logging Basics</h4><p class="paragraph"/>Grails는 <a href="http://logging.apache.org/log4j/1.2/index.html" target="blank">Log4j</a> 로그 시스템에 기반한 공통의 '설정 매커니즘'을 사용한다. <code>grails-app/conf</code> 디렉토리에 있는 <code>Config.groovy</code>를 수정하여 로깅을 설정하고 <code>Config.groovy</code>파일 하나로 <code>development</code>, <code>test</code>, <code>production</code>의 각 환경에 맞게 로깅 구성을 따로 정할 수 있다. Grails는 <code>Config.groovy</code>파일을 처리해서 <code>web-app/WEB-INF/classes</code> 디렉토리 안에 알맞은 <code>log4j.properties</code> 파일을 생성한다.<p class="paragraph"/>Grails의 일반적인 Log4j 설정은 다음과 같다:<p class="paragraph"/><div class="code"><pre>log4j &#123;
    appender.stdout = <span class="java&#45;quote">"org.apache.log4j.ConsoleAppender"</span>
	appender.'stdout.layout'=<span class="java&#45;quote">"org.apache.log4j.PatternLayout"</span>
    rootLogger=<span class="java&#45;quote">"error,stdout"</span>
    logger &#123;
        grails=<span class="java&#45;quote">"info,stdout"</span>
        org &#123;
            grails.spring=<span class="java&#45;quote">"info,stdout"</span>
            codehaus.groovy.grails.web=<span class="java&#45;quote">"info,stdout"</span>
            codehaus.groovy.grails.commons=<span class="java&#45;quote">"info,stdout"</span>
            &#8230;
        &#125;
&#125;
&#125;</pre></div><p class="paragraph"/>표준 Log4j 프로퍼티 파일 스타일을 선호한다면 groovy 멀티라인 문자열을 사용할 수 있다:<p class="paragraph"/><div class="code"><pre>log4j = '''
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
&#35; ...remaining configuration
'''</pre></div><p class="paragraph"/>여기에 유용한 logger를 소개한다:
<ul class="star">
<li>org.codehaus.groovy.grails.commons - 클래스 로딩과 같은 중요한 정보</li>
<li>org.codehaus.groovy.grails.web - Grails의 웹 요청 처리</li>
<li>org.codehaus.groovy.grails.web.mapping - URL 매핑 디버깅</li>
<li>org.codehaus.groovy.grails.plugins - 로그 플러그인의 행동</li>
<li>org.springframework - Spring이 하는 일</li>
<li>org.hibernate - Hibernate가 하는 일</li>
</ul><p class="paragraph"/><h4>Full stacktraces</h4><p class="paragraph"/>예외가 발생 했을 때 자바와 Groovy 내부에서부터 스택을 트레이스하면 심한 노이즈가 있을 수 있다. Grails는 보통 관련이 없는 것들을 걸러내고 중요하지 않은 Grails/Groovy 클래스 패키지만을 Trace하도록 제한한다. Grails는 보통 그러한 관련이 없는 것들을 필터링 해주고, 핵심 Grails/Groovy 클래스 패키지가 아닌 것으로 Trace를 제한하고 있다.<p class="paragraph"/>예외가 발생하면, 전체 추적 내용은 항상 StackTrace 로거에 씌여진다. StackTrace는 <code>stacktrace.log</code> 파일에 기록하지만 Congfig.groovy파일을 이용해서 원하는 곳에 기록하도록 할 수 있다. 예를 들어 만약에 표준 출력으로 전체 추적 내용을 기록하고 싶다면 다음과 같은 설정을:<p class="paragraph"/><div class="code"><pre>StackTrace=<span class="java&#45;quote">"error,errors"</span></pre></div><p class="paragraph"/>다음과 같이 바꾼다:<p class="paragraph"/><div class="code"><pre>StackTrace=<span class="java&#45;quote">"error,stdout"</span></pre></div><p class="paragraph"/><code>grails.full.stacktrace</code> VM 프로퍼티을 <code>true</code>로 설정을 해서 스택 트레이스 필터링을 끌 수 있다.<p class="paragraph"/><div class="code"><pre>grails &#45;Dgrails.full.stacktrace=<span class="java&#45;keyword">true</span> run&#45;app</pre></div><p class="paragraph"/><h4>Logging by Convention</h4><p class="paragraph"/>어플리케이션의 모든 아티펙트에는 <code>log</code> 프로퍼티을 동적으로 추가할 수 있다. 아티펙트는 <a href="../guide/single.html#5. Object Relational Mapping (GORM)" class="guide">도메인 클래스</a>, <a href="../guide/single.html#6.1 Controllers" class="guide">컨트롤러</a>, 태그 라이브러리 등을 말한다. 이것의 사용법은 다음과 같다:<p class="paragraph"/><div class="code"><pre>def foo = <span class="java&#45;quote">"bar"</span>
log.debug <span class="java&#45;quote">"The value of foo is $foo"</span></pre></div><p class="paragraph"/>로그의 이름은 <code>grails.app.&#60;아티펙트 타입&#62;.ClassName</code> 과 같은 관례에 따른다. 다음은 다양한 Grails 아티펙트에 로그를 설정하는 예이다:<p class="paragraph"/><div class="code"><pre>&#35; Set level <span class="java&#45;keyword">for</span> all application artefacts
log4j.logger.grails.app=<span class="java&#45;quote">"info, stdout"</span><p class="paragraph"/>&#35; Set <span class="java&#45;keyword">for</span> a specific controller
log4j.logger.grails.app.controller.YourController=<span class="java&#45;quote">"debug, stdout"</span><p class="paragraph"/>&#35; Set <span class="java&#45;keyword">for</span> a specific domain class
log4j.logger.grails.app.domain.Book=<span class="java&#45;quote">"debug, stdout"</span><p class="paragraph"/>&#35; Set <span class="java&#45;keyword">for</span> a specific taglib
log4j.logger.grails.app.tagLib.FancyAjax=<span class="java&#45;quote">"debug, stdout"</span><p class="paragraph"/>&#35; Set <span class="java&#45;keyword">for</span> all taglibs
log4j.logger.grails.app.tagLib=<span class="java&#45;quote">"info, stdout"</span></pre></div><p class="paragraph"/>아티펙트들의 이름은 관례에 따른다. 다음은 일반적인 아티펙트들의 목록이다.
<ul class="star">
<li>bootstrap - 부트스트랩 클래스들을 위한 아티펙트</li>
<li>dataSource - data source들을 위한 아티펙트</li>
<li>tagLib - 태그 라이브러리를 위한 아티펙트</li>
<li>service - 서비스 클래스들을 위한 아티펙트</li>
<li>controller - 컨트롤러들을 위한 아티펙트</li>
<li>domain - 도메인 요소들을 위한 아티펙트</li>
</ul><p class="paragraph"/><h2><a name="3.2 Environments">3.2 Environments</a></h2><h4>Per Environment Configuration (환경별 설정)</h4><p class="paragraph"/>Grails는 환경마다 설정할 수 있다. grails-app/conf디렉토리에 있는 Config.groovy파일과, DataSource.groovy파일이 환경단위로 설정할 수 있도록 돕는다. 각 파일들은 <a href="http://groovy.codehaus.org/ConfigSlurper" target="blank">ConfigSlurper</a> 의 문법을 따른다. 다음은 Grails에서 제공하는 기본 DataSource의 정의를 예로 든 것이다.<p class="paragraph"/><div class="code"><pre>dataSource &#123;
    pooled = <span class="java&#45;keyword">false</span>                          
    driverClassName = <span class="java&#45;quote">"org.hsqldb.jdbcDriver"</span>	
    username = <span class="java&#45;quote">"sa"</span>
    password = <span class="java&#45;quote">""</span>				
&#125;
environments &#123;
    development &#123;
        dataSource &#123;
            dbCreate = <span class="java&#45;quote">"create&#45;drop"</span> // one of 'create', 'createeate&#45;drop','update'
            url = <span class="java&#45;quote">"jdbc:hsqldb:mem:devDB"</span>
        &#125;
    &#125;   
    test &#123;
        dataSource &#123;
            dbCreate = <span class="java&#45;quote">"update"</span>
            url = <span class="java&#45;quote">"jdbc:hsqldb:mem:testDb"</span>
        &#125;
    &#125;   
    production &#123;
        dataSource &#123;
            dbCreate = <span class="java&#45;quote">"update"</span>
            url = <span class="java&#45;quote">"jdbc:hsqldb:file:prodDb;shutdown=<span class="java&#45;keyword">true</span>"</span>
        &#125;
    &#125;
&#125;</pre></div><p class="paragraph"/>최상위 수준에 정의한 설정을 기억해야 한다. environments 블럭에는 DataSource의 url 프로퍼티과 dbCreate를 위해 환경마다 블럭을 정의하였다. 이 문법은 Config.groovy에서도 사용된다.<p class="paragraph"/><h4>Packaging and Running for Different Environments (다양한 환경을 위한 패키징과 실행)</h4><p class="paragraph"/>Grails는 특정 환경단위로 <a href="../guide/single.html#4. The Command Line" class="guide">명령</a>을 실행할 수 있도록 지원한다. 그 형식은 다음과 같다:<p class="paragraph"/><div class="code"><pre>grails &#91;environment&#93; &#91;command name&#93;</pre></div><p class="paragraph"/>또한 Grails에는 dev, prod, test이라는 미리 만들어진 환경이 3개있다. dev, prod, test는 각각 개발(development), 서비스(production), 테스트(test)를 위한 것이다. 예를 들어 테스트 환경에서 WAR를 만들기 위해서는 명령어를 다음과 같이 사용해야 한다.<p class="paragraph"/><div class="code"><pre>grails test war</pre></div><p class="paragraph"/>만약에 또 다른 환경을 가지고 있다면 <code>grails.env</code> 변수를 통해서 그 환경을 지정할 수 있다. 아래는 그 예이다:<p class="paragraph"/><div class="code"><pre>grails &#45;Dgrails.env=UAT run&#45;app</pre></div><p class="paragraph"/><h4>Programmatic Environment Detection (프로그램에 의한 환경 검사)</h4><p class="paragraph"/><a href="../api/grails/util/GrailsUtil.html" class="api">GrailsUtil</a> 클래스를 Gant 스크립트나 부트스트랩 클래스 같은 곳에 사용함으로써 환경을 찾아낼 수 있다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> grails.util.GrailsUtil<p class="paragraph"/>...<p class="paragraph"/><span class="java&#45;keyword">switch</span>(GrailsUtil.environment) &#123;
	<span class="java&#45;keyword">case</span> <span class="java&#45;quote">"development"</span>:
	   configureForDevelopment()
	<span class="java&#45;keyword">break</span>
	<span class="java&#45;keyword">case</span> <span class="java&#45;quote">"production"</span>:
	   configureForProduction()
	<span class="java&#45;keyword">break</span> 
&#125;</pre></div><h2><a name="3.3 The DataSource">3.3 The DataSource</a></h2>Grails는 자바로 만들어졌기 때문에 data source를 설정하려면 JDBC에 대한 약간의 지식이 필요하다(자바 데이터베이스 접속과는 관계없는 지식).<p class="paragraph"/>만약 HSQLDB외에 다른 DB를 사용하고 싶다면, 필수적으로 JDBC드라이버가 필요하다. MySQL을 예로 들자면 <a href="http://www.mysql.com/products/connector/j/" target="blank">Connector/J</a> 가 필요하다.<p class="paragraph"/>드라이버는 일반적으로 JAR 아카이브 형대로 배포된다. JAR파일을 프로젝트의 lib 디렉토리에 넣어라.<p class="paragraph"/>일단 <code>grails-app/conf/DataSource.groovy</code> 에 있는 DataSource descriptor파일에 JAR에 대한 정보가 있어야 한다. 그 파일은 다음과 같은 정보들은 DataSource에 대한 정의를 담고 있다.
<ul class="star">
<li>driverClassName - JDBC 드라이버의 클래스 이름</li>
<li>username - JDBC 연결하는데에 사용될 사용자 이름</li>
<li>password - JDBC 연결하는데에 사용될 비밀번호</li>
<li>url - 데이터베이스의 JDBC URL</li>
<li>dbCreate - 도메인 모델의 데이터베이스를 자동으로 생성할지 안할지 결정하는 플래그</li>
<li>pooled - 컨넥션의 풀을 사용할것인가를 결정하는 플래그(기본은 true)</li>
<li>logSql - SQL 로깅여부를 결정</li>
<li>dialect - Hibernate의 표현식(dialect)으로 표현되는 문자열이나 클래스는 데이터베이스를 통해서 통신한다. Hibernate의 문법을 사용하려면, <a href="http://www.hibernate.org/hib_docs/v3/api/org/hibernate/dialect/package-summary.html" target="blank">org.hibernate.dialect</a>t 패키지를 참고하라.</li>
</ul><p class="paragraph"/>MySQL에 대한 일반적인 설정은 아마도 다음과 같을 것이다.<p class="paragraph"/><div class="code"><pre>dataSource &#123;
	pooled = <span class="java&#45;keyword">true</span>
	dbCreate = <span class="java&#45;quote">"update"</span>
	url = <span class="java&#45;quote">"jdbc:mysql://localhost/yourDB"</span>
	driverClassName = <span class="java&#45;quote">"com.mysql.jdbc.Driver"</span>
	username = <span class="java&#45;quote">"yourUser"</span>
	password = <span class="java&#45;quote">"yourPassword"</span>	
&#125;</pre></div><p class="paragraph"/><blockquote class="warning">
DataSource를 설정할 때에는 타입이나 def 키워드를 사용하지 않는다. 왜냐하면 Groovy는 그러한 문법들을 지역변수를 정의한 것으로 보고 처리하지 않을 것이기 때문이다. 예를 들어 다음과 같은 경우는 잘못된 것이다.
</blockquote><p class="paragraph"/><div class="code"><pre>dataSource &#123;
	<span class="java&#45;object">boolean</span> pooled = <span class="java&#45;keyword">true</span> // type declaration results in local variable
	&#8230;
&#125;</pre></div><p class="paragraph"/><h2><a name="3.3.1 DataSources and Environments">3.3.1 DataSources and Environments</a></h2>이전의 구성 예는 모든 환경(서비스, 테스트, 개발등)이 같다고 가정하였다.<p class="paragraph"/>하지만, Grails는 DataSource를 "환경 별로(environment aware)" 정의할 수 있다다. 따라서 다음과 같이 할 수 있다.<p class="paragraph"/><div class="code"><pre>dataSource &#123;
	// common settings here
&#125;                     
environments &#123;
  production &#123;
     dataSource &#123;
          url = <span class="java&#45;quote">"jdbc:mysql://liveip.com/liveDb"</span>					
     &#125;			
  &#125;
&#125;</pre></div>
<h2><a name="3.3.2 JNDI DataSources">3.3.2 JNDI DataSources</a></h2>많은 Java EE 컨테이너는 보통 JNDI(<a href="http://java.sun.com/products/jndi/" target="blank">Java Naming and Directory Interface</a> )의 DataSource 인스턴스를 제공한다. 그래서 DataSource를 통해서 JNDI를 사용해야 할 때도 있다.<p class="paragraph"/>아래와 같이 JNDI data source를 정의할 수 있다.<p class="paragraph"/><div class="code"><pre>dataSource &#123;
    jndiName = <span class="java&#45;quote">"java:comp/env/myDataSource"</span>
&#125;</pre></div><p class="paragraph"/>JNDI 이름의 형태는 컨테이너 마다 다를지도 모르지만, DataSource를 정의하는 방법은 똑같다.<p class="paragraph"/><h2><a name="3.3.3 Automatic Database Migration">3.3.3 Automatic Database Migration</a></h2>DataSource를 정의할 때 dbCreate 프로퍼티은 중요하다. 그 이유는 Grails가 런타임에 <a href="../guide/single.html#5. Object Relational Mapping (GORM)" class="guide">GORM</a> 클래스를 이용해 자동적으로 database 테이블를 생성하는 것을 결정하기 때문이다. 옵션들은 다음과 같다.
<ul class="star">
<li>create-drop - Grails를 실행할 때마다 데이터베이스를 삭제drop하고 다시 생성한다.</li>
<li>create - 데이터베이스가 없으면 생성하고 이미 존재할 경우에는 아무일도 하지 않는다. 하지만 데이터는 삭제한다.</li>
<li>update - 데이터베이스가 없으면 생성하고 이미 존재할 경우에는 변경한다.</li>
</ul><p class="paragraph"/><blockquote class="warning">
create-drop과 create 둘 다 이미 있는 데이터를 파괴하므로 사용에 주의해야 한다.
</blockquote><p class="paragraph"/><a href="../guide/single.html#3.2 Environments" class="guide">개발 환경</a> 에서의 dbCreate의 기본값은 “create-drop”이다.<p class="paragraph"/><div class="code"><pre>dataSource &#123;
	dbCreate = <span class="java&#45;quote">"create&#45;drop"</span> // one of 'create', 'create&#45;drop','update'
&#125;</pre></div><p class="paragraph"/>이것은 어플리케이션을 재시작 할 때마다 자동으로 db 테이블을 삭제하고 다시 생성한다. 확실히 이것은 실제 서비스에는 필요없다.<p class="paragraph"/><blockquote class="note">
비록 Grails가 지금은 Rails 스타일의 이전작업(Migrations)을 지원하고 있지 않지만, 현재 비슷한 기능의 플러그인이 두 개 있다. <a href="http://www.liquibase.org/manual/latest/grails.html" target="blank">LiquiBase</a> 플러그인과 <a href="http://code.google.com/p/dbmigrate/wiki/Grails" target="blank">DbMigrate</a> 플러그인을 <code>list-plugins</code> 명령어로 사용할 수 있다.
</blockquote><p class="paragraph"/><p class="paragraph"/><h2><a name="3.4 Externalized Configuration">3.4 Externalized Configuration</a></h2>기본 설정 파일인 <code>grails-app/conf</code> 에 있는 <code>Config.groovy</code> 는 주요 상황에서는 꽤 괜찮다. 하지만 메인 어플리케이션 구조 <em class="italic">바깥에</em> 구성 파일을 유지하고 싶을때가 있을 수 있다. 예를 들어, 어떤 관리자들은 WAR를 설치한 후에 설정을 변경하기 위하여 WAR을 다시 만들기 싫어서 어플리케이션의 설정을 외부로 빼고 싶어한다.<p class="paragraph"/>이렇게 설정하는 시나리오를 위해 설정을 어플리케이션 밖에 위치 시킬 수 있다. <code>Config.groovy</code> 파일 안에 <code>grails.config.locations</code> 설정을 다음과 같이 사용하여 설정 파일의 위치를 Grails에 알린다:<p class="paragraph"/><div class="code"><pre>grails.config.locations = &#91; <span class="java&#45;quote">"classpath:$&#123;appName&#125;&#45;config.properties"</span>,
                            <span class="java&#45;quote">"classpath:$&#123;appName&#125;&#45;config.groovy"</span>,
                            <span class="java&#45;quote">"file:$&#123;userHome&#125;/.grails/$&#123;appName&#125;&#45;config.properties"</span>,
                            <span class="java&#45;quote">"file:$&#123;userHome&#125;/.grails/$&#123;appName&#125;&#45;config.groovy"</span>&#93;</pre></div><p class="paragraph"/>이 예제는 클래스패스와 다른 경로인 <code>USER_HOME</code> 에 위치한 설정파일(Java 프로퍼티 파일과 <a href="http://groovy.codehaus.org/ConfigSlurper" target="blank">ConfigSlurper</a> 설정 모두)을 로드한다.<p class="paragraph"/>모든 설정은 결국 <a href="../api/org/codehaus/groovy/grails/commons/GrailsApplication.html" class="api">GrailsApplication</a> 객체의 <code>config</code> 프로퍼티로 합쳐지기 때문에 이를 이용해 설정에 접근할 수 있다.<p class="paragraph"/>
<blockquote class="note">
또 Grails는 Spring의 프로퍼티 플레이스홀더(placeholder)와 프로퍼티를 오버라이드하는 configurer 개념도 지원한다. 자세한 정보는 <a href="../guide/single.html#14. Grails and Spring" class="guide">Grails와 Spring</a> 에 대한 장에 있다.
</blockquote><h2><a name="3.5 Versioning">3.5 Versioning</a></h2><h4>Versioning Basics(버전 기초)</h4><p class="paragraph"/>Grails에는 어플리케이션 버전을 관리하는 기능이 내장되어 있다. <a href="../ref/Command Line/create-app.html" class="commandLine">create-app</a> 를 이용해서 어플리케이션을 처음 만들었을 때의 버전은 0.1이 된다. 버전은 프로젝트의 루트에 있는 <code>application.properties</code> 라는 어플리케이션 메타 데이터에 저장이 된다.<p class="paragraph"/>어플리케이션의 버전을 바꾸기 위해서는, set-version명령어를 사용한다.<p class="paragraph"/><div class="code"><pre>grails set&#45;version 0.2</pre></div><p class="paragraph"/>버전은 war 명령어뿐만 아니라 많은 명령어에서 사용된다. <a href="../ref/Command Line/war.html" class="commandLine">war</a> 명령어를 실행하면 생성되는 WAR파일의 끝에 어플리케이션의 버전을 덧붙혀진다.<p class="paragraph"/><h4>Detecting Versions at Runtime(런타임에 버전 알아내기)</h4><p class="paragraph"/>런타임에 어플리케이션의 버전을 알아낼 수 있다. Grails에서 제공하는 <a href="../api/org/codehaus/groovy/grails/commons/GrailsApplication.html" class="api">GrailsApplication</a> 클래스를 통해 어플케이션의 메타데이터에 접근한다. 예를 들어 <a href="../guide/single.html#6.1 Controllers" class="guide">컨트롤러</a> 에는 다음과 같이 사용할 수 있는 <a href="../ref/Controllers/grailsApplication.html" class="controllers">grailsApplication</a> 변수가 이미 있다:<p class="paragraph"/><div class="code"><pre>def version = grailsApplication.metadata&#91;'app.version'&#93;</pre></div><p class="paragraph"/>만약 Grails의 버전을 알고 싶다면 다음과 같이 사용할 수 있다.<p class="paragraph"/><div class="code"><pre>def grailsVersion = grailsApplication.metadata&#91;'app.grails.version'&#93;</pre></div><p class="paragraph"/>또는 <code>GrailsUtil</code> 클래스를 사용할 수도 있다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> grails.util.&#42;
def grailsVersion = GrailsUtil.grailsVersion</pre></div><p class="paragraph"/>
<h2><a name="3.6 Deployment">3.6 Deployment</a></h2><h4>빠른 설치</h4><p class="paragraph"/>실제 서비스(production) 환경에서는 Grails 어플리케이션들이 언제나 WAR파일로 설치된다. Grails 어플리케이션을 절대로 run-app명령어를 사용해서 설치하면 안된다. 왜냐하면, 그 명령어는 개발하는 동안 Grails를 auto-reloading을 하도록 구성하기 때문이다.<p class="paragraph"/>하지만 run-war명령어를 이용해 다음과 같이 쉽고 빠르게 Grails 어플리케이션을 실행 할 수 있다.<p class="paragraph"/><div class="code"><pre>grails prod run&#45;war</pre></div><p class="paragraph"/>80번 포트로 실행하도록 하는 방법이다.<p class="paragraph"/><div class="code"><pre>grails &#45;Dserver.port=80 prod run&#45;war</pre></div><p class="paragraph"/>그러면 WAR 파일이 생성되고 서비스production 환경의 WAR 파일은 Jetty를 이용해서 실행된다.<p class="paragraph"/><h4>WAR 설치</h4><p class="paragraph"/>이전에 WAR 설치에 대해 언급했었다. war 명령어는 WAR 파일을 만들기 위한 편의를 제공한다. WAR 파일은 다양한 Java EE 호환 컨테이너에 설치된다.<p class="paragraph"/>WAR 파일을 만들었다면 다음은 WAR 파일을 적당한 디렉토리에 넣어야 한다. 만악 컨테이너가 핫 디플로이먼트hot deployment를 지원한다면 자동으로 리로드될 것이고 그렇지 않으면 컨테이너를 재기동해야 할 것이다.<p class="paragraph"/>예를 들어 아파치 톰캣에서는 TOMCAT_HOME/webapps 디렉토리에 WAR를 놓고 컨테이너를 재시작하면 된다.<p class="paragraph"/>또 다른 컨테이너(특히 상업용)에서는 보통 웹 인터페이스를 제공한다. WAR파일을 웹 인터페이스로 실행중인 컨테이너에 올리고, 설치할 수 있다. 자세한 것은 해당 컨테이너에 대한 문서를 참조하고 설명대로 따라해야 한다.<p class="paragraph"/><h4>WAR 파일 생성 수정하기</h4><p class="paragraph"/>만약 WAR 생성과정을 변경해야 한다면 다양한 방법으로 변경할 수 있다. 만약 간단하게 WAR가 생성되는 장소를 변경하고 싶다면 다음과 같이 하면된다:<p class="paragraph"/><div class="code"><pre>grails war /my/container/path</pre></div><p class="paragraph"/>위 방법 대신에 Config.groovy파일의 grails.war.destFile 옵션을 설정해도 된다:<p class="paragraph"/><div class="code"><pre>grails.war.destFile=/my/container/path</pre></div><p class="paragraph"/>만약에 WAR 파일을 생성하는 동안 의존성들을 수정해야 한다면(예를들어 컨테이너가 공유 라이브러리를 지원한다면) 다음과 같이 특정한 Ant fileset을 grails.war.dependencies 옵션에 명시할 수 있다.<p class="paragraph"/><div class="code"><pre>grails.war.dependencies = &#123;
	fileset(dir:<span class="java&#45;quote">"/my/libs"</span>, includes:<span class="java&#45;quote">"&#42;.jar"</span>)
&#125;</pre></div><p class="paragraph"/>좀 더 유연하게 grails.war.resources를 설정할 수 있다. 이 설정에 WAR 파일을 어디에 생성할지 명시할 수 있다.<p class="paragraph"/><div class="code"><pre>grails.war.resources = &#123; warLocation &#45;&#62;
	copy(todir:<span class="java&#45;quote">"$warLocation/WEB&#45;INF"</span>) &#123;
		fileset(dir:<span class="java&#45;quote">"/my/configs"</span>, includes:<span class="java&#45;quote">"&#42;.xml"</span>)
	&#125;
&#125;</pre></div><h1><a name="4. The Command Line">4. The Command Line</a></h1>Grails의 명령어 시스템은 <a href="http://groovy.codehaus.org/Gant" target="blank">Gant</a>에 내장되어 있다. Gant는 단순히 <a href="http://ant.apache.org" target="blank">Apache Ant</a>의 그루비 래퍼(wrapper)이다.<p class="paragraph"/>하지만 관례와 명령어을 사용하기 때문에 Grails가 더 낫다. 다음과 같이 타이핑 했을 때:<p class="paragraph"/><div class="code"><pre>grails &#91;command name&#93;</pre></div><p class="paragraph"/>Grails 는 아래에 나오는 디렉토리에서 실행할 Gant 스크립트를 찾는다:
<ul class="star">
<li><code>USER_HOME/.grails/scripts</code></li>
<li><code>PROJECT_HOME/scripts</code></li>
<li><code>PROJECT_HOME/plugins/*/scripts</code></li>
<li><code>GRAILS_HOME/scripts</code></li>
</ul><p class="paragraph"/>또 Grails는 run-app와 같이 소문자로 되어있는 명령어 이름들을 소문자와 대문자가 섞여있는 형태로 변환할 것이다. 따라서 다음과 같이 치면<p class="paragraph"/><div class="code"><pre>grails run&#45;app</pre></div><p class="paragraph"/>다음과 같은 파일들을 찾아낼 것이다:
<ul class="star">
<li><code>USER_HOME/.grails/scripts/RunApp.groovy</code></li>
<li><code>PROJECT_HOME/scripts/RunApp.groovy</code></li>
<li><code>PROJECT_HOME/plugins/*/scripts/RunApp.groovy</code></li>
<li><code>GRAILS_HOME/scripts/RunApp.groovy</code></li>
</ul><p class="paragraph"/>만약 매치되는 것이 한 개가 아니라면 Grails는 실행할 것을 하나만 고른다. Gant 스크립트가 실행될 때 "default" 타겟이 실행된다.<p class="paragraph"/>몇몇 사용 가능한 명령어에 대한 도움말의 목록을 얻으려면 다음과 같이 치면 된다:<p class="paragraph"/><div class="code"><pre>grails help</pre></div><p class="paragraph"/>그러면 간단한 사용법과 Grails가 가지고 있는 명령어들이 출력된다:<p class="paragraph"/><div class="code"><pre>Usage (optionals marked with &#42;): 
grails &#91;environment&#93;&#42; &#91;target&#93; &#91;arguments&#93;&#42;<p class="paragraph"/>Examples: 
grails dev run&#45;app	
grails create&#45;app books<p class="paragraph"/>Available Targets (type grails help 'target&#45;name' <span class="java&#45;keyword">for</span> more info):
grails bootstrap
grails bug&#45;report
grails clean
grails compile
...</pre></div><p class="paragraph"/><blockquote class="note">
각각의 명령어들에 관해 더 자세히 알고 싶다면 레퍼런스 가이드의 왼쪽 메뉴에 있는 명령어 레퍼런스를 참조하라.
</blockquote>
<h2><a name="4.1 Creating Gant Scripts">4.1 Creating Gant Scripts</a></h2>현재 프로젝트의 루트에서 <a href="../ref/Command Line/create-script.html" class="commandLine">create-script</a> 명령어를 사용하여 Gant 스크립트를 만들 수 있다. 그 예로 다음과 같이 명령을 내리면<p class="paragraph"/><div class="code"><pre>grails create&#45;script compile&#45;sources</pre></div><p class="paragraph"/><code>script/CompileSources.groovy</code> 라는 스크립트가 만들어질 것이다. Gant 스크립트는 “타겟” 이라는 개념을 지원하고 그것에 의존한다는 것만 제외하면 Groovy 스크립트와 유사하다:<p class="paragraph"/><div class="code"><pre>target(<span class="java&#45;keyword">default</span>:<span class="java&#45;quote">"The <span class="java&#45;keyword">default</span> target is the one that gets executed by Grails"</span>) &#123;
	depends(clean, compile)
&#125;
target(clean:<span class="java&#45;quote">"Clean out things"</span>) &#123;
	Ant.delete(dir:<span class="java&#45;quote">"output"</span>)
&#125;
target(compile:<span class="java&#45;quote">"Compile some sources"</span>) &#123;
	Ant.mkdir(dir:<span class="java&#45;quote">"mkdir"</span>)
	Ant.javac(srcdir:<span class="java&#45;quote">"src/java"</span>, destdir:<span class="java&#45;quote">"output"</span>)
&#125;</pre></div><p class="paragraph"/>위의 스크립트에서 보여준 예처럼 Gant 스크립트에는 암묵적으로 <a href="http://ant.apache.org/manual/index.html" target="blank">Apache Ant API</a> 에 접근 할 수 있는 Ant의 변수가 사용된다.<p class="paragraph"/>You can also "depend" on other targets using the <code>depends</code> method demonstrated in the <code>default</code> target above.<h2><a name="4.2 Re-using Grails scripts">4.2 Re-using Grails scripts</a></h2>Grails에는 재사용하기 매우 좋은 명령어들이 내장돼 있다. 가장 유용한 것들은 <a href="../ref/Command Line/compile.html" class="commandLine">compile</a>, <a href="../ref/Command Line/package.html" class="commandLine">package</a>, <a href="../ref/Command Line/bootstrap.html" class="commandLine">bootstrap</a> 스크립트이다. 모든 명령어에 대한 정보는 레퍼런스 가이드를 참고하라.<p class="paragraph"/><a href="../ref/Command Line/bootstrap.html" class="commandLine">bootstrap</a> 스크립트는 스프링의 <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/context/ApplicationContext.html" class="api">ApplicationContext</a> 인스턴스를 통해서 데이터 소스등에 접근할 수 있게 해준다:<p class="paragraph"/><div class="code"><pre>Ant.property(environment:<span class="java&#45;quote">"env"</span>)                             
grailsHome = Ant.antProject.properties.<span class="java&#45;quote">"env.GRAILS_HOME"</span><p class="paragraph"/>includeTargets &#60;&#60; <span class="java&#45;keyword">new</span> File ( <span class="java&#45;quote">"$&#123;grailsHome&#125;/scripts/Bootstrap.groovy"</span> )<p class="paragraph"/>
target ('<span class="java&#45;keyword">default</span>': <span class="java&#45;quote">"Load the Grails interactive shell"</span>) &#123;
	depends( configureProxy, packageApp, classpath, loadApp, configureApp )<p class="paragraph"/>	Connection c 
	<span class="java&#45;keyword">try</span> &#123;
		// <span class="java&#45;keyword">do</span> something with connection
		c = appCtx.getBean('dataSource').getConnection()
	&#125;
	<span class="java&#45;keyword">finally</span> &#123;
		c?.close()
	&#125;
&#125;</pre></div> <h2><a name="4.3 Hooking into Events">4.3 Hooking into Events</a></h2>Grails는 스크립트 이벤트를 가로채는 방법을 제공한다. Grails의 타겟과 플러그인 스크립트가 실행되는 동안 이벤트가 발생한다.<p class="paragraph"/>이 매커니즘은 꽤 단순하고 유연하게loosely 기술된다. 가로챌 이벤트의 목록은 정해진 것이 아니다. 중요한 타겟target 스크립트에는 동일한 이벤트가 없기 때문에 플러그인 스트립트가 발생시킨 이벤트들을 가로챌 수 있다.<p class="paragraph"/><h4>Defining event handlers(이벤트 핸들러 정의하기)</h4><p class="paragraph"/>이벤트 핸들러는 플러그인의 scripts/ 폴더나 USER_HOME 디렉토리의 .grails/scripts/ 폴더에 있는 Events.groovy라는 스크립트에 정의한다. 모든 이벤트 스크립트는 이벤트가 발생할 때마다 호출된다. 그래서 이벤트를 처리하는 플러그인을 10개를 만들 수도 있고 사용자마다 다르게 할 수도 있다.<p class="paragraph"/><div class="code"><pre>eventCreatedArtefact = &#123; type, name &#45;&#62;
   println <span class="java&#45;quote">"Created $type $name"</span>
&#125;<p class="paragraph"/>eventStatusUpdate = &#123; msg &#45;&#62;
   println msg
&#125;<p class="paragraph"/>eventStatusFinal = &#123; msg &#45;&#62;
   println msg
&#125;</pre></div><p class="paragraph"/>You can see here the three handlers <code>eventCreatedArtefact</code>, <code>eventStatusUpdate</code>, <code>eventStatusFinal</code>. Grails provides some standard events, which are documented in the command line reference guide. For example the <a href="../ref/Command Line/compile.html" class="commandLine">compile</a> command fires the following events:
<ul class="star">
<li><code>CompileStart</code>  - Called when compilation starts, passing the kind of compile - source or tests</li>
<li><code>CompileEnd</code> - Called when compilation is finished, passing the kind of compile - source or tests</li>
</ul><p class="paragraph"/><h4>Triggering events</h4><p class="paragraph"/>To trigger an event simply include the Init.groovy script and call the event() closure:<p class="paragraph"/><div class="code"><pre>Ant.property(environment:<span class="java&#45;quote">"env"</span>)
grailsHome = Ant.antProject.properties.<span class="java&#45;quote">"env.GRAILS_HOME"</span>
includeTargets &#60;&#60; <span class="java&#45;keyword">new</span> File ( <span class="java&#45;quote">"$&#123;grailsHome&#125;/scripts/Init.groovy"</span> )<p class="paragraph"/>
event(<span class="java&#45;quote">"StatusFinal"</span>, &#91;<span class="java&#45;quote">"Super duper plugin action complete!"</span>&#93;)</pre></div><p class="paragraph"/><h4>Common Events</h4><p class="paragraph"/>Below is a table of some of the common events that can be leveraged:<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th>Event</th><th>Parameters</th><th>Description</th></tr><tr class="table-odd"><td>StatusUpdate</td><td>message</td><td>Passed a string indicating current script status/progress</td></tr><tr class="table-even"><td>StatusError</td><td>message</td><td>Passed a string indicating an error message from the current script</td></tr><tr class="table-odd"><td>StatusFinal</td><td>message</td><td>Passed a string indicating the final script status message, i.e. when completing a target, even if the target does not exit the scripting environment</td></tr><tr class="table-even"><td>CreatedArtefact</td><td>artefactType,artefactName</td><td>Called when a create-xxxx script has completed and created an artefact</td></tr><tr class="table-odd"><td>CreatedFile</td><td>fileName</td><td>Called whenever a project source filed is created, not including files constantly managed by Grails</td></tr><tr class="table-even"><td>Exiting</td><td>returnCode</td><td>Called when the scripting environment is about to exit cleanly</td></tr><tr class="table-odd"><td>PluginInstalled</td><td>pluginName</td><td>Called after a plugin has been installed</td></tr><tr class="table-even"><td>CompileStart</td><td>kind</td><td>Called when compilation starts, passing the kind of compile - source or tests</td></tr><tr class="table-odd"><td>CompileEnd</td><td>kind</td><td>Called when compilation is finished, passing the kind of compile - source or tests</td></tr><tr class="table-even"><td>DocStart</td><td>kind</td><td>Called when documentation generation is about to start - javadoc or groovydoc</td></tr><tr class="table-odd"><td>DocEnd</td><td>kind</td><td>Called when documentation generation has ended - javadoc or groovydoc</td></tr><tr class="table-even"><td>SetClasspath</td><td>rootLoader</td><td>Called during classpath initialization so plugins can augment the classpath with rootLoader.addURL(...). Note that this augments the classpath <strong class="bold">after</strong> event scripts are loaded so you cannot use this to load a class that your event script needs to import, although you can do this if you load the class by name.</td></tr><tr class="table-odd"><td>PackagingEnd</td><td>none</td><td>Called at the end of packaging (which is called prior to the Jetty server being started and after web.xml is generated)</td></tr><tr class="table-even"><td>ConfigureJetty</td><td>Jetty Server object</td><td>Called after initial configuration of the Jetty web server.</td></tr></table><h2><a name="4.4 Ant and Maven">4.4 Ant and Maven</a></h2><h4>Ant Integration</h4><p class="paragraph"/>create-app 명령어로 Grails 어플리케이션을 만들때 Grails는 자동으로 <a href="../ref/Command Line/create-app.html" class="commandLine">create-app</a> 의 <code>build.xml</code> 파일을 생성한다. 여기에는 다음과 같은 타겟들이 포함돼 있다.
<ul class="star">
<li>clean - Grails 어플리케이션을 청소한다.</li>
<li>war - WAR 파일을 만든다</li>
<li>test - 유닛 테스트를 실행한다.</li>
<li>deploy - 기본적으로 아무일도 하지 않지만 자동 설치deployment를 구현할 수 있다.</li>
</ul><p class="paragraph"/>이 타겟들은 Ant에 의해 실행된다:<p class="paragraph"/><div class="code"><pre>ant war</pre></div><p class="paragraph"/>build.xml은 Grails의 일반적인 명령어들을 실행하고 <a href="http://cruisecontrol.sourceforge.net/" target="blank">CruiseControl</a> 이나 <a href="https://hudson.dev.java.net/">Hudson</a> 같은 CI(continuous integration) 서버와 통합하는데 사용될 수 있다.<p class="paragraph"/><h4>Maven Integration</h4><p class="paragraph"/>Grails는 공식적으로 <a href="http://maven.apache.org/" target="blank">Maven</a> 을 지원하지 않는다. 하지만 Grails를 위한 <a href="http://forge.octo.com/confluence/display/MTG/Home" target="blank">Maven Tools for Grails</a> 라는 프로젝트가 있다. 이 도구는 이 기존의 Grails 프로젝트를 위한 POM을 만들어줄 뿐만아니라 Maven 라이프사이클lifecycle을 Grails에서 사용할 수 있게 해준다.<p class="paragraph"/>Grails를 위한 <a href="http://forge.octo.com/confluence/display/MTG/Home" target="blank">Maven Tools for Grails</a> 에 대한 자세한 정보는 프로젝트 사이트를 참고하라.
<h1><a name="5. Object Relational Mapping (GORM)">5. Object Relational Mapping (GORM)</a></h1>도메인 클래스는 모든 비지니스 어플리케이션에서 핵심이다. 도메인 클래스에는 비지니스 프로세스의 상태를 유지시키고 행동을 구현한다. 도메인 클래스는 서로 일대일 혹은 일대다 관계를 이룬다.<p class="paragraph"/>GORM은 Grails에서 사용하는 객체 관계형 매핑 구현체이다. 내부적으로 Hibernate 3(아주 인기있고 유연한 오픈소스 ORM)를 이용하지만 Groovy의 동적인 성질과 관례 때문에 Grails의 도메인 클래스를 생성하는 것까지 포함하더라도 설정할게 별로 없다. 실제로 Grails는 정적 타이핑과 동적 타이핑을 모두 지원한다.<p class="paragraph"/>Grails 도메인 클래스는 자바로도 작성할 수 있다. Hibernate와 통합하는 장을 보면 자바로 Grails의 도메인 클래스를 작성하는 법을 확인할 수 있다. 그러나 여전히 동적인 영속성 메소드를 사용한다. 다음은 GORM을 활용하는 예이다:<p class="paragraph"/><div class="code"><pre>def book = Book.findByTitle(<span class="java&#45;quote">"Groovy in Action"</span>)<p class="paragraph"/>book
  .addToAuthors(name:<span class="java&#45;quote">"Dierk Koenig"</span>)
  .addToAuthors(name:<span class="java&#45;quote">"Guillaume LaForge"</span>)
  .save()</pre></div><p class="paragraph"/><h2><a name="5.1 Quick Start Guide">5.1 Quick Start Guide</a></h2><a href="../ref/Command Line/create-domain-class.html" class="commandLine">create-domain-class</a> 명령으로 도메인 클래스를 만든다:<p class="paragraph"/><div class="code"><pre>grails create&#45;domain&#45;class Person</pre></div><p class="paragraph"/>도메인 클래스는 <code>grails-app/domain/Person.groovy</code> 에 생성되며 그 내용은 다음과 같다:<p class="paragraph"/><div class="code"><pre>class Person &#123;	
&#125;</pre></div><p class="paragraph"/><blockquote class="note">
<a href="../guide/single.html#3.3 The DataSource" class="guide">DataSource</a>에 dbCreate 프로퍼티가 “update”, “create”, “create-drop”중에 하나로 설정하면 Grails는 자동으로 데이터베이스 테이블을 생성하거나 수정한다.
</blockquote><p class="paragraph"/>다음과 같이 클래스에 몇 개의 프로퍼티를 추가한다:<p class="paragraph"/><div class="code"><pre>class Person &#123;	
	<span class="java&#45;object">String</span> name
	<span class="java&#45;object">Integer</span> age
	Date lastVisit
&#125;</pre></div><p class="paragraph"/>도메인 클래스를 만들고 <a href="../ref/Command Line/shell.html" class="commandLine">shell</a>이나 <a href="../ref/Command Line/console.html" class="commandLine">console</a>에서 관리할 수 있다:<p class="paragraph"/><div class="code"><pre>grails console</pre></div><p class="paragraph"/>이제 Groovy 명령을 입력할 수 있는 GUI 프로그램이 실행된다.<h2><a name="5.1.1 Basic CRUD">5.1.1 Basic CRUD</a></h2>기본적인 CRUD(Create/Read/Update/Delete) 명령을 사용해 보자.<p class="paragraph"/><h4>Create</h4><p class="paragraph"/>Groovy의 new 연산자를 사용하여 도메인 클래스를 생성하고 프로퍼티 값을 입력하고 <a href="../ref/Domain Classes/save.html" class="domainClasses">save</a> 메소드를를 호출한다:<p class="paragraph"/><div class="code"><pre>def p = <span class="java&#45;keyword">new</span> Person(name:<span class="java&#45;quote">"Fred"</span>, age:40, lastVisit:<span class="java&#45;keyword">new</span> Date())
p.save()</pre></div><p class="paragraph"/><a href="../ref/Domain Classes/save.html" class="domainClasses">save</a> 메소드는 Hibernate을 이용하여 도메인 클래스를 영속화한다.<p class="paragraph"/><h4>Read</h4><p class="paragraph"/>Grails는 내부적으로 도메인 클래스에 <code>id</code> 프로퍼티를 추가한다.<p class="paragraph"/><div class="code"><pre>def p = Person.get(1)
assert 1 == p.id</pre></div><p class="paragraph"/>이 예에서는 <a href="../ref/Domain Classes/get.html" class="domainClasses">get</a> 메소드를 이용하여 데이터베이스에서 Person 객체를 읽는다.<p class="paragraph"/><h4>Update</h4><p class="paragraph"/>특정 인스턴스의 정보를 업데이트하기 위해서 필요한 프로퍼티들을 변경하고 단순하게 다시 <a href="../ref/Domain Classes/save.html" class="domainClasses">save</a> 메소드를 호출하면 된다:<p class="paragraph"/><div class="code"><pre>def p = Person.get(1)
p.name = <span class="java&#45;quote">"Bob"</span>
p.save()</pre></div><p class="paragraph"/><h4>Delete</h4><p class="paragraph"/><a href="../ref/Domain Classes/delete.html" class="domainClasses">delete</a> 메소드로 인스턴스를 삭제한다:<p class="paragraph"/><div class="code"><pre>def p = Person.get(1)
p.delete()</pre></div><p class="paragraph"/><h2><a name="5.2 Domain Modelling in GORM">5.2 Domain Modelling in GORM</a></h2>
Grails 어플리케이션을 만들려면 해결할 문제의 도메인을 알아야 한다. <a href="http://www.amazon.com/" target="blank">Amazon</a> 서점을 만들고 싶다면 책, 저자, 고객, 출판사들을 고려하게 될 것이다.<p class="paragraph"/>여기에서는 제목, 출판일, ISBN등의 정보를 가지는 Book 클래스를 GORM으로 모델링 할 것이다. 계속해서 GORM으로 도메인을 모델링하는 법을 보여줄 것이다.<p class="paragraph"/><a href="../ref/Command Line/create-domain-class.html" class="commandLine">create-domain-class</a> 명령으로 도메인 클래스를 생성할 수 있다:<p class="paragraph"/><div class="code"><pre>grails create&#45;domain&#45;class Book</pre></div><p class="paragraph"/>이 명령을 실행하면 <code>grails-app/domain/Book.groovy</code> 파일이 다음과 같은 내용으로 생성된다:<p class="paragraph"/><div class="code"><pre>class Book &#123;	
&#125;</pre></div><p class="paragraph"/><blockquote class="note">
패키지를 사용하려면 도메인 클래스의 위치를 도메인 디렉토리 밑의 하위 디렉토리로 옮기고 Groovy 패키지 규칙(Java와 동일하다)에 따라 패키지를 정의하면 된다.
</blockquote><p class="paragraph"/>위 클래스는 자동적으로 클래스 이름과 동일한 데이터베이스의 book 테이블과 매핑된다. 이 규칙은 <a href="../guide/single.html#5.5.2 Custom ORM Mapping" class="guide">ORM Domain Specific Language</a> 도메인 명세 언어(ORM Domain Specific Language)로 수정할 수 있다.<p class="paragraph"/>이제 도메인 클래스를 만들었고 Java 데이터 형식을 이용하여 프로퍼티를 정의해보자. 다음의 예를 보면:<p class="paragraph"/><div class="code"><pre>class Book &#123;
	<span class="java&#45;object">String</span> title
	Date releaseDate
	<span class="java&#45;object">String</span> ISBN
&#125;</pre></div><p class="paragraph"/>각 프로퍼티는 데이터베이스의 컬럼으로 매핑되고 그 컬럼 이름은 '_'로 구분되는 소문자로 만들어진다. 예를 들어 releaseDate는 release_date의 컬럼이름으로 매핑된다. SQL 데이터 형식은 Java 데이터 형식에 따라 자동으로 매핑된다. 그리고 <a href="../guide/single.html#5.5.2 Custom ORM Mapping" class="guide">ORM DSL</a> 이나 제약조건(<a href="../guide/single.html#7.1 Declaring Constraints" class="guide">Constraints</a>)을 이용하여 매핑 규칙을 수정할 수 있다.
<h2><a name="5.2.1 Association in GORM">5.2.1 Association in GORM</a></h2>관계(Relationships)는 도메인 클래스들이 상호 동작하는 방식을 의미한다. 양쪽 클래스에 정확하게 정의하지 않으면 관계는 정의된 쪽에서만 적용된다.<h2><a name="5.2.1.1 One-to-one">5.2.1.1 One-to-one</a></h2>일대일 관계은 가장 단순형태다. 이 관계는 다른 도메인 클래스의 형식으로 프로퍼티를 정의하는 것만으로 쉽게 정의할 수 있다. 다음의 예를 보자:<p class="paragraph"/><h5>Example A</h5><p class="paragraph"/><div class="code"><pre>class Face &#123;
    Nose nose
&#125;
class Nose &#123;	
&#125;</pre></div><p class="paragraph"/>Face에서 Nose로의 단뱡향 일대일 관계를 만들었다. 이제 양뱡향 관계를 만들어보자:<p class="paragraph"/><h5>Example B</h5><p class="paragraph"/><div class="code"><pre>class Face &#123;
    Nose nose
&#125;
class Nose &#123;	
	Face face
&#125;</pre></div><p class="paragraph"/>이제 양뱡향 관계를 만들었다. 하지만 아직 두 클래스 모두 연쇄적으로 업데이트되지 않는다.<p class="paragraph"/>연쇄적으로 업데이트 되게하면 다음과 같다:<p class="paragraph"/><h5>Example C</h5><p class="paragraph"/><div class="code"><pre>class Face &#123;
    Nose nose
&#125;
class Nose &#123;	
	<span class="java&#45;keyword">static</span> belongsTo = &#91;face:Face&#93;
&#125;</pre></div><p class="paragraph"/>belongsTo를 이용하여 Nose를 Face에 종속시켰다. 이제 Face를 생성하고 저장하면 <em class="italic">연쇄적으로</em> Nose도 추가되고 변경된다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">new</span> Face(nose:<span class="java&#45;keyword">new</span> Nose()).save()</pre></div><p class="paragraph"/>The example above will save both face and nose. Note that the inverse <em class="italic">is not</em> true and will result in an error due to a transient <code>Face</code>:<p class="paragraph"/>위 예제는 Face와 Nose가 모두 잘 저장되지만 Face가 비영속 객체(transient object)므로 역순으로 생성하면 저장이 <em class="italic">안되고</em> 오류가 발생할 것이다.<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">new</span> Nose(face:<span class="java&#45;keyword">new</span> Face()).save() // will cause an error</pre></div><p class="paragraph"/>그리고 Nose는 Face에 종속되어 있기 때문에 Face를 삭제하면 Nose 역시 삭제된다.<p class="paragraph"/><div class="code"><pre>def f = Face.get(1)
f.delete() // both Face and Nose deleted</pre></div><p class="paragraph"/>belongsTo를 명시하지 않았다면 연쇄적으로 삭제되지 않는다. Nose를 명시적으로 삭제하지 않은 상태에서 Face를 삭제하면 외래키 제약조건(foreign key constraint) 에러가 발생한다:<p class="paragraph"/><div class="code"><pre>// error here without belongsTo
def f = Face.get(1)
f.delete()<p class="paragraph"/>// no error as we explicitly delete both
def f = Face.get(1)
f.nose.delete()
f.delete()</pre></div><p class="paragraph"/>다음과 같이 작성하면 이 관계를 단방향으로 만들 수도 있다. 그리고 연쇄적으로 저장, 업데이트 시킬 수 있다.<p class="paragraph"/><div class="code"><pre>class Face &#123;
    Nose nose
&#125;
class Nose &#123;	
	<span class="java&#45;keyword">static</span> belongsTo = Face
&#125;</pre></div><p class="paragraph"/>이 예제에서 belongsTo를 선언할 때 map 문법을 사용하지 않았고 관계(association)라고 부르지도 않았다는 점을 주목하자. Grails는 단방향으로 해석한다. 3가지 예제를 모두 요약하면 아래의 다이어그램과 같다.<p class="paragraph"/><img border="0" class="center" src="../img/GORM-1to1.png"></img><h2><a name="5.2.1.2 One-to-many">5.2.1.2 One-to-many</a></h2>일대다 관계는 하나의 클래스가 많은 다른 클래스의 인스턴스를 가지고 있는 것이다. <code>Author</code> 와 <code>Book</code> 의 관계가 그렇다. hasMany를 이용하여 이런 관계를 정의한다.<p class="paragraph"/><div class="code"><pre>class Author &#123;
    <span class="java&#45;keyword">static</span> hasMany = &#91; books : Book &#93;<p class="paragraph"/>    <span class="java&#45;object">String</span> name
&#125;
class Book &#123;
	<span class="java&#45;object">String</span> title
&#125;</pre></div><p class="paragraph"/>우리는 단방향 1-n 관계를 만들었다. Grails는 기본적으로 Join 테이블로 이런한 관계를 매핑한다.<p class="paragraph"/><blockquote class="note">
<a href="../guide/single.html#5.5.2 Custom ORM Mapping" class="guide">ORM DSL</a> 은 외래키 관계을 사용하여 단방향 관계를 가능하게 한다.
</blockquote><p class="paragraph"/>Grails는 자동으로 도메인 클래스의 <code>hasMany</code> 가 명시된 프로퍼티들을 <code>java.util.Set</code> 형식으로 만든다. 따라서 컬렉션(collection)의 이터레이션(iteration)을 사용할 수 있다.<p class="paragraph"/><div class="code"><pre>def a = Author.get(1)<p class="paragraph"/>a.books.each &#123;
	println it.title
&#125;</pre></div><p class="paragraph"/><blockquote class="note">
Grails에서 사용하는 기본 패치(fetch) 전략은 필요할 때(lazily) 패치하는 "lazy" 전략이다. <a href="http://www.javalobby.org/java/forums/t20533.html" target="blank">n+1 문제</a>가 발생하지 않도록 조심해야 한다.<p class="paragraph"/>"eager" 패치 전략을 취하도록 <a href="../guide/single.html#5.4 Querying with GORM" class="guide">query</a>의 일부로서 <a href="../guide/single.html#5.5.2 Custom ORM Mapping" class="guide">ORM DSL</a> 에 명시 할 수도 있다.
</blockquote><p class="paragraph"/>연쇄적으로 저장, 갱신하는 것이 기본적인 연쇄 방식이고 belongsTo가 명시되어 있지 않으면 연쇄적으로 삭제되지도 않는다.<p class="paragraph"/><div class="code"><pre>class Author &#123;
    <span class="java&#45;keyword">static</span> hasMany = &#91; books : Book &#93;<p class="paragraph"/>    <span class="java&#45;object">String</span> name
&#125;
class Book &#123;
	<span class="java&#45;keyword">static</span> belongsTo = &#91;author:Author&#93;
	<span class="java&#45;object">String</span> title
&#125;</pre></div><p class="paragraph"/>일대다 관계에서 '다'쪽의 도메인 클래스에 '일'쪽의 형식으로 정의된 프로퍼티가 두 개 이상 있다면 mappedBy를 사용하여 어떤 컬렉션에 매핑돼야 하는지 명시해야 한다.<p class="paragraph"/><div class="code"><pre>class Airport &#123;
	<span class="java&#45;keyword">static</span> hasMany = &#91;flights:Flight&#93;
	<span class="java&#45;keyword">static</span> mappedBy = &#91;flights:<span class="java&#45;quote">"departureAirport"</span>&#93;
&#125;
class Flight &#123;
	Airport departureAirport
	Airport destinationAirport
&#125;</pre></div><p class="paragraph"/>또, 컬렉션을 어러개 만들어 '다'쪽의 도메인 클래스의 다른 프로퍼티로 매핑시키는 것도 가능하다.<p class="paragraph"/><div class="code"><pre>class Airport &#123;
	<span class="java&#45;keyword">static</span> hasMany = &#91;outboundFlights:Flight, inboundFlights:Flight&#93;
	<span class="java&#45;keyword">static</span> mappedBy = &#91;outboundFlights:<span class="java&#45;quote">"departureAirport"</span>, inboundFlights:<span class="java&#45;quote">"destinationAirport"</span>&#93;
&#125;
class Flight &#123;
	Airport departureAirport
	Airport destinationAirport
&#125;</pre></div><p class="paragraph"/><h2><a name="5.2.1.3 Many-to-many">5.2.1.3 Many-to-many</a></h2>Grails는 다대다 관계를 지원한다. 양쪽 클래스에 hasMany를 정의하고 관계를 소유하는 쪽에 belongsTo를 사용하면 다대다 관계가 만들어진다.<p class="paragraph"/><div class="code"><pre>class Book &#123;
   <span class="java&#45;keyword">static</span> belongsTo = Author
   <span class="java&#45;keyword">static</span> hasMany = &#91;authors:Author&#93;
   <span class="java&#45;object">String</span> title
&#125;
class Author &#123;
   <span class="java&#45;keyword">static</span> hasMany = &#91;books:Book&#93;
   <span class="java&#45;object">String</span> name
&#125;</pre></div><p class="paragraph"/>Grails는 데이터베이스의 테이블 조인을 사용하여 다대다 관계를 구현한다. 관계를 소유하는 쪽에 관계를 영속화할 책임이 있다. 오직 한쪽에서만 연쇄적으로 저장할 수 있다. 이 경우에는 Author 클래스에 책임이 있다.<p class="paragraph"/>다음의 예는 올바르게 작동하고 연쇄적으로 저장된다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">new</span> Author(name:<span class="java&#45;quote">"Stephen King"</span>)
		.addToBooks(<span class="java&#45;keyword">new</span> Book(title:<span class="java&#45;quote">"The Stand"</span>))
		.addToBooks(<span class="java&#45;keyword">new</span> Book(title:<span class="java&#45;quote">"The Shining"</span>))		
		.save()</pre></div><p class="paragraph"/>하지만 아래의 예는 Book만 저장되고 Author들은 저장되지 않는다.<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">new</span> Book(name:<span class="java&#45;quote">"Groovy in Action"</span>)
		.addToAuthors(<span class="java&#45;keyword">new</span> Author(name:<span class="java&#45;quote">"Dierk Koenig"</span>))
		.addToAuthors(<span class="java&#45;keyword">new</span> Author(name:<span class="java&#45;quote">"Guillaume Laforge"</span>))		
		.save()</pre></div><p class="paragraph"/>다대다 관계에서는 오직 한 쪽에서만 관계를 관리할 수 있는데 이것은 Hibernate에서도 마찬가지다.<p class="paragraph"/><blockquote class="warning">
Grails의 <a href="../guide/single.html#16. Scaffolding" class="guide">Scaffolding</a> 기능은 현재 다대다 관계를 <strong class="bold">지원하지 않는다</strong>. 따라서 관계를 관리하는 코드를 직접 작성해야 한다.
</blockquote><h2><a name="5.2.2 Composition in GORM">5.2.2 Composition in GORM</a></h2><a href="../guide/single.html#5.2.1 Association in GORM" class="guide">association</a> 외에도 Grails는 결합(Composition)도 지원한다. 클래스를 각각의 테이블에 매핑하지 않고 하나의 테이블에 "포함하여" 매핑할 수 있다.<p class="paragraph"/><div class="code"><pre>class Person &#123;
	Address homeAddress
	Address workAddress
	<span class="java&#45;keyword">static</span> embedded = &#91;'homeAddress', 'workAddress'&#93;
&#125;
class Address &#123;
	<span class="java&#45;object">String</span> number
	<span class="java&#45;object">String</span> code
&#125;</pre></div><p class="paragraph"/>다음과 같이 테이블이 매핑된다.<p class="paragraph"/><img border="0" class="center" src="../img/5.2.2-composition.jpg"></img><p class="paragraph"/><blockquote class="note">
<code>grails-app/domain</code> 디렉토리에 새로운 Groovy 파일을 만들고 그 파일에 <code>Address</code> 클래스를 만들면 <code>address</code> 테이블이 생성된다. 이 것을 원하지 않으면 <code>grails-app/domain/Person.groovy</code> 파일의 <code>Person</code> 클래스 아래에 <code>Address</code> 클래스를 만든다. Groovy에서는 한 파일에 여러개의 클래스를 정의할 수 있다.
</blockquote><h2><a name="5.2.3 Inheritance in GORM">5.2.3 Inheritance in GORM</a></h2>GORM 에서는 추상 부모 클래스와 영속 GORM 엔터티에서 상속받을 수 있다. 예를 들면:<p class="paragraph"/><div class="code"><pre>class Content &#123;
     <span class="java&#45;object">String</span> author
&#125;
class BlogEntry <span class="java&#45;keyword">extends</span> Content &#123;
    URL url
&#125;
class Book <span class="java&#45;keyword">extends</span> Content &#123;
    <span class="java&#45;object">String</span> ISBN
&#125;
class PodCast <span class="java&#45;keyword">extends</span> Content &#123;
    <span class="java&#45;object">byte</span>&#91;&#93; audioStream
&#125;</pre></div><p class="paragraph"/>이 예에서 우리는 부모 클래스인 <code>Content</code> 와 다른 특징을 가진 자식 클래스들을 만들었다.<p class="paragraph"/><h4>Considerations(고려 사항)</h4><p class="paragraph"/>Grails는 기본적으로 상속 구조당 하나의 테이블(table-per-hierarchy)에 매핑한다. 부모 클래스와 그 자식 클래스들은(<code>BlogEntry</code>, <code>Book</code>, 등등) <strong class="bold">동일한</strong> 테이블을 사용하고 식별 칼럼을 두어 구분한다.<p class="paragraph"/>상속 구조당 하나의 테이블(table-per-hierarchy)에 매핑하는 것은 'not null'인 프로퍼티를 가질 수 없다는 단점이 있다. 다른 방법으로 <a href="../guide/single.html#5.5.2 Custom ORM Mapping" class="guide">ORM DSL</a>을 이용하여 클래스당 하나의 테이블(table-per-subclass)에 매핑하는 전략을 사용하는 것이다.<p class="paragraph"/>그러나 클래스당 하나의 테이블(table-per-subclass)에 매핑하는 전략을 과도하게 사용하면 조인 쿼리가 남발되기 때문에 쿼리 성능이 형편없어 진다. 우리는 상속을 남용하지말고 상속 계층를 너무 깊게 가져가지 말라고 권고한다.<p class="paragraph"/><h4>Polymorphic Queries(쿼리의 다형성)</h4><p class="paragraph"/>상속은 다형적으로(polymorphically) 질의할 수 있게 해준다. 예를 들어 <code>Content</code> 부모 클래스에서 <a href="../ref/Domain Classes/list.html" class="domainClasses">list</a> 메소드를 사용하면 모든 자식 클래스들이 반환된다:<p class="paragraph"/><div class="code"><pre>def content = Content.list() // 블로그 글, 책, 팟 캐스트 모두 나열된다.
content = Content.findAllByAuthor('Joe Bloggs') // 저자를 기준으로 찾는다.<p class="paragraph"/>def podCasts = PodCast.list() //팟 캐스트만 나열된다.</pre></div><h2><a name="5.2.4 Sets, Lists and Maps">5.2.4 Sets, Lists and Maps</a></h2><h4>Sets of objects(집합)</h4><p class="paragraph"/>관계를 만들면 GORM은 기본적으로 <code>java.util.Set</code>을 이용한다. 이 것은 정렬되지 않으며 중복을 허용하지 않는 컬렉션이다. 다음의 Author 클래스가 있다면<p class="paragraph"/><div class="code"><pre>class Author &#123;
   <span class="java&#45;keyword">static</span> hasMany = &#91;books:Book&#93;
&#125;</pre></div><p class="paragraph"/>GORM은 이 books 프로퍼티를 <code>java.util.Set</code>형식으로 만든다. 컬렉션을 사용할 때 정렬되지 않았다는 것이 문제가 될 수 있다. 정렬된 컬렉션을 사용하길 원한다면 다음처럼 books를 <code>SortedSet</code>으로 명시한다.<p class="paragraph"/><div class="code"><pre>class Author &#123;
   SortedSet books
   <span class="java&#45;keyword">static</span> hasMany = &#91;books:Book&#93;
&#125;</pre></div><p class="paragraph"/><code>java.util.SortedSet</code>을 사용하는 경우에는 Book 클래스에 <code>java.lang.Comparable</code>을 구현해야 한다.<p class="paragraph"/><div class="code"><pre>class Book <span class="java&#45;keyword">implements</span> Comparable &#123;
   <span class="java&#45;object">String</span> title
   Date releaseDate = <span class="java&#45;keyword">new</span> Date()<p class="paragraph"/>   <span class="java&#45;object">int</span> compareTo(obj) &#123;
       releaseDate.compareTo(obj.releaseDate)
   &#125;
&#125;</pre></div><p class="paragraph"/>이 예제대로 라면 Author 클래스의 books 프로퍼티에 Book 객체들이 있게된다. Book 객체들은 releaseDate를 기준으로 정렬될 것이다.<p class="paragraph"/><h4>Lists of objects(리스트)</h4><p class="paragraph"/>단순하게 집합을 객체가 추가된 순서로 유지하고 배열처럼 인덱스로 객체를 참조하게 하고 싶을 땐 <code>List</code>를 사용하면 된다:<p class="paragraph"/><div class="code"><pre>class Author &#123;
   List books
   <span class="java&#45;keyword">static</span> hasMany = &#91;books:Book&#93;
&#125;</pre></div><p class="paragraph"/>books 컬렉션의 순서는 객체를 추가한 순서대로 유지된다. 0부터 시작하는 인덱스를 이용하여 다음과 같이 사용할 수 있다:<p class="paragraph"/><div class="code"><pre>author.books&#91;0&#93; // 첫 번째 책</pre></div><p class="paragraph"/>데이터베이스 수준에서 일어나는 일을 살펴보면 Hibernate는 books_idx 컬럼을 생성한다. 데이터베이스에서도 순서를 지키기위해서 <code>book_idx</code>에 컬렉션 요소(element)의 인덱스를 저장한다.<p class="paragraph"/><code>List</code>를 사용할 때 요소를 저장하기 전에 컬렉션에 추가해야 한다. 그렇지 않으면 Hibernate는 예외를 던질 것이다(<code>org.hibernate.HibernateException: null index column for collection</code>):<p class="paragraph"/><div class="code"><pre>// This won't work!
def book = <span class="java&#45;keyword">new</span> Book(title: 'The Shining')
book.save()
author.addToBooks(book)<p class="paragraph"/>// Do it <span class="java&#45;keyword">this</span> way instead.
def book = <span class="java&#45;keyword">new</span> Book(title: 'Misery')
author.addToBooks(book)
author.save()</pre></div><p class="paragraph"/><h4>Maps of Objects(맵)</h4><p class="paragraph"/>만약 string/value 쌍만으로 이루어진 단순한 맵을 원하면 다음처럼 사용하면 된다:<p class="paragraph"/><div class="code"><pre>class Author &#123;
   Map books // map of ISBN:book names
&#125;<p class="paragraph"/>def a = <span class="java&#45;keyword">new</span> Author()
a.books = &#91;<span class="java&#45;quote">"1590597583"</span>:<span class="java&#45;quote">"Grails Book"</span>&#93;
a.save()</pre></div><p class="paragraph"/>맵의 키와 값은 모두 <strong class="bold">반드시</strong> 문자열이어야 한다.<p class="paragraph"/>객체의 맵을 원한다면 다음처럼 한다.<p class="paragraph"/><div class="code"><pre>class Book &#123;
  Map authors
  <span class="java&#45;keyword">static</span> hasMany = &#91;authors:Author&#93;
&#125;<p class="paragraph"/>def a = <span class="java&#45;keyword">new</span> Author(name:<span class="java&#45;quote">"Stephen King"</span>)<p class="paragraph"/>def book = <span class="java&#45;keyword">new</span> Book()
book.authors = &#91;stephen:a&#93;
book.save()</pre></div><p class="paragraph"/>static <code>hasMany</code> 프로퍼티로 맵의 요소의 형식을 정의할 수 있다. 이 맵의 키는 <strong class="bold">반드시</strong> 문자열이어야 한다.
<h2><a name="5.3 Persistence Basics">5.3 Persistence Basics</a></h2>Grails에서 잊지 말아야 할 것이 있는데 Grails는 내부적으로 <a href="http://www.hibernate.org/" target="blank">Hibernate</a> 을 사용하여 영속성을 구현했다. <a href="http://wiki.rubyonrails.org/rails/pages/ActiveRecord" target="blank">ActiveRecord</a> 나 <a href="http://ibatis.apache.org/" target="blank">iBatis</a> 를 사용한적이 있다면 Hibernate의 "세션 모델"이 조금 어색할 수 있다.<p class="paragraph"/>Grails는 자동으로 현재 실행하는 요청을 Hibernate 세션에 바인드(bind)시킨다. 이 것은 우리가 <a href="../ref/Domain Classes/save.html" class="domainClasses">save</a>, <a href="../ref/Domain Classes/delete.html" class="domainClasses">delete</a> 등의 GORM 메소드를 투명하게 사용할 수 있게 해준다.
<h2><a name="5.3.1 Saving and Updating">5.3.1 Saving and Updating</a></h2>다음은 <a href="../ref/Domain Classes/save.html" class="domainClasses">save</a> 메소드를 사용하는 예이다.<p class="paragraph"/><div class="code"><pre>def p = Person.get(1)
p.save()</pre></div><p class="paragraph"/>Hibernate와 가장 큰 차이점은 <a href="../ref/Domain Classes/save.html" class="domainClasses">save</a> 메소드를 호출할 때 어떠한 SQL도 실행할 필요가 없다는 것이다. 보통 Hibernate는 SQL 문을 모았다가 끝날때 일괄 처리한다. Grails는 Hibernate Session을 관리해서 자동으로 이 일을 해낸다.<p class="paragraph"/>그러나 SQL 문이 언제 실행돼야 하는지를 결정하고 싶을 때도 있다. Hibernate에서는 이 것을 세션을 "flush" 했다라고 한다. 이렇게 하기 위해서 다음처럼 save 메소드를 호출할 때 flush를 인자로 넘길 수 있다.<p class="paragraph"/><div class="code"><pre>def p = Person.get(1)
p.save(flush:<span class="java&#45;keyword">true</span>)</pre></div><p class="paragraph"/>이전의 save를 포함하여 지연된 모든 SQL 문장들이 DB와 동기화될 것이다. 이 때 예외를 처리할 수 있다. 이 예외처리는 일반적으로 낙관적 잠금(<a href="../guide/single.html#5.3.5 Pessimistic and Optimistic Locking" class="guide">optimistic locking</a>)을 포함하는 고도의 동시적concurrent 시나리오에 유용하다.<p class="paragraph"/><div class="code"><pre>def p = Person.get(1)
<span class="java&#45;keyword">try</span> &#123;
	p.save(flush:<span class="java&#45;keyword">true</span>)
&#125;
<span class="java&#45;keyword">catch</span>(Exception e) &#123;
	// deal with exception
&#125;</pre></div><h2><a name="5.3.2 Deleting Objects">5.3.2 Deleting Objects</a></h2>다음은 <a href="../ref/Domain Classes/delete.html" class="domainClasses">delete</a> 메소드를 사용하는 예이다.<p class="paragraph"/><div class="code"><pre>def p = Person.get(1)
p.delete()</pre></div><p class="paragraph"/><a href="../ref/Domain Classes/delete.html" class="domainClasses">delete</a> 메소드에도 flush 인자를 이용하여 flush시킬 수 있다.<p class="paragraph"/><div class="code"><pre>def p = Person.get(1)
p.delete(flush:<span class="java&#45;keyword">true</span>)</pre></div><p class="paragraph"/>데이터를 삭제하는 것은 조심해야 하기 때문에 Grails도 <code>deleteAll</code> 메소드를 제공하지 않는다. 이진 flags/logic을 이용해서 데이터를 삭제할 수 있다.<p class="paragraph"/>정말 일괄 삭제해야 한다면 <a href="../ref/Domain Classes/executeUpdate.html" class="domainClasses">executeUpdate</a> 메소드를 이용하여 DML 문을 실행시켜서 삭제할 수 있다.<p class="paragraph"/><div class="code"><pre>Customer.executeUpdate(<span class="java&#45;quote">"delete Customer c where c.name = :oldName"</span>, &#91;oldName:<span class="java&#45;quote">"Fred"</span>&#93;)</pre></div><p class="paragraph"/><h2><a name="5.3.3 Understanding Cascading Updates and Deletes">5.3.3 Understanding Cascading Updates and Deletes</a></h2>GORM을 사용할 때 연쇄(Cascade) 갱신과 삭제가 어떻게 동작하는 지를 이해하는 것은 중요하다. 클래스가 관계를 "소유"하는 것을 제어하는 <code>belongsTo</code> 설정이 우리가 기억해야 할 핵심이다.<p class="paragraph"/>일대일, 일대다, 다대다 관계에 상관없이 <code>belongsTo</code>를 정의했다면 갱신과 삭제는 소유한 클래스에서 그 소유물(관계의 다른 쪽)까지 연쇄적으로 동작할 것이다.<p class="paragraph"/>_belongsTo를 정의하지 않으면_ 연쇄 작업은 일어나지 않으며 모든 객체를 일일이 손수 저장해야 한다.<p class="paragraph"/>여기에 한 예가 있다.<p class="paragraph"/><div class="code"><pre>class Airport &#123;
	<span class="java&#45;object">String</span> name
	<span class="java&#45;keyword">static</span> hasMany = &#91;flights:Flight&#93;
&#125;
class Flight &#123;
	<span class="java&#45;object">String</span> number
	<span class="java&#45;keyword">static</span> belongsTo = &#91;airport:Airport&#93;
&#125;</pre></div><p class="paragraph"/><code>Airport</code>를 생성하고 <code>Flight</code>를 몇 개 추가한 후 <code>Airport</code>를 저장하면 <code>Flight</code>도 연쇄적으로 저장된다. 결국 생성한 모든 객체가 저장된다.<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">new</span> Airport(name:<span class="java&#45;quote">"Gatwick"</span>)
	 .addToFlights(<span class="java&#45;keyword">new</span> Flight(number:<span class="java&#45;quote">"BA3430"</span>))
	 .addToFlights(<span class="java&#45;keyword">new</span> Flight(number:<span class="java&#45;quote">"EZ0938"</span>))
	 .save()</pre></div><p class="paragraph"/>반대로 <code>Airport</code>를 삭제하면 관련된 모든 <code>Flight</code>도 삭제될 것이다.<p class="paragraph"/><div class="code"><pre>def airport = Airport.findByName(<span class="java&#45;quote">"Gatwick"</span>)
airport.delete()</pre></div><p class="paragraph"/>그러나 <code>belongsTo</code>를 제거하면 위의 코드는 더 이상 연쇄적으로 삭제하지 않는다. <a href="../guide/single.html#5.5.2 Custom ORM Mapping" class="guide">ORM DSL</a>을 사용하여 연쇄 행동을 제어할 수 있다.
<h2><a name="5.3.4 Eager and Lazy Fetching">5.3.4 Eager and Lazy Fetching</a></h2>GORM은 기본적으로 Lazy 패칭을 사용한다. 다음 예가 이를 잘 설명한다.<p class="paragraph"/><div class="code"><pre>class Airport &#123;
	<span class="java&#45;object">String</span> name
	<span class="java&#45;keyword">static</span> hasMany = &#91;flights:Flight&#93;
&#125;
class Flight &#123;
	<span class="java&#45;object">String</span> number
	<span class="java&#45;keyword">static</span> belongsTo = &#91;airport:Airport&#93;
&#125;</pre></div><p class="paragraph"/>위의 도메인 클래스로 다음과 같이 코드를 작성한다.<p class="paragraph"/><div class="code"><pre>def airport = Airport.findByName(<span class="java&#45;quote">"Gatwick"</span>)
airport.flights.each &#123;
	println it.name
&#125;</pre></div><p class="paragraph"/>GORM은 <code>Airport</code> 인스턴스를 가져오기 위해 단 하나의 SQL을 실행하고 <code>Flight</code>마다 추가로 1개의 쿼리를 더 실행할 것이다. 결국에 N+1번 질의한다.<p class="paragraph"/>관계(association)에 드물게 접근하는 경우에는 이 방법이 최적일 것이다. 전적으로 관계(association)의 사용빈도에 달려있다.<p class="paragraph"/>다음과 같이 Eager 패칭을 사용하는 것으로 Lazy 패칭의 단점을 해결할 수 있다.<p class="paragraph"/><div class="code"><pre>class Airport &#123;
	<span class="java&#45;object">String</span> name
	<span class="java&#45;keyword">static</span> hasMany = &#91;flights:Flight&#93;
	<span class="java&#45;keyword">static</span> fetchMode = &#91;flights:<span class="java&#45;quote">"eager"</span>&#93;
&#125;</pre></div><p class="paragraph"/><code>Airport</code> 인스턴스와 <code>Flight</code> 관계는 매핑 규칙에 따라 한번에 전부 로드될 것이다. 데이터베이스에 질의하는 빈도가 줄어드는 장점이 있지만 Eager Association이 너무 많으면 데이터베이스 전체를 메모리로 로드하게 될 수도 있으니 주의해야 한다.<p class="paragraph"/><blockquote class="note">
<a href="../guide/single.html#5.5.2 Custom ORM Mapping" class="guide">ORM DSL</a>을 이용하여 Lazy 패치없이 관계를 정의할 수 있다.
</blockquote><p class="paragraph"/>
<h2><a name="5.3.5 Pessimistic and Optimistic Locking">5.3.5 Pessimistic and Optimistic Locking</a></h2><h4>Optimistic Locking(낙관적 잠금)</h4><p class="paragraph"/>기본적으로 GORM 클래스는 낙관적 잠금을 사용하도록 돼 있다. 낙관적 잠금은 Hibernate의 것을 이용하므로 데이터베이스의 <code>version</code> 컬럼에 버전을 저장한다.<p class="paragraph"/><code>version</code> 프로퍼티를 통해서 이 버전 컬럼을 읽을 수 있다. 사용하고 있는 영속성 인스턴스의 버전을 읽는다.<p class="paragraph"/><div class="code"><pre>def airport = Airport.get(10)<p class="paragraph"/>println airport.version</pre></div><p class="paragraph"/>도메인 클래스에 대해서 업데이트를 실행하면 Hiberate는 자동으로 version 프로퍼티과 데이터베이스의 version 컬럼을 검사한다. 만약 서로 다르면 <a href="http://www.hibernate.org/hib_docs/v3/api/org/hibernate/StaleObjectStateException.html" class="api">StaleObjectException</a>을 던지고 트랜잭션을 롤백한다.<p class="paragraph"/>이 것은 성능 문제를 야기하는 비관적 잠금을 사용하지도 않고서도 원자성을 확실하게 보장하기 때문에 유용하다. 단, 동시 쓰기가 많이 발생한다면 이 예외를 직접 처리해야 한다.<p class="paragraph"/><div class="code"><pre>def airport = Airport.get(10)<p class="paragraph"/><span class="java&#45;keyword">try</span> &#123;
	airport.name = <span class="java&#45;quote">"Heathrow"</span>
	airport.save(flush:<span class="java&#45;keyword">true</span>)
&#125;
<span class="java&#45;keyword">catch</span>(org.springframework.dao.OptimisticLockingFailureException e) &#123;
	// deal with exception
&#125;</pre></div><p class="paragraph"/>어플리케이션에 따라 예외를 처리하는 방법이 달라질 수 있다. 전적으로 사용자에게 떠넘길 수도 있고 프로그램으로 데이터를 자동으로 병합해줄 수도 있고 충돌을 해결하도록 사용자에게 요청할 수 있다.<p class="paragraph"/>이 방법이 싫다면 비관적 잠금을 사용하면 된다.<p class="paragraph"/><h4>Pessimistic Locking(비관적 잠금)</h4><p class="paragraph"/>비관적 잠금은 "SELECT * FOR UPDATE" 라는 SQL 문을 실행하는 것과 동일하게 데이터베이스의 특정 열을 잠근다. 잠긴 것이 해제될 때까지 다른 읽기가 블럭된다.<p class="paragraph"/><a href="../ref/Domain Classes/lock.html" class="domainClasses">lock</a> 메소드를 이용하여 비관적 잠금을 사용할 수 있다.<p class="paragraph"/><div class="code"><pre>def airport = Airport.get(10)
airport.lock() // lock <span class="java&#45;keyword">for</span> update
airport.name = <span class="java&#45;quote">"Heathrow"</span>
airport.save()</pre></div><p class="paragraph"/>트랜잭션이 커밋되면 Grails는 잠금을 자동으로 해제한다.<h2><a name="5.4 Querying with GORM">5.4 Querying with GORM</a></h2>GORM은 동적 파인더(dynamic finder)라는 강력한 질의 방법을 제공한다. 이 것은 Hibernate의 객체지향 쿼리 언어인 HQL에 버금같다.<p class="paragraph"/><a href="http://groovy.codehaus.org/GPath" target="blank">GPath</a> 와 sort, findAll 같은 메소드들로 컬렉션을 관리할 수 있는 Groovy와 GORM의 결합은 강력한 조합을 만들어 낸다.<p class="paragraph"/>그러나. 언제나 천리길도 한 걸음부터.<p class="paragraph"/><h4>Listing instances(리스트)</h4><p class="paragraph"/>단순하게 <a href="../ref/Domain Classes/list.html" class="domainClasses">list</a> 메소드를 사용하여 클래스의 모든 인스턴스를 조회할 수 있다:<p class="paragraph"/><div class="code"><pre>def books = Book.list()</pre></div><p class="paragraph"/>페이지정보(pagination)를 <a href="../ref/Domain Classes/list.html" class="domainClasses">list</a> 메소드의 인자로 넘길 수 있다:<p class="paragraph"/><div class="code"><pre>def books = Book.list(offset:10, max:20)</pre></div><p class="paragraph"/>정렬도 가능하다.<p class="paragraph"/><div class="code"><pre>def books = Book.list(sort:<span class="java&#45;quote">"title"</span>, order:<span class="java&#45;quote">"asc"</span>)</pre></div><p class="paragraph"/>sort 인자로 정열할 때 기준이되는 도메인 클래스의 프로퍼티를 명시하고 order 인자에는 오름 정렬일 때 <strong class="bold">asc</strong>를, 내림 정렬일 때에는 <strong class="bold">desc</strong>를 사용한다<p class="paragraph"/><h4>Retrieval by Database Identifier(데이터베이스 식별자로 조회)</h4><p class="paragraph"/><a href="../ref/Domain Classes/get.html" class="domainClasses">get</a> 메소드에 데이터베이스 식별자를 인자로 넘겨서 조회할 수 있다.<p class="paragraph"/><div class="code"><pre>def book = Book.get(23)</pre></div><p class="paragraph"/>식별자들의 집합을 <a href="../ref/Domain Classes/getAll.html" class="domainClasses">getAll</a> 메소드의 인자로 넘겨서 인스턴스의 목록을 조회할 수 있다.<p class="paragraph"/><div class="code"><pre>def books = Book.getAll(23, 93, 81)</pre></div>
<h2><a name="5.4.1 Dynamic Finders">5.4.1 Dynamic Finders</a></h2>GORM은 <strong class="bold">동적 파인더</strong> 개념을 지원한다. 동적 파인더는 정적 메소드를 실행하는 것과 비슷하다. 그렇지만 동적 파인더를 지원하기 위해 특별한 메소드가 존재하는 것은 아니다.<p class="paragraph"/>메소드를 사용하는 것이 아니다. 클래스의 프로퍼티를 기반으로 런타임에 코드를 합성하여 마술처럼 자동으로 생성한다. 다음 Book 클래스의 예를 보자.<p class="paragraph"/><div class="code"><pre>class Book &#123;
	<span class="java&#45;object">String</span> title
	Date releaseDate
	Author author
&#125;                
class Author &#123;
	<span class="java&#45;object">String</span> name
&#125;</pre></div><p class="paragraph"/><code>Book</code> 클래스는 title, releaseDate, author같은 프로퍼티를 가지고 있다. 이 프로퍼티들은 '메소드 표현식(method expressions)'에 따라 <a href="../ref/Domain Classes/findBy.html" class="domainClasses">findBy</a> <a href="../ref/Domain Classes/findAllBy.html" class="domainClasses">findAllBy</a> 메소드에서 사용된다.<p class="paragraph"/><div class="code"><pre>def book = Book.findByTitle(<span class="java&#45;quote">"The Stand"</span>)<p class="paragraph"/>book = Book.findByTitleLike(<span class="java&#45;quote">"Harry Pot%"</span>)<p class="paragraph"/>book = Book.findByReleaseDateBetween( firstDate, secondDate )<p class="paragraph"/>book = Book.findByReleaseDateGreaterThan( someDate )<p class="paragraph"/>book = Book.findByTitleLikeOrReleaseDateLessThan( <span class="java&#45;quote">"%Something%"</span>, someDate )</pre></div><p class="paragraph"/><h4>Method Expressions(메소드 표현식)</h4><p class="paragraph"/>GORM의 메소드 표현식은 <a href="../ref/Domain Classes/findBy.html" class="domainClasses">findBy</a> 같은 접두어 뒤에 프로퍼티들을 연결시켜서 완성된다. 기본식은 다음과 같다.<p class="paragraph"/><div class="code"><pre>Book.findBy&#91;Property&#93;&#91;Suffix&#93;&#42;&#91;<span class="java&#45;object">Boolean</span> Operator&#93;&#42;&#91;Property&#93;&#91;Suffix&#93;</pre></div><p class="paragraph"/>*는 생략가능하고 각각의 접미어에 따라 쿼리가 달라진다. 예를 들면:<p class="paragraph"/><div class="code"><pre>def book = Book.findByTitle(<span class="java&#45;quote">"The Stand"</span>)<p class="paragraph"/>book =  Book.findByTitleLike(<span class="java&#45;quote">"Harry Pot%"</span>)</pre></div><p class="paragraph"/>
이 예에서 전자는 등호 연산과 동일하고 후자는 접미어 <code>Like</code>로 인해 <code>like</code> 연산으로 동작한다.<p class="paragraph"/>가능한 접미어들:
<ul class="star">
<li><code>LessThan</code> - less than the given value</li>
<li><code>LessThanEquals</code> - less than or equal a give value</li>
<li><code>GreaterThan</code> - greater than a given value</li>
<li><code>GreaterThanEquals</code> - greater than or equal a given value</li>
<li><code>Like</code> - Equivalent to a SQL like expression</li>
<li><code>Ilike</code> - Similar to a <code>Like</code>, except case insensitive</li>
<li><code>NotEqual</code> - Negates equality</li>
<li><code>Between</code> - Between two values (requires two arguments)</li>
<li><code>IsNotNull</code> - Not a null value (doesn't require an argument)</li>
<li><code>IsNull</code> - Is a null value (doesn't require an argument)</li>
</ul><p class="paragraph"/>You'll notice the last 3 effect the number of arguments required to the method as demonstrated by the example:<p class="paragraph"/><div class="code"><pre>def now = <span class="java&#45;keyword">new</span> Date()
def lastWeek = now &#45; 7
def book = Book.findByReleaseDateBetween( lastWeek, now )</pre></div><p class="paragraph"/>Equally <code>isNull</code> and <code>isNotNull</code> require no arguments:<p class="paragraph"/><div class="code"><pre>def books = Book.findAllByReleaseDateIsNull()</pre></div><p class="paragraph"/><h4>Boolean logic (AND/OR) </h4><p class="paragraph"/>Method expressions can also use a boolean operator to combine two criteria:<p class="paragraph"/><div class="code"><pre>def books = 
    Book.findAllByTitleLikeAndReleaseDateGreaterThan(<span class="java&#45;quote">"%Java%"</span>, <span class="java&#45;keyword">new</span> Date()&#45;30)</pre></div><p class="paragraph"/>In this case we're using <code>And</code> in the middle of the query to make sure both conditions are satisfied, but you could equally use <code>Or</code>:<p class="paragraph"/><div class="code"><pre>def books = 
    Book.findAllByTitleLikeOrReleaseDateGreaterThan(<span class="java&#45;quote">"%Java%"</span>, <span class="java&#45;keyword">new</span> Date()&#45;30)</pre></div><p class="paragraph"/>Clearly, method names can end up being quite long, in which case you should consider using <a href="../guide/single.html#5.4.2 Criteria" class="guide">Criteria</a>.<p class="paragraph"/><h4>Querying Associations</h4><p class="paragraph"/>Associations can also be used within queries:<p class="paragraph"/><div class="code"><pre>def author = Author.findByName(<span class="java&#45;quote">"Stephen King"</span>)<p class="paragraph"/>def books = author ? Book.findAllByAuthor(author) : &#91;&#93;</pre></div><p class="paragraph"/>In this case if the <code>Author</code> instance is not null we use it in a query to obtain all the <code>Book</code> instances for the given <code>Author</code>.<p class="paragraph"/><h4>Pagination &#38; Sorting</h4><p class="paragraph"/>The same pagination and sorting parameters available on the <a href="../ref/Domain Classes/list.html" class="domainClasses">list</a> method can also be used with dynamic finders by supplying a map as the final parameter:<p class="paragraph"/><div class="code"><pre>def books = 
  Book.findAllByTitleLike(<span class="java&#45;quote">"Harry Pot%"</span>, &#91;max:3, 
                                         offset:2, 
                                         sort:<span class="java&#45;quote">"title"</span>,
                                         order:<span class="java&#45;quote">"desc"</span>&#93;)</pre></div>
<h2><a name="5.4.2 Criteria">5.4.2 Criteria</a></h2>Criteria는 복잡한 쿼리를 만들기 위해 Groovy 빌더를 사용한다. Criteria는 자료형이 보장(type safe)되는 매우 훌륭한 도구다. 이 것이 StringBuffer보다 훨씬 훌륭하다.<p class="paragraph"/><a href="../ref/Domain Classes/createCriteria.html" class="domainClasses">createCriteria</a>나 <a href="../ref/Domain Classes/withCriteria.html" class="domainClasses">withCriteria</a> 메소드를 통해서 Criteria를 사용한다. 이 빌더는 Hibernate의 Criteria API를 사용한다. 빌더의 노드들은 Hibernate의 Criteria API의 <a href="http://www.hibernate.org/hib_docs/v3/api/org/hibernate/criterion/Restrictions.html" class="api">Restrictions</a> 클래스에 있는 static method들에 매핑된다. 다음의 예를 보자:<p class="paragraph"/><div class="code"><pre>def c = Account.createCriteria()
def results = c &#123;
	like(<span class="java&#45;quote">"holderFirstName"</span>, <span class="java&#45;quote">"Fred%"</span>)
	and &#123;
		between(<span class="java&#45;quote">"balance"</span>, 500, 1000)
		eq(<span class="java&#45;quote">"branch"</span>, <span class="java&#45;quote">"London"</span>)
	&#125;
	maxResults(10)
	order(<span class="java&#45;quote">"holderLastName"</span>, <span class="java&#45;quote">"desc"</span>)
&#125;</pre></div><p class="paragraph"/><h4>Conjunctions and Disjunctions(논리곱과 논리합)</h4><p class="paragraph"/>위의 예에서 보여주듯이 <code>and { }</code>을 이용하여 논리블럭을 만들고 Criteria에 논리연산을 적용할 수 있다:<p class="paragraph"/><div class="code"><pre>and &#123;
	between(<span class="java&#45;quote">"balance"</span>, 500, 1000)
	eq(<span class="java&#45;quote">"branch"</span>, <span class="java&#45;quote">"London"</span>)
&#125;</pre></div><p class="paragraph"/>OR 연산자도 마찬가지다:<p class="paragraph"/><div class="code"><pre>or &#123;
	between(<span class="java&#45;quote">"balance"</span>, 500, 1000)
	eq(<span class="java&#45;quote">"branch"</span>, <span class="java&#45;quote">"London"</span>)
&#125;</pre></div><p class="paragraph"/>NOT 연산자에서도 잘 동작한다:<p class="paragraph"/><div class="code"><pre>not &#123;
	between(<span class="java&#45;quote">"balance"</span>, 500, 1000)
	eq(<span class="java&#45;quote">"branch"</span>, <span class="java&#45;quote">"London"</span>)
&#125;</pre></div><p class="paragraph"/><h4>Querying Associations(관계 질의하기)</h4><p class="paragraph"/>프로퍼티에 알 맞는 노드가 있으면 관계를 질의할 수 있다. 다음 예제는 <code>Account</code> 클래스는 많은 <code>Transaction</code> 객체를 가질 수 있다는 것을 말해준다.<p class="paragraph"/><div class="code"><pre>class Account &#123;
    &#8230;
    def hasMany = &#91;transactions:Transaction&#93;
    Set transactions
    &#8230;
&#125;</pre></div><p class="paragraph"/>우리는 빌더 노드에 <code>transaction</code> 프로퍼티을 사용하여 이 관계를 질의할 수 있다.<p class="paragraph"/><div class="code"><pre>def c = Account.createCriteria()
def now = <span class="java&#45;keyword">new</span> Date()
def results = c.list &#123;
       transactions &#123;
            between('date',now&#45;10, now)
       &#125;
&#125;</pre></div><p class="paragraph"/>이 예제는 최근 10일안에 <code>transaction</code>이 있었던 <code>Account</code> 인스턴스를 모두 찾는다.
그리고 그러한 관계를 질의하는 쿼리를 논리 블럭안에 넣을 수 있다.:<p class="paragraph"/><div class="code"><pre>def c = Account.createCriteria()
def now = <span class="java&#45;keyword">new</span> Date()
def results = c.list &#123;
     or &#123;
        between('created',now&#45;10,now)
        transactions &#123;
             between('date',now&#45;10, now)
        &#125;
     &#125;
&#125;</pre></div><p class="paragraph"/>이 예제는 최근 10일 이내에 transaction이 수행됐었거나 생성된 Account 인스턴스들은 모두 찾는다.<p class="paragraph"/><h4>Querying with Projections(프로젝션으로 질의하기)</h4><p class="paragraph"/>프로젝션은 결과를 사용자 사정에 맞추는데(customize) 사용된다. 프로젝션을 사용하기 위해서는 Criteria 빌더 트리에 "projections" 노드를 정의해야 한다. projections 노드의 메소드은 Hibernate의 <a href="http://www.hibernate.org/hib_docs/v3/api/org/hibernate/criterion/Projections.html" class="api">Projections</a> 클래스의 메소드와 동일하다:<p class="paragraph"/><div class="code"><pre>def c = Account.createCriteria()<p class="paragraph"/>def numberOfBranches = c.get &#123;
	projections &#123;
		countDistinct('branch')
	&#125;
&#125;</pre></div><p class="paragraph"/><h4>Using Scrollable Results(스크롤되는 결과의 사용)</h4><p class="paragraph"/>scroll 메소드를 호출하여 Hiberate의 <a href="http://www.hibernate.org/hib_docs/v3/api/org/hibernate/ScrollableResults.html" class="api">ScrollableResults</a> 기능을 사용할 수 있다.<p class="paragraph"/><div class="code"><pre>def results = crit.scroll &#123;
      maxResults(10)
&#125;
def f = results.first()
def l = results.last()
def n = results.next()
def p = results.previous()<p class="paragraph"/>def <span class="java&#45;keyword">future</span> = results.scroll(10)
def accountNumber = results.getLong('number')</pre></div><p class="paragraph"/>Hiberate에서 ScrollableResult를 설명하는 문서를 인용했다:<p class="paragraph"/><blockquote class="quote">
원하는 개수만큼 결과를 스크롤할 수 있는 result iterator이다. Query/ScrollableResults 패턴은 JDBC PreparedStatement/ResultSet 패턴과 매우 유사하고 메소드의 이름도 ResultSet의 것과 비슷하게 지어졌다.
</blockquote><p class="paragraph"/>하지만 JDBC와는 다르게 결과의 컬럼의 인덱스는 0부터 시작한다.<p class="paragraph"/><h4>Setting properties in the Criteria instance(Criteria 인스턴스의 프로퍼티를 설정하기)</h4><p class="paragraph"/>빌더 트리에서 기술한 조건이 해석할 수 없으면 Criteria 인스턴스의 자체 프로퍼티를 설정하려고 시도한다. 그래서 이 클래스의 모든 프로퍼티에 접근하는 것이 가능하다. 아래의 예를 보면 <a href="http://www.hibernate.org/hib_docs/v3/api/org/hibernate/Criteria.html" class="api">Criteria</a> 인스턴스의 <code>setMaxResults</code>와 <code>setFirstResult</code> 메소드가 호출된다.<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> org.hibernate.FetchMode as FM
	&#8230;
	def results = c.list &#123;
		maxResults(10)
		firstResult(50)
		fetchMode(<span class="java&#45;quote">"aRelationship"</span>, FM.EAGER)
	&#125;</pre></div><p class="paragraph"/><h4>Querying with Eager Fetching(Eager 패칭으로 질의하기)</h4><p class="paragraph"/><a href="../guide/single.html#5.3.4 Eager and Lazy Fetching" class="guide">Eager and Lazy Fetching</a> 을 설명하면서 우리는 N+1 select 문제를 회피하는 방법에 대해 이미 다루었다. 하지만 Criteria를 이용하여 동일한 일을 할 수 있다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> org.hibernate.FetchMode as FM
...<p class="paragraph"/>def criteria = Task.createCriteria()
def tasks = criteria.list&#123;
     eq(<span class="java&#45;quote">"assignee.id"</span>, task.assignee.id)
     fetchMode('assignee', FM.EAGER)
     fetchMode('project', FM.EAGER)
     order('priority', 'asc')
&#125;</pre></div><p class="paragraph"/>
<h4>Method Reference(메소드 레퍼런스)</h4><p class="paragraph"/>만약 다음의 예제처럼 아무것도 없이 빌더를 실행하면:<p class="paragraph"/><div class="code"><pre>c &#123; &#8230; &#125;</pre></div><p class="paragraph"/>결과의 목록을 얻어오는 것이 빌더의 목적이므로 다음의 예제와 동일하게 작동된다:<p class="paragraph"/><div class="code"><pre>c.list &#123; &#8230; &#125;</pre></div><p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th>메소드</th><th>설명</th></tr><tr class="table-odd"></tr><tr class="table-even"><td><strong class="bold">list</strong></td><td>기본 메소드로 조건에 만족하는 모든 열을 반환한다.</td></tr><tr class="table-odd"><td><strong class="bold">get</strong></td><td>단 한 개의 결과 집합(result set)를 반환한다. 이 메소드를 위한 Criteria는 단 한 개의 결과를 반환하도록 만들어져야 한다. 이 메소드와 단지 첫 열만을 얻어오는 것과 혼동하지 말아야 한다.</td></tr><tr class="table-even"><td><strong class="bold">scroll</strong></td><td>스크롤되는 결과를 반환한다.</td></tr><tr class="table-odd"><td><strong class="bold">listDistinct</strong></td><td>서브쿼리나 관계를 이용할 때 결과 집합에서 동일한 열이 여러개 존재할 수 있는데 이 것으로 중복을 허용하지 않을 수 있다. <a href="http://www.hibernate.org/hib_docs/v3/api/org/hibernate/criterion/CriteriaSpecification.html" class="api">CriteriaSpecification</a> 클래스의 <code>DISTINCT_ROOT_ENTITY</code>와 동일하다.</td></tr></table><p class="paragraph"/><h2><a name="5.4.3 Hibernate Query Language (HQL)">5.4.3 Hibernate Query Language (HQL)</a></h2>GORM에서는 HQL도 사용할 수 있다. Hiberate 문서의 <a href="http://www.hibernate.org/hib_docs/reference/en/html/queryhql.html" target="blank">14장 HQL: The Hibernate Query Language</a>에서 HQL에대한 모든 것을 참고할 수 있다.<p class="paragraph"/>GORM은 find, <a href="../ref/Domain Classes/findAll.html" class="domainClasses">findAll</a> <a href="../ref/Domain Classes/executeQuery.html" class="domainClasses">executeQuery</a> 등의 HQL을 사용할 수 있는 얼마간의 메소드들을 제공한다.<p class="paragraph"/><div class="code"><pre>def results =
      Book.findAll(<span class="java&#45;quote">"from Book as b where b.title like 'Lord of the%'"</span>)</pre></div><p class="paragraph"/><h4>Positional and Named Parameters(위치 파라미터와 이름 파라미터)</h4><p class="paragraph"/>쿼리에 필요한 값은 하드코딩하려 한다면 위치 파리미터를 사용할 수 있다:<p class="paragraph"/><div class="code"><pre>def results =
      Book.findAll(<span class="java&#45;quote">"from Book as b where b.title like ?"</span>, &#91;<span class="java&#45;quote">"The Shi%"</span>&#93;)</pre></div><p class="paragraph"/>이름 파라미터를 사용하는 것도 가능하다:<p class="paragraph"/><div class="code"><pre>def results =
      Book.findAll(<span class="java&#45;quote">"from Book as b where b.title like :search or b.author like :search"</span>, &#91;search:<span class="java&#45;quote">"The Shi%"</span>&#93;)</pre></div><p class="paragraph"/><h4>Multiline Queries(여러 줄로 질의하기)</h4><p class="paragraph"/>쿼리를 여러줄에 걸쳐서 만들어야 한다면 라인연결문자를 사용하라:<p class="paragraph"/><img border="0" class="center" src="../img/multilinehql.png"></img><p class="paragraph"/><blockquote class="note">
여러 줄 문자열을 만들기 위한 Groovy로 표현법은 HQL 쿼리에 사용할 수 없다.
</blockquote><p class="paragraph"/><h4>Pagination and Sorting(페이지 매김과 정렬)</h4><p class="paragraph"/>HQL에서도 패이지를 매길 수 있고 정열할 수 있다. 간단하게 메소드 끝에 맵 형식으로 페이지 매김과 정열 옵션을 기술한다.<p class="paragraph"/><div class="code"><pre>def results =
      Book.findAll(<span class="java&#45;quote">"from Book as b where b.title like 'Lord of the%'"</span>, 
                   &#91;max:10, offset:20, sort:<span class="java&#45;quote">"title"</span>, order:<span class="java&#45;quote">"asc"</span>&#93;)</pre></div><h2><a name="5.5 Advanced GORM Features">5.5 Advanced GORM Features</a></h2>앞으로 우리는 캐싱, 매핑 방법, 이벤트를 다루는 방법들에 대해 알아보자.
<h2><a name="5.5.1 Events and Auto Timestamping">5.5.1 Events and Auto Timestamping</a></h2>GORM은 delete, insert, update같은 이벤트가 발생할 때 수행될 클로저(closure)를 등록할 수 있다. 단순히 도메인 클래스의 이벤트에 적절한 클로저를 동록하면 된다. 다음과 같은 이벤트들이 있다.<p class="paragraph"/><h4>The beforeInsert event(beforeInsert 이벤트)</h4><p class="paragraph"/>객체가 데이터베이스에 저장되기 전에 실행된다.<p class="paragraph"/><div class="code"><pre>class Person &#123;
   Date dateCreated<p class="paragraph"/>   def beforeInsert = &#123;
       dateCreated = <span class="java&#45;keyword">new</span> Date()
   &#125;
&#125;</pre></div><p class="paragraph"/><h4>The beforeUpdate event(beforeUpdate 이벤트)</h4><p class="paragraph"/>객체가 업데이트되기 전에 실행된다.<p class="paragraph"/><div class="code"><pre>class Person &#123;
   Date dateCreated
   Date lastUpdated<p class="paragraph"/>   def beforeInsert = &#123;
       dateCreated = <span class="java&#45;keyword">new</span> Date()
   &#125;
   def beforeUpdate = &#123;
       lastUpdated = <span class="java&#45;keyword">new</span> Date()
   &#125;
&#125;</pre></div><p class="paragraph"/><h4>The beforeDelete event(beforeDelete 이벤트)</h4><p class="paragraph"/>객체가 삭제되기 전에 실행된다.<p class="paragraph"/><div class="code"><pre>class Person &#123;
   <span class="java&#45;object">String</span> name
   Date dateCreated
   Date lastUpdated<p class="paragraph"/>   def beforeDelete = &#123;
      <span class="java&#45;keyword">new</span> ActivityTrace(eventName:<span class="java&#45;quote">"Person Deleted"</span>,data:name).save()
   &#125;
&#125;</pre></div><p class="paragraph"/><h4>The onLoad event(onLoad 이벤트)</h4><p class="paragraph"/>데이터베이스에서 객체가 로드될때 실행된다:<p class="paragraph"/><div class="code"><pre>class Person &#123;
   <span class="java&#45;object">String</span> name
   Date dateCreated
   Date lastUpdated<p class="paragraph"/>   def onLoad = &#123;
      name = <span class="java&#45;quote">"I'm loaded"</span>
   &#125;
&#125;</pre></div><p class="paragraph"/><h4>Automatic timestamping(자동 시간도장)</h4><p class="paragraph"/>위의 예에서 이벤트를 사용하여 <code>lastUpdated</code>와 <code>dateCreated</code> 프로퍼티를 업데이트하는 방법에 대해 알아보았다. GORM은 객체의 히스토리를 유지하는 다른방법을 제공한다. GORM에서는 단순히 <code>lastUpdated</code>와 <code>dateCreated</code> 프로퍼티만 정의하는 것만으로도 충분한다.<p class="paragraph"/>이 기능이 맘에 들지 않는다면 끌 수 있다:<p class="paragraph"/><div class="code"><pre>class Person &#123;
   Date dateCreated
   Date lastUpdated
   <span class="java&#45;keyword">static</span> mapping = &#123;
      autoTimestamp <span class="java&#45;keyword">false</span>
   &#125;
&#125;</pre></div><p class="paragraph"/><h2><a name="5.5.2 Custom ORM Mapping">5.5.2 Custom ORM Mapping</a></h2>Grails의 도메인 클래스는 ORM DSL(Object Relational Mapping Domain Specify Language) 레거시 스키마에 매핑될 수 있다. 다음 장에서 ORM DSL로 할 수 있는 일들을 설명한다.<p class="paragraph"/><blockquote class="note">
GORM의 관례에 따르는 테이블, 컬럼 이름등이 마음에 든다면 이 것은 전혀 필요없다. 캐싱을 한다거나 GORM을 레거시 스키마에 매핑하려 할때에만 이 기능이 필요하다.
</blockquote><p class="paragraph"/>도메인 클래스에 정적 mapping 블럭을 사용하므로써 매핑 규칙을 정의할 수 있다:<p class="paragraph"/><div class="code"><pre>class Person &#123;
  ..
  <span class="java&#45;keyword">static</span> mapping = &#123;<p class="paragraph"/>  &#125;
&#125;</pre></div>
<h2><a name="5.5.2.1 Table and Column Names">5.5.2.1 Table and Column Names</a></h2><h4>Table names(테이블 이름)</h4><p class="paragraph"/><code>table</code>을 사용하여 클래스가 매핑될 데이터베이스 테이블 이름을 정의할 수 있다.:<p class="paragraph"/><div class="code"><pre>class Person &#123;
  ..
  <span class="java&#45;keyword">static</span> mapping = &#123;
      table 'people'
  &#125;
&#125;</pre></div><p class="paragraph"/>이 경우 <code>person</code>이 아니라 <code>people</code>이라는 테이블에 매핑될 것이다.<p class="paragraph"/><h4>Column names(컬럼 이름)</h4><p class="paragraph"/>데이터베이스의 컬럼에 매핑하는 규칙도 정의할 수 있다. 다음의 예제처럼 원하는 이름으로 매핑시킬 수 있다:<p class="paragraph"/><div class="code"><pre>class Person &#123;
  <span class="java&#45;object">String</span> firstName
  <span class="java&#45;keyword">static</span> mapping = &#123;
      table 'people'
      firstName column:'First_Name'
  &#125;
&#125;</pre></div><p class="paragraph"/>이 예제에서는 매핑할 프로퍼티 이름은 <code>firstName</code>이고 <code>column</code>이라는 파라미터를 이용하여 어느 컬럼에 매핑할지 명시한다.<p class="paragraph"/><h4>Column type(컬럼 타입)</h4><p class="paragraph"/>GORM은 DSL의 타입 속성(attribute)으로 Hibernate 타입을 설정할 수 있다. 이 것은 <a href="http://www.hibernate.org/hib_docs/v3/api/org/hibernate/types/UserType.html" class="api">org.hibernate.types.UserType</a>를 상속한 사용자 타입도 명시할 수 있고 타입에 어떻게 영속성을 부여할지 정의할 수 있게 한다. <code>PostCodeType</code>을 만들었고 이 것을 사용한다면 다음의 예제처럼 할 수 있다:<p class="paragraph"/><div class="code"><pre>class Address &#123;
   <span class="java&#45;object">String</span> number
   <span class="java&#45;object">String</span> postCode
   <span class="java&#45;keyword">static</span> mapping = &#123;
      postCode type:PostCodeType
   &#125;
&#125;</pre></div><p class="paragraph"/>뿐만아니라 Grails가 선택하는 기본 타입을 사용하지 않고 Hibernate가 제공하는 기본 타입중에 하나로 매핑하게 할 수 있다:<p class="paragraph"/><div class="code"><pre>class Address &#123;
   <span class="java&#45;object">String</span> number
   <span class="java&#45;object">String</span> postCode
   <span class="java&#45;keyword">static</span> mapping = &#123;
      postCode type:'text'
   &#125;
&#125;</pre></div><p class="paragraph"/>이 예제에서는 <code>postCode</code> 컬럼이 SQL TEXT나 CLOB 형식에 매핑된다. 매핑되는 형식은 사용하는 데이터베이스에 따라 다르다.<p class="paragraph"/><h4>One-to-One Mapping(일대일 매핑)</h4><p class="paragraph"/>관계(association)가 있을 때 관계를 매핑하는 외래 키를 변경하는 것도 가능하다. 일대일 관계에서는 일반 컬럼을 매핑하는 것과 동일하다. 예를 들면 다음과 같다:<p class="paragraph"/><div class="code"><pre>class Person &#123;
  <span class="java&#45;object">String</span> firstName
  Address address
  <span class="java&#45;keyword">static</span> mapping = &#123;
      table 'people'
      firstName column:'First_Name'
	  address column:'Person_Adress_Id'
  &#125;
&#125;</pre></div><p class="paragraph"/>기본적으로 <code>address</code> 관계는 외래키 컬럼 <code>address_id</code>에 매핑된다. 그러나 <code>Person_Adress_Id</code> 컬럼에 매핑하도록 변경했다.<p class="paragraph"/><h4>One-to-Many Mapping(일대다 매핑)</h4><p class="paragraph"/>양방향 일대다 관계에서는 '다'쪽의 컬럼이름을 변경하는 것만으로도 외래키 컬럼을 변경할 수 있다. 하지만 단방향 관계에서는 관계 자체에 외래키를 명시해야 한다. 다음은 <code>Person</code>과 <code>Address</code>사이의 단방향 일대다 관계에서 <code>address</code> 테이블의 외래키를 변경시키는 예제이다:<p class="paragraph"/><div class="code"><pre>class Person &#123;
  <span class="java&#45;object">String</span> firstName
  <span class="java&#45;keyword">static</span> hasMany = &#91;addresses:Address&#93;
  <span class="java&#45;keyword">static</span> mapping = &#123;
      table 'people'
      firstName column:'First_Name'
	  addresses column:'Person_Address_Id'
  &#125;
&#125;</pre></div><p class="paragraph"/><code>joinTable</code> 파라미터를 이용하면 <code>address</code> 테이블에 있는 컬럼이 아니라 테이블을 조인할 수 있다:<p class="paragraph"/><div class="code"><pre>class Person &#123;
  <span class="java&#45;object">String</span> firstName
  <span class="java&#45;keyword">static</span> hasMany = &#91;addresses:Address&#93;
  <span class="java&#45;keyword">static</span> mapping = &#123;
      table 'people'
      firstName column:'First_Name'
      addresses joinTable:&#91;name:'Person_Addresses', key:'Person_Id', column:'Address_Id'&#93;
  &#125;
&#125;</pre></div><p class="paragraph"/><h4>Many-to-Many Mapping(다대다 매핑)</h4><p class="paragraph"/>Grails에서는 기본적으로 n-n 관계를 조인 테이블으로 매핑한다. 다음은 n-n 관계의 예제이다:<p class="paragraph"/><div class="code"><pre>class Group &#123;
	&#8230;
	<span class="java&#45;keyword">static</span> hasMany = &#91;people:Person&#93;
&#125;
class Person &#123;
	&#8230;
	<span class="java&#45;keyword">static</span> belongsTo = Group
	<span class="java&#45;keyword">static</span> hasMany = &#91;groups:Group&#93;
&#125;</pre></div><p class="paragraph"/>이 예제에서 Grails는 <code>person</code>과 <code>group</code> 테이블을 참조하는 외래키 <code>person_id</code>와 <code>group_id</code>을 사용하여 <code>group_person</code>이라는 조인 테이블을 만든다. 각 클래스를 매핑할 때 mapping 블럭에 컬럼을 명시하여 매핑하는 컬럼도 변경할 수 있다:<p class="paragraph"/><div class="code"><pre>class Group &#123;
   &#8230;
   <span class="java&#45;keyword">static</span> mapping = &#123;
       people column:'Group_Person_Id'
   &#125;	
&#125;
class Person &#123;
   &#8230;
   <span class="java&#45;keyword">static</span> mapping = &#123;
       groups column:'Group_Group_Id'
   &#125;	
&#125;</pre></div><p class="paragraph"/>사용할 조인 테이블의 이름도 명시할 수 있다:<p class="paragraph"/><div class="code"><pre>class Group &#123;
   &#8230;
   <span class="java&#45;keyword">static</span> mapping = &#123;
       people column:'Group_Person_Id',joinTable:'PERSON_GROUP_ASSOCIATIONS'
   &#125;	
&#125;
class Person &#123;
   &#8230;
   <span class="java&#45;keyword">static</span> mapping = &#123;
       groups column:'Group_Group_Id',joinTable:'PERSON_GROUP_ASSOCIATIONS'
   &#125;	
&#125;</pre></div><h2><a name="5.5.2.2 Caching Strategy">5.5.2.2 Caching Strategy</a></h2><h4>Setting up caching(캐싱 설정하기)</h4><p class="paragraph"/><a href="http://www.hibernate.org/" target="blank">Hibernate</a> 는 사용자가 정의 가능한 캐시 프로바이더(cache provider)를 지원하는 2차 캐시 second-level cache를 가지고 있다. 다음의 예처럼 <code>grails-app/conf/DataSource.groovy</code>에 설정한다:<p class="paragraph"/><div class="code"><pre>hibernate &#123;
    cache.use_second_level_cache=<span class="java&#45;keyword">true</span>
    cache.use_query_cache=<span class="java&#45;keyword">true</span>
    cache.provider_class='org.hibernate.cache.EhCacheProvider'
&#125;</pre></div><p class="paragraph"/>당연히 원하는 대로 설정할 수 있다. 예를 들어, 분산 캐시 매커니즘을 사용하고 싶다면 그렇게 할 수 있다.<p class="paragraph"/><blockquote class="note">
캐시에 대하여, 특히 Hibernate의 2차 캐시second-level cache에 대하여 더 알고 싶으면 <a href="http://www.hibernate.org/hib_docs/reference/en/html/performance.html#performance-cache" target="blank">Hibernate 문서</a>에서 관련 주제를 참고하라.
</blockquote><p class="paragraph"/><h4>Caching instances(인스턴스 캐싱하기)</h4><p class="paragraph"/>기본적으로 캐싱되게 하려면 mapping 블럭에 <code>cache</code> 매소드를 호출한다:<p class="paragraph"/><div class="code"><pre>class Person &#123;
  ..
  <span class="java&#45;keyword">static</span> mapping = &#123;
      table 'people'
      cache <span class="java&#45;keyword">true</span>
  &#125;
&#125;</pre></div><p class="paragraph"/>이 예제에서는 lazy든 아니든 상관하지 않고 'read-write'로 캐싱한다. 물론 이 전략도 변경할 수 있다:<p class="paragraph"/><div class="code"><pre>class Person &#123;
  ..
  <span class="java&#45;keyword">static</span> mapping = &#123;
      table 'people'
      cache usage:'read&#45;only', include:'non&#45;lazy'
  &#125;
&#125;</pre></div><p class="paragraph"/><h4>Caching associations(관계 캐싱하기)</h4><p class="paragraph"/>인스턴스를 캐싱할 때 Hibernate의 2차 캐시를 사용하도록 할 수 있을 뿐만 아니라 객체의 컬렉션도 캐싱할 수 있다. 다음의 코드를 보면:<p class="paragraph"/><div class="code"><pre>class Person &#123;
  <span class="java&#45;object">String</span> firstName
  <span class="java&#45;keyword">static</span> hasMany = &#91;addresses:Address&#93;
  <span class="java&#45;keyword">static</span> mapping = &#123;
      table 'people'
      version <span class="java&#45;keyword">false</span>
      addresses column:'Address', cache:<span class="java&#45;keyword">true</span>
  &#125;
&#125;
class Address &#123;
   <span class="java&#45;object">String</span> number
   <span class="java&#45;object">String</span> postCode
&#125;</pre></div><p class="paragraph"/>이 예제는 addresses 컬렉션에 대해 'read-write'로 캐싱한다. 'read-write'뿐만 아니라 다른 것도 사용할 수 있다:<p class="paragraph"/><div class="code"><pre>cache:'read&#45;write' // or 'read&#45;only' or 'transactional'</pre></div><p class="paragraph"/>캐시 사용법에서 보다 자세히 설명한다.<p class="paragraph"/><h4>Cache usages(캐시 사용법)</h4><p class="paragraph"/>다음은 설정할 수 있는 캐싱 정책과 그 사용법에 대한 설명이다.
<ul class="star">
<li><code>read-only</code> - 영속 클래스를 전혀 수정하지 않고 읽기만 한다면 'read-only' 캐시를 사용하라.</li>
<li><code>read-write</code> - 데이터를 수정할 것이라면 'read-write' 캐시가 적절하다.</li>
<li><code>nonstrict-read-write</code> - 가끔 데이터를 수정하고(두 트랜젝션에서 동일한 아이템을 동시에 수정하지 않을 것 같다면) 엄격한 트랜젝션 격리(strict transaction isolation)가 필요없다면 <code>nonstrict-read-write</code>를 사용하는 것이 좋다.</li>
<li><code>transactional</code> - 이 전략은 JBoss의 TreeCache같은 완벽한 트랜젝션 지향 캐시 공급자(fully transactional cache providers)를 사용할 수 있게 해준다. 그런 캐시는 JTA 환경에서만 사용되고 <code>grails-app/conf/DataSource.groovy</code>파일에서의 <code>Hiberate</code> 설정에 <code>hibernate.transaction.manager_lookup_class</code>를 명시해야만 한다.</li>
</ul><p class="paragraph"/><h2><a name="5.5.2.3 Inheritance Strategies">5.5.2.3 Inheritance Strategies</a></h2>GORM은 기본적으로 상속 구조당 하나의 테이블(table-per-hierarchy)로 매핑시킨다. 이것은 데이터베이스의 컬럼이 <code>NOT-NULL</code> 제약조건을 따르도록 하지 못하는 단점이 있다. 클래스당 하나의 테이블(table-per-subclass)을 사용하는 전략을 취하려면 다음처럼 한다:<p class="paragraph"/><div class="code"><pre>class Payment &#123;
    <span class="java&#45;object">Long</span> id
    <span class="java&#45;object">Long</span> version
    <span class="java&#45;object">Integer</span> amount<p class="paragraph"/>    <span class="java&#45;keyword">static</span> mapping = &#123;
        tablePerHierarchy <span class="java&#45;keyword">false</span>
    &#125;
&#125;
class CreditCardPayment <span class="java&#45;keyword">extends</span> Payment  &#123;
    <span class="java&#45;object">String</span> cardNumber
&#125;</pre></div><p class="paragraph"/>기본 클래스인 <code>Payment</code>를 상속받은 모든 클래스는 상속 구조당 하나의 테이블(table-per-hierarchy)로 매핑되지 않을 것이다.<p class="paragraph"/><h2><a name="5.5.2.4 Custom Database Identity">5.5.2.4 Custom Database Identity</a></h2>DSL을 사용하여 GORM이 데이터베이스 식별자를 생성하는 방법을 정의할 수 있다. GORM은 사용하는 데이터베이스가 메커니즘에 따라 id를 생성한다. 이 것은 분명 최상의 방법인데 아직도 다른 방법으로 접근해야 하는 스키마들이 많이 있다.<p class="paragraph"/>Hibernate의 식별자 생성기id generator를 정의해야 한다. 입맛에 맞는 식별자 생성기(id generator)를 정의하고 그에 따라 매핑되게 할 수 있다.<p class="paragraph"/><div class="code"><pre>class Person &#123;
  ..
  <span class="java&#45;keyword">static</span> mapping = &#123;
      table 'people'
      version <span class="java&#45;keyword">false</span>
      id generator:'hilo', params:&#91;table:'hi_value',column:'next_value',max_lo:100&#93;
  &#125;
&#125;</pre></div><p class="paragraph"/>이 예에서는 Hibernate에 기본적으로 포함된 'hilo' 생성기를 사용한다. 'hilo' 생성기는 식별자를 생성하기 위해 별도의 테이블을 사용한다.<p class="paragraph"/><blockquote class="note">
Hibernate 생성기에 대한 정보가 더 필요하면 <a href="http://www.hibernate.org/hib_docs/reference/en/html/mapping.html#mapping-declaration-id-generator" target="blank">Hibernate reference documentation</a>를 참고하라
</blockquote><p class="paragraph"/>식별자가 사용하는 컬럼을 명시하려면 다음과 같이 할 수 있다:<p class="paragraph"/><div class="code"><pre>class Person &#123;
  ..
  <span class="java&#45;keyword">static</span> mapping = &#123;
      table 'people'
      version <span class="java&#45;keyword">false</span>
      id column:'person_id'
  &#125;
&#125;</pre></div>
<h2><a name="5.5.2.5 Composite Primary Keys">5.5.2.5 Composite Primary Keys</a></h2>GORM은 두 개 이상의 속성으로 구성되는 복합 식별자의 개념을 지원한다. 권장되는 방법이 아니지만 할 수 있다:<p class="paragraph"/><div class="code"><pre>class Person &#123;
  <span class="java&#45;object">String</span> firstName
  <span class="java&#45;object">String</span> lastName<p class="paragraph"/>  <span class="java&#45;keyword">static</span> mapping = &#123;
      id composite:&#91;'firstName', 'lastName'&#93;
  &#125;
&#125;</pre></div><p class="paragraph"/>이 예는 Person클래스의 <code>firstName</code>과 <code>lastName</code> 속성을 이용하는 복합 식별자를 만든다. 나중에 식별자로 인스턴스를 얻어와야 한다면 다음처럼 객체의 프로토타입을 이용해야 한다:<p class="paragraph"/><div class="code"><pre>def p = Person.get(<span class="java&#45;keyword">new</span> Person(firstName:<span class="java&#45;quote">"Fred"</span>, lastName:<span class="java&#45;quote">"Flintstone"</span>))
println p.firstName</pre></div>
<h2><a name="5.5.2.6 Database Indices">5.5.2.6 Database Indices</a></h2>우리는 종종 쿼리를 최적화 하기위해 테이블 인덱스를 사용해야 한다. 어떻게 사용해야 하는 가는 문제 도메인에 따라 다르고 쿼리가 사용되는 패턴에 따라 다르다. GORM의 DSL로 컬럼을 어떤 인덱스에 태워야 할지를 명시 할 수 있다:<p class="paragraph"/>
<div class="code"><pre>class Person &#123;
  <span class="java&#45;object">String</span> firstName
  <span class="java&#45;object">String</span> address
  <span class="java&#45;keyword">static</span> mapping = &#123;
      table 'people'
      version <span class="java&#45;keyword">false</span>
      id column:'person_id'
      firstName column:'First_Name', index:'Name_Idx'
      address column:'Address', index:'Name_Idx, Address_Index'
  &#125;
&#125;</pre></div><p class="paragraph"/><p class="paragraph"/><h2><a name="5.5.2.7 Optimistic Locking and Versioning">5.5.2.7 Optimistic Locking and Versioning</a></h2><a href="../guide/single.html#5.3.5 Pessimistic and Optimistic Locking" class="guide">낙관적 잠금과 비관적 잠금</a>에 대해 이미 살펴보았듯이 기본적으로 GORM은 낙관적 작금을 사용하고 자동으로 <code>version</code> 속성을 모든 클래스에 주입(inject)한다. 그리고 이 <code>version</code> 속성은 데이터베이스의 <code>version</code> 컬럼에 매핑된다.<p class="paragraph"/>레거시 스키마에 이대로 매핑한다면 골칫거리가 될 뿐이다. 레거시 스키마에 매핑할 때에는 이 기능을 끌 수 있다:<p class="paragraph"/><div class="code"><pre>class Person &#123;
  ..
  <span class="java&#45;keyword">static</span> mapping = &#123;
      table 'people'
      version <span class="java&#45;keyword">false</span>
  &#125;
&#125;</pre></div><p class="paragraph"/><blockquote class="note">
낙관적 잠금을 사용하지 않으면 근본적으로 동시 업데이트를 고려해야 한다. 그리고 <a href="../guide/single.html#5.3.5 Pessimistic and Optimistic Locking" class="guide">비관적 잠금</a>을 사용하지 않으면 사용자가 데이터를 덮어 쓸수도 있기 때문에 언제라도 데이터를 잃어 버릴 수 있다.
</blockquote>
<h2><a name="5.5.2.8 Eager and Lazy Fetching">5.5.2.8 Eager and Lazy Fetching</a></h2><h5>Lazy Collections(Lazy 컬렉션)</h5><p class="paragraph"/>
<a href="../guide/single.html#5.3.4 Eager and Lazy Fetching" class="guide">Eager 패칭과 Lazy 패칭</a>에서 이미 살펴봤듯이 GORM은 기본적으로 컬렉션에대해 lazy 패칭을 사용한다. 이 것은 <code>fetchMode</code> 설정으로 변경할 수 있다. 그러나 ORM DSL을 이용하여 모든 매핑 설정을 한데 모을 수 있다:<p class="paragraph"/><div class="code"><pre>class Person &#123;
  <span class="java&#45;object">String</span> firstName
  <span class="java&#45;keyword">static</span> hasMany = &#91;addresses:Address&#93;
  <span class="java&#45;keyword">static</span> mapping = &#123;
      addresses lazy:<span class="java&#45;keyword">false</span>
  &#125;
&#125;
class Address &#123;
  <span class="java&#45;object">String</span> street
  <span class="java&#45;object">String</span> postCode
&#125;</pre></div><p class="paragraph"/><h4>Lazy Single-Ended Associations(한 쪽의 관계에서의 Lazy 패칭)</h4><p class="paragraph"/>GORM에서 1-1 과 n-1 association은 기본적으로 lazy 패칭이 아니다. 다른 엔터티와의 관계가 많은 엔터티를 로드하는 경우에 골칫거리가 될 수 있다. 엔터티를 로드할 때마다 새로운 SELECT 문이 수행되기 때문에 문제가 된다. 1-n, n-n association에서 lazy 컬렉션을 이용하여 lazy 패칭을 하게 할 수 있다:<p class="paragraph"/><div class="code"><pre>class Person &#123;
	<span class="java&#45;object">String</span> firstName
	<span class="java&#45;keyword">static</span> belongsTo = &#91;address:Address&#93;
	<span class="java&#45;keyword">static</span> mapping = &#123;
		address lazy:<span class="java&#45;keyword">true</span> // lazily fetch the address
	&#125;
&#125;
class Address &#123;
	<span class="java&#45;object">String</span> street
	<span class="java&#45;object">String</span> postCode
&#125;</pre></div><p class="paragraph"/><code>Person</code> 클래스의 <code>address</code> 속성이 필요할 때(lazily) Load되도록 설정했다.<p class="paragraph"/><h2><a name="5.6 Programmatic Transactions">5.6 Programmatic Transactions</a></h2>Grails는 Spring을 기반으로 만들었고 Spring의 Transaction 추상화 기술을 사용하여 트랜젝션 프로그래밍을 지원한다. GORM은 클래스에 <a href="../ref/Domain Classes/withTransaction.html" class="domainClasses">withTransaction</a> 메소드를 추가하여 사용하기 쉽도록 개선했다. withTransaction 메소드는 첫 번째 인자로 Spring의 <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/transaction/TransactionStatus.html" class="api">TransactionStatus</a> 객체를 넘겨 받는다.<p class="paragraph"/>일반적인 사용법은 다음과 같다:<p class="paragraph"/><div class="code"><pre>def transferFunds = &#123;
	Account.withTransaction &#123; status &#45;&#62;
		def source = Account.get(params.from)
		def dest = Account.get(params.to)<p class="paragraph"/>		def amount = params.amount.toInteger()
		<span class="java&#45;keyword">if</span>(source.active) &#123;
			source.balance &#45;= amount
			<span class="java&#45;keyword">if</span>(dest.active) &#123;
				dest.amount += amount
			&#125;
			<span class="java&#45;keyword">else</span> &#123;
				status.setRollbackOnly()
			&#125;
		&#125;<p class="paragraph"/>		
	&#125;<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/>이 예제에서 dest 계좌가 active가 아니면 트랜젝션이 롤백되고 트랜젝션이 처리되는 중간에 예외가 발생하면 자동으로 롤백된다.<p class="paragraph"/>트랜젝션이 통째로 롤백되지 않고 특정 시점으로 트랜젝션이 롤백되도록 “save points”를 사용할 수 있다. 이 것은 Spring의 <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/transaction/SavepointManager.html" class="api">SavePointManager</a> 인터페이스를 사용하여 구현됐다.<p class="paragraph"/>
<a href="../ref/Domain Classes/withTransaction.html" class="domainClasses">withTransaction</a> 메소드의 블럭내에서만 begin/commit/rollback 로직을 수행할 수 있다.
<h2><a name="5.7 GORM and Constraints">5.7 GORM and Constraints</a></h2>유효성 검사(<a href="../guide/single.html#7.1 Declaring Constraints" class="guide">Validation</a>)에서도 제약조건이 언급되지만 어떤 제약조건은 테이터베이스 스키마를 생성하는 방법에 영향을 준다. 그래서 여기에서도 검토할 필요가 있다.<p class="paragraph"/>운 좋게도 Grails의 제약조건은 도메인 클래스의 속성과 관련된 데이터베이스 컬럼을 생성하는 방법에 관여한다.<p class="paragraph"/>다음 예를 보자. 다음 속성을 갖는 도메인 모델을 만들었다.<p class="paragraph"/><div class="code"><pre><span class="java&#45;object">String</span> name
<span class="java&#45;object">String</span> description</pre></div><p class="paragraph"/>MySQL의 경우에 기본적으로 GORM은 이 컬럼을 다음과 같이 정의한다.<p class="paragraph"/><div class="code"><pre>컬럼 이름 | 데이터 타입
 description | varchar(255)</pre></div><p class="paragraph"/>그러나 도메인 클래스의 비지니스 로직은 description의 길이가 1000자가 될 수도 있다. 이 경우에 SQL로 테이블을 생성한다면 다음처럼 할 것이다.<p class="paragraph"/><div class="code"><pre>컬럼 이름 | 데이터 타입 
 description | TEXT</pre></div><p class="paragraph"/>데이터를 저장하기 전에 어플리케이션에서 1000자를 초과하지 못하도록 하는 유효성 검사를 했으면 좋겠다. Grails에서는 <a href="../guide/single.html#7.1 Declaring Constraints" class="guide">constraints</a>로 이 일을 할 수 있다. 도메인 클래스에 다음과 같이 코드를 추가한다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">static</span> constraints = &#123;
        description(maxSize:1000)
&#125;</pre></div><p class="paragraph"/>이 제약조건은 어플리케이션에서 유효성을 검사하도록 할뿐만 아니라 위에서 설명한 대로 스키마를 생성한다. 이제부터는 스키마 생성에 관여하는 다른 제약조건들을 살펴볼 것이다.<p class="paragraph"/><h4>Constraints Affecting String Properties(문자열 속성에 관여하는 제약조건들)</h4>
<ul class="star">
<li><a href="../ref/Constraints/inList.html" class="constraints">inList</a></li>
<li><a href="../ref/Constraints/maxSize.html" class="constraints">maxSize</a></li>
<li><a href="../ref/Constraints/size.html" class="constraints">size</a></li>
</ul><p class="paragraph"/><code>maxSize</code>나 <code>size</code> 제약조건이 있으면 Grails는 제약조건의 값을 참조하여 최대 컬럼 길이를 결정한다.<p class="paragraph"/>일반적으로 동일한 도메인 클래스의 속성에 이 두개의 제약조건 동시에 사용하는 것을 권장하지 않는다. 그러나 <code>maxSize</code> 제약조건과 <code>size</code> 제약조건이 둘 다 정의되면 Grails는 <code>maxSize</code> 제약조건의 값과 <code>size</code> 제약조건의 상한 값중에서 작은 수에 따라 컬럼의 길이를 결정한다(이 값을 초과하면 유효성 검사에서 에러를 발생시키기 때문에 Grails는 두 값 중에서 최소값을 사용한다).<p class="paragraph"/>inList 제약조건이 정의되면(그리고 <code>maxSize</code>와 <code>size</code> 제약조건이 정의되어있지 않다면) Grails는 유요한 값 중에서 가장 긴 문자열의 길이를 컬럼의 최대 길이로 설정한다. 예를 들어, "Java", "Groovy", "C++"들이 있을 때 Grails는 컬럼의 길이를 6으로 설정한다("Groovy" 문자열의 길이가 6이다).<p class="paragraph"/><h4>Constraints Affecting Numeric Properties(숫자 속성에 관여하는 제약조건들)</h4>
<ul class="star">
<li><a href="../ref/Constraints/min.html" class="constraints">min</a></li>
<li><a href="../ref/Constraints/max.html" class="constraints">max</a></li>
<li><a href="../ref/Constraints/range.html" class="constraints">range</a></li>
</ul><p class="paragraph"/>max 제약조건, min 제약조건, range 제약조건이 정의되면 Grails는 이 제약조건들에 따라 컬럼의 전체 자릿수(<a href="http://uk.builder.com/architecture/db/0,39026552,20268520,00.htm" target="blank">precision</a>)를 결정한다. 이 제약조건의 적용 여부는 Hibernate가 사용하는 DBMS를 어떻게 연동되는 가에 달려있다.<p class="paragraph"/>일반적으로 동일한 도메인 클래스의 속성에 min/max 제약조건과 range 제약조건을 동시에 사용하는 것을 권장하지 않는다. 만약 이 제약조건이 동시에 사용되면 Grails는 제약조건중 가장 작은 값을 사용한다(최소 전체 자릿수precision를 벗어나는 값은 유효성 검사에서 에러를 발생시키기 때문에 Grails는 두 개중 작은 값을 사용한다).
<ul class="star">
<li><a href="../ref/Constraints/scale.html" class="constraints">scale</a></li>
</ul><p class="paragraph"/>scale 제약조건이 정의되면 Grails는 이 제약조건의 값에 따라 컬럼의 소수 자릿수(<a href="http://uk.builder.com/architecture/db/0,39026552,20268520,00.htm" target="blank">scale</a>)를 결정한다(예를 들면, java.lang.Float, java.Lang.Double, java.lang.BigDecimal, or subclasses of java.lang.BigDecimal). 이 제약조건의 적용 여부는 Hibernate가 사용하는 DBMS를 어떻게 연동되는 가에 달려있다.<p class="paragraph"/>제약조건에 최대, 최소 값을 정의하면 Grails는 전체 자리수(precision)에 사용할 최대 값을 산출해낸다. 'max:100'만 설정되면 매우 큰 음수가 있을 수 있기 때문에 min/max 제약조건은 둘 다 설정되지 않으면 스키마 생성에 관여하지 않는다는 것을 잊지마라. 제약조건의 값이 Hibernate 컬럼의 전체 자릿수(현재는 기본값이 19다)보다 크지 않으면 Hibernate의 기본값이 사용된다. 예를 들면:<p class="paragraph"/><div class="code"><pre>someFloatValue(max:1000000, scale:3)</pre></div><p class="paragraph"/>이 것은 다음과 같은 의미이다:<p class="paragraph"/><div class="code"><pre>someFloatValue DECIMAL(19, 3) // 기본 전체 자릿수(precision)가 적용됐다.</pre></div><p class="paragraph"/>그러나 다음과 같은 경우엔:<p class="paragraph"/><div class="code"><pre>someFloatValue(max:12345678901234567890, scale:5)</pre></div><p class="paragraph"/>다음과 같은 의미를 가진다:<p class="paragraph"/><div class="code"><pre>someFloatValue DECIMAL(25, 5) // 전체 자릿수(precision) = max 값의 자릿수 + 소수 자릿수(scale)</pre></div><p class="paragraph"/>또 다음처럼 min, max 제약조건이 동시에 사용하는 경우에는:<p class="paragraph"/><div class="code"><pre>someFloatValue(max:100, min:&#45;100000)</pre></div><p class="paragraph"/>다음과 같은 의미를 가진다:<p class="paragraph"/><div class="code"><pre>someFloatValue DECIMAL(8, 2) // 전체 자릿수(precision) = min 값의 자릿수 + 기본 소수자릿수(scale:2)</pre></div><h1><a name="6. The Web Layer">6. The Web Layer</a></h1><h2><a name="6.1 Controllers">6.1 Controllers</a></h2>컨트롤러(Controller)는 요청(<a href="../ref/Controllers/request.html" class="controllers">request</a>)을 처리해 응답(response)을 생성한다. 요청이 들어올 때마다 새로운 인스턴스가 생성되고 컨트롤러는 응답을 생성하거나 뷰에 넘길 수 있다. 컨트롤러를 만드는 방법은 쉽다. <code>Controller</code>로 끝나는 클래스를 만들고 이 클래스를 <code>grails-app/controllers</code> 디렉토리에 넣으면 된다.<p class="paragraph"/>먼저 컨트롤러 이름을 URI에 매핑하고 그 다음에 컨트롤러에 정의된 액션을 URI에 매핑하는 것이 기본적으로 <a href="../guide/single.html#6.4 URL Mappings" class="guide">URL이 매핑</a>되는 방법이다.<p class="paragraph"/><h2><a name="6.1.1 Understanding Controllers and Actions">6.1.1 Understanding Controllers and Actions</a></h2><h4>Creating a controller(컨트롤러 만들기)</h4><p class="paragraph"/><a href="../ref/Command Line/create-controller.html" class="commandLine">create-controller</a> 명령(target)으로 컨트롤러를 만들 수 있다. Grails 프로젝트의 루트(root) 디렉토리에서 다음의 명령을 실행한다:<p class="paragraph"/><div class="code"><pre>grails create&#45;controller book</pre></div><p class="paragraph"/>이 명령을 실행하면 컨트롤러가 <code>grails-app/controllers/BookController.groovyv</code>파일에 만들어진다:<p class="paragraph"/>
<div class="code"><pre>class BookController &#123; &#8230; &#125;</pre></div><p class="paragraph"/>이 <code>BookController</code>는 기본적으로 /book URI로 매핑된다(어플리케이션의 루트의 하위로).<p class="paragraph"/><blockquote class="note">
<code>create-controller</code> 명령은 매우 편리하다. 아주 쉽게 컨트롤러를 만들고 텍스트 에디터나 IDE로 편집할 수 있다.
</blockquote><p class="paragraph"/><h4>Creating Actions(액션 만들기)</h4><p class="paragraph"/>컨트롤러는 코드 블럭으로 구현된 많은 프로퍼티를 가질 수 있다. 각 프로퍼티는 URI에 매핑된다.<p class="paragraph"/><div class="code"><pre>class BookController &#123;
    def list = &#123;<p class="paragraph"/>        // <span class="java&#45;keyword">do</span> controller logic
        // create model<p class="paragraph"/>        <span class="java&#45;keyword">return</span> model
    &#125;
&#125;</pre></div><p class="paragraph"/>이 예제의 list 프로퍼티는 기본적으로 <code>/book/list</code>로 매핑된다.<p class="paragraph"/><h4>The Default Action(기본 액션)</h4><p class="paragraph"/>컨트롤러의 URI에 매핑하는 기본 액션이 있다. 이 경우의 기본 URI는 <code>/book</code>이고 기본 URI는 다음 규칙을 따른다.
<ul class="star">
<li>컨트롤러에 액션이 하나밖에 없다면 기본 URI는 그 액션에 매핑된다.</li>
<li>/book에 명시된 액션이 없을 때 요청을 처리하는 액션은 <code>index</code> 액션이다.</li>
<li><code>defaultAction</code> 프로퍼티를 이용해서 기본 URI에 매핑되는 액션을 설정할 수 있다:</li>
</ul><p class="paragraph"/><div class="code"><pre>def defaultAction = <span class="java&#45;quote">"list"</span></pre></div>
<h2><a name="6.1.2 Controllers and Scopes">6.1.2 Controllers and Scopes</a></h2><h4>Available Scopes(이용할 수 있는 스콥)</h4><p class="paragraph"/>스콥는 본질적으로 변수를 저장할 수 있는 해시 객체다. 컨트롤러에서 사용가능한 스콥은 다음과 같다.
<ul class="star">
<li><a href="../ref/Controllers/servletContext.html" class="controllers">servletContext</a> - 어플리케이션 스콥이라고도 한다. 이 스콥은 전체 웹 어플리케이션의 상태를 공유할 수 있게 한다. 이 servletContext는 <a href="http://java.sun.com/j2ee/1.4/docs/api/javax/servlet/ServletContext.html" class="api">javax.servlet.ServletContext</a>의 인스턴스다.</li>
<li><a href="../ref/Controllers/session.html" class="controllers">session</a> - 이 session은 사용자의 상태와 관련돼 있다. 일반적으로 클라이언트의 세션과 연관된 쿠키를 사용한다. 이 session은 <a href="http://java.sun.com/j2ee/1.4/docs/api/javax/servlet/http/HttpSession.html" class="api">HttpSession</a>의 인스턴스다.</li>
<li><a href="../ref/Controllers/request.html" class="controllers">request</a> - 이 request 객체에는 현재 요청과 관련된 객체들을 저장할 수 있다. 이 <strong class="bold"> </strong> request는 HttpServletRequest의 객체이다.</li>
<li><a href="../ref/Controllers/params.html" class="controllers">params</a> - 요청(CGI) 파리미터들의 맵이다.</li>
<li><a href="../ref/Controllers/flash.html" class="controllers">flash</a> - 나중에 설명한다.</li>
</ul><p class="paragraph"/><h4>Accessing Scopes(스콥 사용하기)</h4><p class="paragraph"/>스콥은 변수 이름과 Groovy의 배열 인덱스 연산자를 이용하여 접근할 수 있다. 이 것은 <a href="http://java.sun.com/j2ee/1.4/docs/api/javax/servlet/http/HttpServletRequest.html" class="api">HttpServletRequest</a>같은 Servlet API에 정의돼 있는 클래스들을 사용한다.<p class="paragraph"/><div class="code"><pre>class BookController &#123;
    def find = &#123;
        def findBy = params&#91;<span class="java&#45;quote">"findBy"</span>&#93;
        def appContext = request&#91;<span class="java&#45;quote">"foo"</span>&#93;
        def loggedUser = session&#91;<span class="java&#45;quote">"logged_user"</span>&#93;<p class="paragraph"/>    &#125;
&#125;</pre></div><p class="paragraph"/>코드을 더 명료하게 하는 역참조(de-reference) 연산자로 Scope 변수에 접근할 수도 있다:<p class="paragraph"/><div class="code"><pre>class BookController &#123;
    def find = &#123;
        def findBy = params.findBy
        def appContext = request.foo
        def loggedUser = session.logged_user<p class="paragraph"/>    &#125;
&#125;</pre></div><p class="paragraph"/>이 방법은 Grails가 스콥들에 통일된 방법으로 접근할 수 있도록 제공하는 방법중 한 가지 방법이다.<p class="paragraph"/><h4>Using Flash Scope(Flash 스콥)</h4><p class="paragraph"/>Grails는 <a href="../ref/Controllers/flash.html" class="controllers">flash</a> 스콥을 지원한다. flash 스콥에는 현재 요청부터 다음 요청까지 전달해야 할 프로퍼티를 저장할 수 있다. 그 후 이 프로퍼티는 지워진다. 리다이렉션으로 바로 처리될 메시지를 전달하는데 유용하다. 예를 들어:<p class="paragraph"/><div class="code"><pre>def delete = &#123;
    def b = Book.get( params.id )
    <span class="java&#45;keyword">if</span>(!b) &#123;
        flash.message = <span class="java&#45;quote">"User not found <span class="java&#45;keyword">for</span> id $&#123;params.id&#125;"</span>
        redirect(action:list)
    &#125;
    &#8230; // remaining code
&#125;</pre></div>
<h2><a name="6.1.3 Models and Views">6.1.3 Models and Views</a></h2><h4>Returning the Model(모델 반환하기)</h4><p class="paragraph"/>모델은 엄밀히 렌더링할 때 뷰에서 사용하는 맵이다. 이 맵의 키는 뷰에서 접근할 수 있는 변수 이름으로 변환된다. 모델을 반환하는 방법은 두 가지이다. 하나는 명시적으로 맵 인스턴스를 반환하는 방법이다:<p class="paragraph"/><div class="code"><pre>def show = &#123;
 	&#91; book : Book.get( params.id ) &#93;
&#125;</pre></div><p class="paragraph"/>명시적으로 반환하는 모델이 없으면 컨트롤러의 프로퍼티들이 모델로 사용된다. 그래서 다음과 같이 코드를 작성할 수 있다:<p class="paragraph"/><div class="code"><pre>class BookController &#123;
    List books
    List authors
    def list = &#123;
           books = Book.list()
           authors = Author.list()
    &#125;
&#125;</pre></div><p class="paragraph"/><blockquote class="note">
 이 것은 실제로 컨트롤러도 미리정의된(prototyped) 스콥이기 때문에 가능하다. 즉, 요청마다 새로운 컨트롤러가 생성된다. 요청마다 새로운 컨트롤러가 생성되지 않으면 이 코드는 쓰레드에 안전(thread safe)하지 못하다.
</blockquote><p class="paragraph"/>이 예제의 <code>books</code>와 <code>authors</code> 프로퍼티는 뷰에서 사용할 수 있다.<p class="paragraph"/>스프링의 <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/servlet/ModelAndView.html" class="api">ModelAndView</a> 클래스의 인스턴스를 반환할 수도 있는데 이 것은 좀 더 고급스런 방법이다.<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> org.springframework.web.servlet.ModelAndView<p class="paragraph"/>def index = &#123;
	// index 페이지를 위해 선호하는 책들을 가져온다.
    def favoriteBooks = &#8230; 
    // 이 책들을 보여주기 위해 list 뷰로 넘긴다.
    <span class="java&#45;keyword">return</span> <span class="java&#45;keyword">new</span> ModelAndView(<span class="java&#45;quote">"/book/list"</span>, &#91; bookList : favoriteBooks &#93;)
&#125;</pre></div><p class="paragraph"/>
<h4>Selecting the View(뷰 선택하기)</h4><p class="paragraph"/>여기까지 보여준 코드에서는 렌더링할 <a href="../guide/single.html#6.2 Groovy Server Pages" class="guide">view</a>를 명시하는 코드는 없었다. Grails는 어떤 뷰를 선택해야 하는지를 어떻게 알까? 해답은 '관례'에 있다. 다음과 같이 액션을 만든다:<p class="paragraph"/><div class="code"><pre>class BookController &#123;
	def show = &#123;
	 	&#91; book : Book.get( params.id ) &#93;
	&#125;	
&#125;</pre></div><p class="paragraph"/>Grails는 자동으로 <code>grails-app/views/book/show.gsp</code>라는 뷰를 찾을 것이다. 엄밀하게 Grails는 JSP 파일을 먼저 찾는다. Grails에서는 JSP도 사용할 수 있다.<p class="paragraph"/>다른 뷰를 사용하기 원한다면 다음처럼 <a href="../ref/Controllers/render.html" class="controllers">render</a> 메소드를 사용하여 변경할 수 있다.<p class="paragraph"/>
<div class="code"><pre>def show = &#123;
  	def map = &#91; book : Book.get( params.id ) &#93;
    render(view:<span class="java&#45;quote">"display"</span>, model:map)
&#125;</pre></div><p class="paragraph"/>이 예제에서 Grails는 <code>grails-app/views/book/display.gsp</code>를 렌더링하려고 할 것이다. Grails는 <code>grails-app/views</code> 디렉토리의 <code>book</code> 폴더에 있는 뷰를 사용하려 한다는 사실에 주목하라. 이 것이 관례이다. 이 관례 대신에 shared 뷰를 사용하게 하고 싶으면 다음과 같이 하라:<p class="paragraph"/><div class="code"><pre>def show = &#123;
  	def map = &#91; book : Book.get( params.id ) &#93;
    render(view:<span class="java&#45;quote">"/shared/display"</span>, model:map)
&#125;</pre></div><p class="paragraph"/>이 예제에서 Grails는 <code>grails-app/views/shared/display.gsp</code>를 이용하여 렌더링할 것이다.<p class="paragraph"/><h4>Rendering a Response(응답 만들기)</h4><p class="paragraph"/>(일반적으로 Ajax 어플리케이션에서는)텍스트나 코드의 조각(snippet)을 컨트롤러에서 바로 렌더링하는 것이 더 쉬울때도 있다. 이 경우 대단히 유연한 <code>render</code> 메소드를 사용한다:<p class="paragraph"/><div class="code"><pre>render <span class="java&#45;quote">"Hello World!"</span></pre></div><p class="paragraph"/>이 코드는 "Hello World!"를 응답으로 전달할 것이다. render 메소드로 할 수 있는 다른 예도 보자:<p class="paragraph"/>
<div class="code"><pre>// write some markup
render &#123;
   <span class="java&#45;keyword">for</span>(b in books) &#123;
      div(id:b.id, b.title)
   &#125;
&#125;
// 사용할 뷰를 명시한다
render(view:'show')
// 컬렉션의 각 아이템에 템플릿을 적용한다
render(template:'book_template', collection:Book.list())
// 명시한 엔코딩(encoding)과 컨텐트 타입(content type)에 따라 text를 렌더링한다
render(text:<span class="java&#45;quote">"&#60;xml&#62;some xml&#60;/xml&#62;"</span>,contentType:<span class="java&#45;quote">"text/xml"</span>,encoding:<span class="java&#45;quote">"UTF&#45;8"</span>)</pre></div><p class="paragraph"/>
<h2><a name="6.1.4 Redirects and Chaining">6.1.4 Redirects and Chaining</a></h2><h4>Redirects(리다이렉트)</h4><p class="paragraph"/><a href="../ref/Controllers/redirect.html" class="controllers">redirect</a> 메소드를 사용하여 액션을 리다이렉트(redirect)시킬 수 있다:<p class="paragraph"/><div class="code"><pre>class OverviewController &#123;
    def login = &#123;&#125;<p class="paragraph"/>    def find = &#123;
        <span class="java&#45;keyword">if</span>(!session.user)
           redirect(action:login)
        &#8230;
    &#125;
&#125;</pre></div><p class="paragraph"/>내부적으로 <a href="../ref/Controllers/redirect.html" class="controllers">redirect</a>는 <a href="http://java.sun.com/j2ee/1.4/docs/api/javax/servlet/http/HttpServletResponse.html" class="api">HttpServletResonse</a>객체의 <code>sendRedirect</code> 메소드를 사용한다:<p class="paragraph"/>
<code>redirect</code> 메소드로 다음과 같은 일을 할 수 있다:
<ul class="star">
<li>동일한 컨트롤러 클래스에서 다른 클로저로 리다이렉트 시킬 수 있다:</li>
</ul><p class="paragraph"/><div class="code"><pre>// 동일한 클래스의 login 액션을 호출한다
redirect(action:login)</pre></div>
<ul class="star">
<li>다른 컨트롤러와 액션으로 리다이렉트 시킬 수 있다:</li>
</ul><p class="paragraph"/><div class="code"><pre>// home 컨트롤러의 index 액션으로 리다이렉트된다
redirect(controller:'home',action:'index')</pre></div>
<ul class="star">
<li>어플리케이션 컨텍스트 경로의 하위에 있는 리소스의 URI로 리다이렉트 시킬 수 있다:</li>
</ul><p class="paragraph"/><div class="code"><pre>// 명시한 URI로 리다이렉트된다
redirect(uri:<span class="java&#45;quote">"/login.html"</span>)</pre></div>        
<ul class="star">
<li>URL로도 가능하다:</li>
</ul><p class="paragraph"/><div class="code"><pre>// 다른 사이트의 페이지로 리다아렉트 시킨다
redirect(url:<span class="java&#45;quote">"http://grails.org"</span>)</pre></div><p class="paragraph"/>메소드의 <code>params</code> 인자를 사용하여 액션에 파라미터를 넘길 수 있다:<p class="paragraph"/><div class="code"><pre>redirect(action:myaction, params:&#91;myparam:<span class="java&#45;quote">"myvalue"</span>&#93;)</pre></div><p class="paragraph"/>
이 파라미터들은 요청 파리미터에 접근할 수 있는 <a href="../ref/Controllers/params.html" class="controllers">params</a>라는 동적 프로퍼티을 통해서 이용할 수 있다. 만약 어떤 파리마티의 이름이 요청 파라미터와 동일하다면 요청 파라미터는 덮어 씌여져서(is overridden) 컨트롤러의 파라미터가 사용된다.<p class="paragraph"/><code>params</code> 객체는 맵이기 때문에 현재의 요청 파라미터를 다음 액션에 그대로 넘길 수 있다:<p class="paragraph"/><div class="code"><pre>redirect(action:<span class="java&#45;quote">"next"</span>, params:params)</pre></div><p class="paragraph"/><h4>Chaining(체이닝)</h4><p class="paragraph"/>액션은 연쇄적으로 묶일 수 있다. 체이닝은 한 액션에서 다음 액션까지 모델이 유지되도록 해준다. 다음 예제의 <code>first</code> 액션이 호출되면:<p class="paragraph"/><div class="code"><pre>class ExampleChainController &#123;
    def first = &#123;
        chain(action:second,model:&#91;one:1&#93;)
    &#125;
    def second  = &#123;
        chain(action:third,model:&#91;two:2&#93;)
    &#125;
    def third = &#123;
         &#91;three:3&#93;
    &#125;
&#125;</pre></div><p class="paragraph"/>
모델의 최종결과는 다음과 같다:<p class="paragraph"/><div class="code"><pre>&#91;one:1, two:2, three:3&#93;</pre></div><p class="paragraph"/>
모델은 <code>chainModel</code> 맵을 사용하여 다음에 실행되는 컨트롤러의 액션에서도 사용될 수 있다. 다음 예제처럼 액션에서만 이 동적 프로퍼티를 사용할 수 있고 <code>chain</code> 메소드를 호출한다:<p class="paragraph"/><div class="code"><pre>class ChainController &#123;<p class="paragraph"/>    def nextInChain = &#123;
        def model = chainModel.myModel
        &#8230;
    &#125;
&#125;</pre></div><p class="paragraph"/><code>redirect</code> 메소드처럼 <code>chain</code> 메소드에서도 파라미터를 넘길 수 있다:<p class="paragraph"/><div class="code"><pre>chain(action:<span class="java&#45;quote">"action1"</span>, model:&#91;one:1&#93;, params:&#91;myparam:<span class="java&#45;quote">"param1"</span>&#93;)</pre></div><p class="paragraph"/>
<h2><a name="6.1.5 Controller Interceptors">6.1.5 Controller Interceptors</a></h2>인터셉터는 요청, 세션, 어플리케이션의 상태를 처리하는 중에 가로채야intercept할 때 유용하다. 인터셉터는 액션으로 구현된고 현재는 before, after 두 종류의 인터셉터가 있다<p class="paragraph"/><blockquote class="note">
인터셉터를 하나 이상의 컨트롤러에 적용해야 한다면 <a href="../guide/single.html#6.6 Filters" class="guide">Filter</a>를 사용하는 것이 낫다. Filter는 여러 개의 컨트롤러나 URI이에 적용할 수 있고 각 컨트롤러의 로직을 변경할 필요도 없다.
</blockquote><p class="paragraph"/><h4>Before Interception</h4><p class="paragraph"/><code>beforeInterceptor</code>는 액션이 실해되기 전에 가로챈다. 만약 인터셉터가 <code>false</code>를 반환하면 요청된 액션은 실행되지 않는다. 인터셉터는 다음의 예제처럼 모든 액션에 적용될 수 있다.<p class="paragraph"/><div class="code"><pre>def beforeInterceptor = &#123;
       println <span class="java&#45;quote">"Tracing action $&#123;actionUri&#125;"</span>
&#125;</pre></div><p class="paragraph"/>이 예제는 컨트롤러 안에 정의된다. 이 인터셉터는 액션이 하나도 실행되기 전에 실행될 것이다. 다음은 일반적으로 사용하는 인증 예제이다:<p class="paragraph"/><div class="code"><pre>def beforeInterceptor = &#91;action:<span class="java&#45;keyword">this</span>.&#38;auth,except:'login'&#93;
// 보통의 메소드처럼 정의했지만 숨겨진다
def auth() &#123;
     <span class="java&#45;keyword">if</span>(!session.user) &#123;
            redirect(action:'login')
            <span class="java&#45;keyword">return</span> <span class="java&#45;keyword">false</span>
     &#125;
&#125;
def login = &#123;
     // 로그인 페이지를 보여준다
&#125;</pre></div><p class="paragraph"/>
이 예제에서는 <code>auth</code> 메소드를 호출하도록 정의했다. 외부에 액션이 노출되지 않았지만 메소드는 호출된다(액션이 숨겨진다). 이 <code>beforeInterceptor</code>는 login 액션을 제외(except)하고 모든 액션에 적용된다. 즉, 모든 액션이 실행되기 전에 'auth' 메소드가 실행된다. 'auth' 메소드는 Groovy의 메소드 포인터 문법을 사용하여 참조된다. 'auth' 메소드는 인증된 사용자인지를 검사하고 인증된 사용자가 아니면 login 액션으로 리다이렉트 시킨다. 그리고 이 메소드가 false를 반환하기 때문에 원래 요구된 액션은 실행되지 않는다.<p class="paragraph"/><h4>After Interception</h4><p class="paragraph"/>액션이 실행된 후에 실행되는 인터셉터는 <code>afterInterceptor</code> 프로퍼티를 이용하여 정의한다:<p class="paragraph"/><div class="code"><pre>def afterInterceptor = &#123; model &#45;&#62;
       println <span class="java&#45;quote">"Tracing action $&#123;actionUri&#125;"</span>
&#125;</pre></div><p class="paragraph"/>afterInterceptor는 결과 모델을 인자로 받는다. 이 인터셉터를 사용하여 액션이 실행된 후의 모델이나 응답을 관리할 수 있다.<p class="paragraph"/>afterInterceptor를 이용하면 렌더링하기 전에 Spring의 MVC <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/servlet/ModelAndView.html" class="api">ModelAndView</a> 객체도 수정할 수 있다. 위 예제에 적용하면 다음과 같이 된다:<p class="paragraph"/><div class="code"><pre>def afterInterceptor = &#123; model, modelAndView &#45;&#62;
       println <span class="java&#45;quote">"Current view is $&#123;modelAndView.viewName&#125;"</span>
       <span class="java&#45;keyword">if</span>(model.someVar) modelAndView.viewName = <span class="java&#45;quote">"/mycontroller/someotherview"</span>
       println <span class="java&#45;quote">"View is now $&#123;modelAndView.viewName&#125;"</span>
&#125;</pre></div><p class="paragraph"/>이 것는 액션이 반환하는 모델을 사용할 뷰를 변경시키는 예제다. 액션이 가로채어지고 render나 redirect를 호출되면 <code>modelAndView</code>는 <code>null</code>이 된다는 것을 기억하라.<p class="paragraph"/><h4>Interception Conditions(인터셉터에 조건 달기)</h4><p class="paragraph"/>Rails 사용자들은 인증 예제가 친숙할 것이고 인터셉터를 실행할 때 어떻게 'except' 조건을 사용해야 하는지를 잘 알고 있을 것이다(Rails에서는 인터셉터를 필터(filter)라고 부른다. 하지만 필터는 자바의 servlet filter와 혼동된다):<p class="paragraph"/><div class="code"><pre>def beforeInterceptor = &#91;action:<span class="java&#45;keyword">this</span>.&#38;auth,except:'login'&#93;</pre></div><p class="paragraph"/>이 인터셉터은 명시한 액션을 제외하고 모든 액션에 적용된다. 다음의 예처럼 여러 개의 액션을 명시할 수도 있다:<p class="paragraph"/><div class="code"><pre>def beforeInterceptor = &#91;action:<span class="java&#45;keyword">this</span>.&#38;auth,except:&#91;'login','register'&#93;&#93;</pre></div><p class="paragraph"/>다른 조건으로 'only'도 있다. 인터셉터은 오직 명시된 액션에만 적용된다:<p class="paragraph"/><div class="code"><pre>def beforeInterceptor = &#91;action:<span class="java&#45;keyword">this</span>.&#38;auth,only:&#91;'secure'&#93;&#93;</pre></div><p class="paragraph"/><h2><a name="6.1.6 Data Binding">6.1.6 Data Binding</a></h2>데이터 바인딩은 요청 파라미터를 객체의 프로퍼티이나 객체에 "결합"시키는(binding) 행위를 말한다. 데이터 바인딩시 폼(form)을 통해서 요청되는 일반적인 파리마터들의 형 변환을 고려해야 한다. 이 파라미터들은 Groovy나 Java 객체의 프로퍼티가 아니라 항상 문자열이다.<p class="paragraph"/>Grails는 <a href="http://www.springframework.org" target="blank">Spring&#39;s</a>이 제공하는 데이터 바인딩 기능을 이용하여 데이터를 바인딩한다.<p class="paragraph"/><h4>Binding Request Data to the Model(요청 데이터를 모델에 바인딩하기)</h4><p class="paragraph"/>도메인 클래스의 프로퍼티로 요청 파라미터를 바인딩시키는 방법은 두 가지다. 먼저 도메인 클래스의 묵시적(implicit) 생성자를 사용할 수 있다.<p class="paragraph"/><div class="code"><pre>def save = &#123;
  def b = <span class="java&#45;keyword">new</span> Book(params)
  b.save()
&#125;</pre></div><p class="paragraph"/><code>new Book(params)</code>에서 데이터를 바인딩 시킨다. Grails는 <a href="../ref/Controllers/params.html" class="controllers">params</a> 객체를 도메인 클래스의 생성자에 넘기면 자동으로 요청 파라미터를 바인딩해야 하는 것으로 간주한다. 만약 다음과 같은 요청이 들어온다면:<p class="paragraph"/><div class="code"><pre>/book/save?title=The%20Stand&#38;author=Stephen%20King</pre></div><p class="paragraph"/><code>title</code>과 <code>author</code>은 자동으로 도메인 클래스에 설정된다. 만약 존재하는 인스턴스로 바인딩해야 한다면 <a href="../ref/Domain Classes/properties.html" class="domainClasses">properties</a> 프로퍼티를 이용할 수 있다:<p class="paragraph"/><div class="code"><pre>def save = &#123;
  def b = Book.get(params.id)
  b.properties = params
  b.save()
&#125;</pre></div><p class="paragraph"/>이 것은 묵시적 생성자를 사용한 것과 동일하다.<p class="paragraph"/><h4>Data binding and Associations(데이터 바인딩과 관계)</h4><p class="paragraph"/>'일대일'이나 '일대다' 관계에서도 Grails가 데이터 바인딩 기능을 적용하여 관계를 업데이트할 수 있다. 다음과 같은 요청이 들어오면:<p class="paragraph"/><div class="code"><pre>/book/save?author.id=20</pre></div><p class="paragraph"/>다음의 예제처럼 데이터를 바인딩시킬 때 Grails는 자동으로 요청 파라미터의 <code>.id</code> 접미어를 해석하고 이 정보를 이용하여 <code>Author</code> 인스턴스 찾아낸다.<p class="paragraph"/><div class="code"><pre>def b = <span class="java&#45;keyword">new</span> Book(params)</pre></div><p class="paragraph"/><h4>Data binding with Multiple domain classes(데이터를 여러 개의 도메인 클래스에 바인딩하기)</h4><p class="paragraph"/><a href="../ref/Controllers/params.html" class="controllers">params</a> 객체를 이용하여 여러 개의 도메인 객체에 데이터를 바인딩 시킬 수 있다.<p class="paragraph"/>다음과 같은 요청이 들어오면:<p class="paragraph"/><div class="code"><pre>/book/save?book.title=The%20Stand&#38;author.name=Stephen%20King</pre></div><p class="paragraph"/>이 요청의 각 파라미터가 <code>author.</code>와 <code>book.</code>같은 접두어(Prefix)를 갖는다는 것에 주목해야 한다. 타입에 따라 파라미터를 분리해서 사용해야 한다. Grails의 <code>params</code> 객체는 다차원 해시같은 것이다. 바인딩 시킬 파라미터만을 분리 할 수 있다:<p class="paragraph"/><div class="code"><pre>def b = <span class="java&#45;keyword">new</span> Book(params&#91;'book'&#93;)</pre></div><p class="paragraph"/>바인드할 파라미터만을 분리하기 위해 <code>book.title</code>의 '.' 앞의 접미어만을 사용하는 것을 기억하라. 동일한 방법을 <code>Author</code> 클래스에도 적용할 수 있다:<p class="paragraph"/><div class="code"><pre>def a = <span class="java&#45;keyword">new</span> Author(params&#91;'author'&#93;)</pre></div><p class="paragraph"/><h4>Data binding and type conversion errors(데이터 바인딩과 타입 변환 에러)</h4><p class="paragraph"/>데이터를 바인딩시킬 때 문자열이 특별한 타입으로 변환되지 않는다. 이 때 타입 변환 에러가 발생하는데 Grails는 타입 변환 에러를 도메인 클래스의 <a href="../ref/Domain Classes/errors.html" class="domainClasses">errors</a> 프로퍼티에 남겨둔다. 예제를 보자:<p class="paragraph"/><div class="code"><pre>class Book &#123;
    &#8230;
    URL publisherURL
&#125;</pre></div><p class="paragraph"/>여게에 Java의 <code>java.net.URL</code>을 사용하는 도메인 클래스 <code>Book</code>이 있고 요청은 다음과 같다고 할 때:<p class="paragraph"/><div class="code"><pre>/book/save?publisherURL=a&#45;bad&#45;url</pre></div><p class="paragraph"/>문자열 <code>a-bad-url</code>이 <code>publisherURL</code> 프로퍼티에 바인드되지 않고 타입 미스매치 에러가 발생한다. 에러를 다음의 예제처럼 처리할 수 있다:<p class="paragraph"/><div class="code"><pre>def b = <span class="java&#45;keyword">new</span> Book(params)<p class="paragraph"/><span class="java&#45;keyword">if</span>(b.hasErrors()) &#123;
   println <span class="java&#45;quote">"The value $&#123;b.errors.getFieldError('publisherURL').rejectedValue&#125; is not a valid URL!"</span>
&#125;</pre></div><p class="paragraph"/>여기서 모든 에러 코드를 다루진 않는다(자세한 정보는 유효성 검사(validation)을 봐라). 또, <code>grails-app/i18n/messages.properties</code> 파일을 사용하여 타입 변환 에러 메시지를 보여줄 수 있다. 다음과 같이 일반 에러 메시지 핸들러를 사용할 수 있다:<p class="paragraph"/><div class="code"><pre>typeMismatch.java.net.URL=The field &#123;0&#125; is not a valid URL</pre></div><p class="paragraph"/>좀 더 구체적인 핸들러도 만들 수 있다:<p class="paragraph"/><div class="code"><pre>typeMismatch.Book.publisherURL=The publisher URL you specified is not a valid URL</pre></div><p class="paragraph"/><h4>Data Binding and Security concerns(데이터 바인딩과 보안)</h4><p class="paragraph"/>요청 파라미터를 이용하여 프로퍼티을 업데이트할 때 도메인 클래스에 악성 데이터(malicious data)를 집어넣으려는 사용자를 조심해야 한다. 이 것은 데이터베이스에 저장하기 전에 처리돼야 한다.<p class="paragraph"/>이 문제를 해결하기 위해 두 가지 방법을 사용할 수 있다. 하나는 <a href="../guide/single.html#6.1.9 Command Objects" class="guide">Command Objects</a>를 사용하는 것이고 다른 하나는 유연한 <a href="../ref/Controllers/bindData.html" class="controllers">bindData</a> 메소드를 사용하는 것이다.<p class="paragraph"/><code>bindData</code> 메소드는 데이터 바인딩 기능과 동일한 일을 하지만 임의의 객체에 사용할 수 있다:<p class="paragraph"/><div class="code"><pre>def sc = <span class="java&#45;keyword">new</span> SaveCommand()
bindData(sc, params)</pre></div><p class="paragraph"/>그리고 <code>bindData</code> 메소드는 업데이트되길 원치 않는 파라미터들을 제외시킬 수 있다:<p class="paragraph"/><div class="code"><pre>def sc = <span class="java&#45;keyword">new</span> SaveCommand()
bindData(sc, params, &#91;'myReadOnlyProp'&#93;)</pre></div><p class="paragraph"/><p class="paragraph"/><h2><a name="6.1.7 XML and JSON Responses">6.1.7 XML and JSON Responses</a></h2><h4>Using the render method to output XML(render 메소드를 이용하여 XML 형식으로 응답하기)</h4><p class="paragraph"/>Grails가 XML과 JSON 형식으로 응답할 수 있도록 제공하는 방법은 여러가지다. 먼저 <a href="../ref/Controllers/render.html" class="controllers">render</a> 메소드를 사용하는 법부터 알아보자:<p class="paragraph"/>XML을 생성하는 코드의 블럭을 <code>render</code> 메소드에 넘길 수 있다:<p class="paragraph"/><div class="code"><pre>def list = &#123;
	def results = Book.list()
	render(contentType:<span class="java&#45;quote">"text/xml"</span>) &#123;
		books &#123;
			<span class="java&#45;keyword">for</span>(b in results) &#123;
				book(title:b.title)
			&#125;
		&#125;	
	&#125;
&#125;</pre></div><p class="paragraph"/>이 코드의 결과는 다음과 같을 것이다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;books&#62;</span>
	  <span class="xml&#45;tag">&#60;book title=<span class="xml&#45;quote">"The Stand"</span> /&#62;</span>
	  <span class="xml&#45;tag">&#60;book title=<span class="xml&#45;quote">"The Shining"</span> /&#62;</span>	
<span class="xml&#45;tag">&#60;/books&#62;</span></pre></div><p class="paragraph"/>마크업을 만들 때 이름이 중복되지 않도록 주의해야 한다. 예를 들어 다음과 같은 코드는 오류가 발생한다:<p class="paragraph"/><div class="code"><pre>def list = &#123;
	def books = Book.list()  // 변수 이름이 중복됐다
		render(contentType:<span class="java&#45;quote">"text/xml"</span>) &#123;
		books &#123;
			<span class="java&#45;keyword">for</span>(b in results) &#123;
				book(title:b.title)
			&#125;
		&#125;	
	&#125;
&#125;</pre></div><p class="paragraph"/>Groovy에서는 지역 변수 <code>books</code>를 메소드처럼 실행하려고 하기 때문이다<p class="paragraph"/><h4>Using the render method to output JSON(render 메소드를 이용하여 JSON형식으로 응답하기)</h4><p class="paragraph"/><code>render</code> 메소드를 사용하여 JSON형식으로도 출력할 수 있다:<p class="paragraph"/><div class="code"><pre>def list = &#123;
	def results = Book.list()
	render(contentType:<span class="java&#45;quote">"text/json"</span>) &#123;
		books &#123;
			<span class="java&#45;keyword">for</span>(b in results) &#123;
				book(title:b.title)
			&#125;
		&#125;	
	&#125;
&#125;</pre></div><p class="paragraph"/>이 결과는 다음과 같다:<p class="paragraph"/><div class="code"><pre>&#91;
	&#123;title:<span class="java&#45;quote">"The Stand"</span>&#125;, 
	&#123;title:<span class="java&#45;quote">"The Shining"</span>&#125;
&#93;</pre></div><p class="paragraph"/>JSON을 만들 때에도 이름이 중복되지 않게 해야 한다.<p class="paragraph"/><h4>Automatic XML Marshalling(자동 XML 마샬링)</h4><p class="paragraph"/>Grails에는 특수한 변환기를 이용해 자동으로 <a href="../guide/single.html#5. Object Relational Mapping (GORM)" class="guide">domain classes</a>를 XML 마샬링하는 기능이 있다.<p class="paragraph"/>컨트롤러에 <code>grails.converters</code> 패키지를 import한다.<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> grails.converters.&#42;</pre></div><p class="paragraph"/>다음과 같이 굉장히 간편한 문법으로 도메인 클래스를 XML로 변환할 수 있다:<p class="paragraph"/><div class="code"><pre>render Book.list() as XML</pre></div><p class="paragraph"/>이 결과는 다음과 같다:<p class="paragraph"/><div class="code"><pre>&#60;?xml version=<span class="java&#45;quote">"1.0"</span> encoding=<span class="java&#45;quote">"ISO&#45;8859&#45;1"</span>?&#62;
&#60;list&#62;
  &#60;book id=<span class="java&#45;quote">"1"</span>&#62;
    &#60;author&#62;Stephen King&#60;/author&#62;
    &#60;title&#62;The Stand&#60;/title&#62;
  &#60;/book&#62;
  &#60;book id=<span class="java&#45;quote">"2"</span>&#62;
    &#60;author&#62;Stephen King&#60;/author&#62;
    &#60;title&#62;The Shining&#60;/title&#62;
  &#60;/book&#62;
&#60;/list&#62;</pre></div><p class="paragraph"/>Grails의 코덱(<a href="../guide/single.html#11.2 Encoding and Decoding Strings" class="guide">codecs</a>) 기능을 사용하도록 변환기를 사용할 수도 있다. 이 코덱 기능으로 <a href="../guide/single.html#11.2 Encoding and Decoding Strings" class="guide">encodeAsXML</a>과 <a href="../guide/single.html#11.2 Encoding and Decoding Strings" class="guide">encodeAsJSON</a> 메소드를 제공한다:<p class="paragraph"/><div class="code"><pre>def xml = Book.list().encodeAsXML()
render xml</pre></div><p class="paragraph"/>XML 마샬링에 대한 내용은 <a href="../guide/single.html#13.1 REST" class="guide">REST</a>를 설명하는 절에서도 볼 수 있다.<p class="paragraph"/><h4>Automatic JSON Marshalling(자동 JSON 마샬링)</h4><p class="paragraph"/>Grails는 자동으로 JSON을 마샬링해주는 방법도 제공한다. XML 마샬링의 방법과 동일하다. 단지 <code>XML</code>을 <code>JSON</code>으로 바꾸기만 하면 된다.<p class="paragraph"/><div class="code"><pre>render Book.list() as JSON</pre></div><p class="paragraph"/>이 결과는 다음과 같다:<p class="paragraph"/><div class="code"><pre>&#91;
	&#123;<span class="java&#45;quote">"id"</span>:1,
	 <span class="java&#45;quote">"class"</span>:<span class="java&#45;quote">"Book"</span>,
	 <span class="java&#45;quote">"author"</span>:<span class="java&#45;quote">"Stephen King"</span>,
	 <span class="java&#45;quote">"title"</span>:<span class="java&#45;quote">"The Stand"</span>&#125;,
	&#123;<span class="java&#45;quote">"id"</span>:2,
	 <span class="java&#45;quote">"class"</span>:<span class="java&#45;quote">"Book"</span>,
	 <span class="java&#45;quote">"author"</span>:<span class="java&#45;quote">"Stephen King"</span>,
	 <span class="java&#45;quote">"releaseDate"</span>:<span class="java&#45;keyword">new</span> Date(1194127343161),
	 <span class="java&#45;quote">"title"</span>:<span class="java&#45;quote">"The Shining"</span>&#125;
 &#93;</pre></div><p class="paragraph"/>XML 마샬링처럼 <code>encodeAsJSON</code> 메소드를 사용할 수도 있다.
<h2><a name="6.1.8 Uploading Files">6.1.8 Uploading Files</a></h2><h4>Programmatic File Uploads(파일 업로드 프로그래밍)</h4><p class="paragraph"/>Grails에서의 파일 업로드는 Spring의 <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/multipart/MultipartHttpServletRequest.html" class="api">MultipartHttpServletRequest</a>를 통해서 지원된다. 파일을 업로드하기 위해서 먼저 다음의 예제같이 멀티파트 폼(multipart form)을 만든다:<p class="paragraph"/><div class="code"><pre>Upload Form: <span class="xml&#45;tag">&#60;br /&#62;</span>
	<span class="xml&#45;tag">&#60;g:form action=<span class="xml&#45;quote">"upload"</span> method=<span class="xml&#45;quote">"post"</span> enctype=<span class="xml&#45;quote">"multipart/form&#45;data"</span>&#62;</span>
		<span class="xml&#45;tag">&#60;input type=<span class="xml&#45;quote">"file"</span> name=<span class="xml&#45;quote">"myFile"</span> /&#62;</span>
		<span class="xml&#45;tag">&#60;input type=<span class="xml&#45;quote">"submit"</span> /&#62;</span>
	<span class="xml&#45;tag">&#60;/g:form&#62;</span></pre></div><p class="paragraph"/>몇 가지 방법으로 파일 업로드를 처리할 수 있다. 먼저 Spring의 <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/multipart/MultipartFile.html" class="api">MultipartFile</a> 인스턴스를 사용하는 방법부터 살펴보자:<p class="paragraph"/><div class="code"><pre>def upload = &#123;
    def f = request.getFile('myFile')
    <span class="java&#45;keyword">if</span>(!f.empty) &#123;
      f.transferTo( <span class="java&#45;keyword">new</span> File('/some/local/dir/myfile.txt') )
      response.sendError(200,'Done');
    &#125;    
    <span class="java&#45;keyword">else</span> &#123;
       flash.message = 'file cannot be empty'
       render(view:'uploadForm')
    &#125;
&#125;</pre></div><p class="paragraph"/><a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/multipart/MultipartFile.html" class="api">MultipartFile</a> 인스턴스를 통해서 InputStream을 획득할 수 있기 때문에 이 방법은 다른 위치에 파일을 저장하고 직접 파일을 조작할 때 유용하다. .<p class="paragraph"/><h4>File Uploads through Data Binding(데이터 바인딩으로 파일 업로드 처리하기)</h4><p class="paragraph"/>파일 업로드는 데이터 바인딩으로도 처리할 수 있다. 다음 예제는 <code>Image</code> 도메인 클래스이다:<p class="paragraph"/><div class="code"><pre>class Image &#123;
   <span class="java&#45;object">byte</span>&#91;&#93; myFile
&#125;</pre></div><p class="paragraph"/>다음의 예제처럼 image 객체를 만들고 params 객체를 파라미터로 넘긴다면 Grails는 자동으로 file을 바이트(byte) 타입의 myFile 프로퍼티에 바인딩 시킬 것이다:<p class="paragraph"/><div class="code"><pre>def img = <span class="java&#45;keyword">new</span> Image(params)</pre></div><p class="paragraph"/>Image 클래스의 myFile 프로퍼티의 형식을 String 형식으로 바꾸어 파일의 내용을 String 형식으로 만드는 것도 가능하다:<p class="paragraph"/><div class="code"><pre>class Image &#123;
   <span class="java&#45;object">String</span> myFile
&#125;</pre></div><p class="paragraph"/><h2><a name="6.1.9 Command Objects">6.1.9 Command Objects</a></h2>Grails 컨트롤러는 Command 객체 개념을 지원한다. Command 객체는 Struts같은 것에서 form 빈을 사용하는 것과 유사하다. 이 것은 업데이트해야 하는 도메인 클래스의 프로퍼티들을 부분적으로 할당할(populate) 때 유용하다. 이 인터랙션에 요구되는 도메인 클래스는 없지만 <a href="../guide/single.html#6.1.6 Data Binding" class="guide">data binding</a>과 유효성 검사(<a href="../guide/single.html#7. Validation" class="guide">validation</a>) 같은 기능들이 필요하다.<p class="paragraph"/><h4>Declaring Command Objects(Command 객체 정의하기)</h4><p class="paragraph"/>일반적으로 컨트롤러가 정의된 소스파일의 컨트롤러 아래에 Command 객체들을 정의한다:<p class="paragraph"/><div class="code"><pre>class UserController &#123;
	&#8230;
&#125;
class LoginCommand &#123;
   <span class="java&#45;object">String</span> username
   <span class="java&#45;object">String</span> password
   <span class="java&#45;keyword">static</span> constraints = &#123;
           username(blank:<span class="java&#45;keyword">false</span>, minSize:6)
           password(blank:<span class="java&#45;keyword">false</span>, minSize:6)
   &#125;
&#125;</pre></div><p class="paragraph"/>이 예제는 <a href="../guide/single.html#5. Object Relational Mapping (GORM)" class="guide">domain classes</a>에 정의했던 것처럼 Command 객체에도 제약조건(<a href="../guide/single.html#7.1 Declaring Constraints" class="guide">constraints</a>)을 정의할 수 있다는 것을 보여준다.<p class="paragraph"/><h4>Using Command Objects(Command 객체 사용하기)</h4><p class="paragraph"/>Command 객체를 사용하기 위해서 컨트롤러의 액션은 Command 객체의 파라미터들을 원하는 만큼 명시할 수 있다. 파라미터의 형식은 개발자가 지정하기 때문에 Grails는 생성하고 할당(populate)하고 유효성 검사를 해야 할 객체들을 알 수 있다.<p class="paragraph"/>Grails는 컨트롤러의 액션이 실행되기 전에 Command 클래스의 인스턴스를 자동으로 생성하고 요청 파라미터를 일치하는 Command 객체의 프로퍼티에 할당한다. 마지막으로 Command 객체의 유효성도 검사한다. 예를 들어:<p class="paragraph"/><div class="code"><pre>class LoginController &#123;
  def login = &#123; LoginCommand cmd &#45;&#62;
         <span class="java&#45;keyword">if</span>(cmd.hasErrors()) &#123;
                redirect(action:'loginForm')
         &#125;
         <span class="java&#45;keyword">else</span> &#123;
            // <span class="java&#45;keyword">do</span> something <span class="java&#45;keyword">else</span>
        &#125;
  &#125;
&#125;</pre></div><p class="paragraph"/><h4>Command Objects and Dependency Injection(Command 객체와 의존성 주입)</h4><p class="paragraph"/>Command 객체로 의존성 주입도 다룰 수 있다. 이 것은 Grails의 서비스(<a href="../guide/single.html#8. The Service Layer" class="guide">services</a>)와 상호작용해야 하는 유효성 검사 로직을 Command 객체에 구현해야 할 때 유용하다.<p class="paragraph"/><div class="code"><pre>class LoginCommand &#123;
    def loginService<p class="paragraph"/>	<span class="java&#45;object">String</span> username
	<span class="java&#45;object">String</span> password
	<span class="java&#45;keyword">static</span> constraints = &#123;
		username(validator: &#123;
			loginService.canLogin(username, password)
		&#125;)
	&#125;
&#125;</pre></div><p class="paragraph"/>이 예제의 Command 객체는 Spring의 <code>ApplicationContext</code>에서 이름으로 주입된 빈(bean)과 상호작용한다.<p class="paragraph"/><h2><a name="6.2 Groovy Server Pages">6.2 Groovy Server Pages</a></h2>GSP는 Grails의 뷰 기술이다. 이 것은 ASP와 JSP 사용자에게 친숙하도록 설계됐다. 하지만 좀 더 유연하고 직관적으로 설계하였다.<p class="paragraph"/>Grails의 GSP는 <code>grails-app/views</code> 디렉토리에 있다. 관례에 따라서 자동적으로 렌더링되도록 할 수 있고 다음과 같이 <a href="../ref/Controllers/render.html" class="controllers">render</a> 메소드를 사용할 수도 있다.<p class="paragraph"/><div class="code"><pre>render(view:<span class="java&#45;quote">"index"</span>)</pre></div><p class="paragraph"/>GSP는 뷰를 렌더링할 때 일반적으로 마크업(mark-up)과 GSP 태그를 혼합하여 사용한다.<p class="paragraph"/><blockquote class="note">
Groovy 로직을 GSP 안에 넣을 수도 있지만 실제로 사용하지 않는 것이 좋다. 사용방법은 이 문서에서 설명할 것이다. 마크업과 코드를 혼합하는 것은 오류를 범하는 것이다. 대부분의 GSP 페이지에는 code가 한 줄도 없을 것이고 필요하지도 않다.
</blockquote><p class="paragraph"/>GSP는 일반적으로 뷰를 렌더링하는데 사용하는 변수들의 집합인 "model"을 하나 가지고 있다. 이 모델은 컨트롤러에서 GSP 뷰로 전달된다. 예를 들어 다음과 같이 컨트롤러의 액션을 만든다:<p class="paragraph"/><div class="code"><pre>def show = &#123;
	&#91;book: Book.get(params.id)&#93;
&#125;</pre></div><p class="paragraph"/>이 액션은 <code>Book</code> 인스턴스를 찾아서 <code>book</code>으로 참조될 수 있도록 모델을 만든다. 이 키는 GSP 뷰에서 <code>book</code>이라는 이름으로 참조될 수 있다.<p class="paragraph"/><div class="code"><pre>&#60;%=book.title%&#62;</pre></div>
<h2><a name="6.2.1 GSP Basics">6.2.1 GSP Basics</a></h2>이 장에서는 GSP의 기초와 무엇을 이용할 수 있는지에 대해서 살펴본다. 먼저 기본 문법에 대해서 살펴보자. JSP나 ASP 사용자라면 매우 친숙할 것이다.<p class="paragraph"/>GSP는 Groovy 코드를 넣을 수 있도록 <code>&#60;% %&#62;</code> 블럭을 지원한다(다시 한번 강조하지만 권장하지 않는다):<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;html&#62;</span>
   <span class="xml&#45;tag">&#60;body&#62;</span>
     <span class="xml&#45;tag">&#60;% out &#60;&#60; <span class="xml&#45;quote">"Hello GSP!"</span> %&#62;</span>
   <span class="xml&#45;tag">&#60;/body&#62;</span>
<span class="xml&#45;tag">&#60;/html&#62;</span></pre></div><p class="paragraph"/>또한 값을 출락하기 위해 <code>&#60;%= %&#62;</code> 문법을 사용할 수도 있다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;html&#62;</span>
   <span class="xml&#45;tag">&#60;body&#62;</span>
     <span class="xml&#45;tag">&#60;%=<span class="xml&#45;quote">"Hello GSP!"</span> %&#62;</span>
   <span class="xml&#45;tag">&#60;/body&#62;</span>
<span class="xml&#45;tag">&#60;/html&#62;</span></pre></div><p class="paragraph"/>GSP는 JSP 스타일의 주석도 지원한다. 다음 예제를 보자:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;html&#62;</span>
   <span class="xml&#45;tag">&#60;body&#62;</span>
	 <span class="xml&#45;tag">&#60;%&#45;&#45; This is my comment &#45;&#45;%&#62;</span>
     <span class="xml&#45;tag">&#60;%=<span class="xml&#45;quote">"Hello GSP!"</span> %&#62;</span>
   <span class="xml&#45;tag">&#60;/body&#62;</span>
<span class="xml&#45;tag">&#60;/html&#62;</span></pre></div>
<h2><a name="6.2.1.1 Variables and Scopes">6.2.1.1 Variables and Scopes</a></h2>당연히 <code>&#60;% %&#62;</code> 블럭에 변수를 정의 할 수 있다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;% now = new Date() %&#62;</span></pre></div><p class="paragraph"/>그리고 정의한 부분 이후부터 이 변수를 재사용할 수 있다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;%=now%&#62;</span></pre></div><p class="paragraph"/>그러나 GSP에서 사용할 수 있도록 미리 정의된 변수들이 많이 있다:
<ul class="star">
<li><code>application</code> - <a href="http://java.sun.com/j2ee/1.4/docs/api/javax/servlet/ServletContext.html" class="api">javax.servlet.ServletContext</a> 인스턴스</li>
<li><code>applicationContext</code> - Spring의 <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/context/ApplicationContext.html" class="api">ApplicationContext</a> 인스턴스</li>
<li><code>flash</code> - <a href="../ref/Controllers/flash.html" class="controllers">flash</a> 객체</li>
<li><code>grailsApplication</code> - <a href="../api/org/codehaus/groovy/grails/commons/GrailsApplication.html" class="api">GrailsApplication</a> 인스턴스</li>
<li><code>out</code> - 출력 스트림에 쓸 수 있는 응답 writer</li>
<li><code>params</code> - 요청 파라미터들을 얻을 수 있는 <a href="../ref/Controllers/params.html" class="controllers">params</a> 객체</li>
<li><code>request</code> - <a href="http://java.sun.com/j2ee/1.4/docs/api/javax/servlet/http/HttpServletRequest.html" class="api">HttpServletRequest</a> 인스턴스</li>
<li><code>response</code> - <a href="http://java.sun.com/j2ee/1.4/docs/api/javax/servlet/http/HttpServletResponse.html" class="api">HttpServletResponse</a> 인스턴스</li>
<li><code>session</code> - <a href="http://java.sun.com/j2ee/1.4/docs/api/javax/servlet/http/HttpSession.html" class="api">HttpSession</a> 인스턴스</li>
<li><code>webRequest</code> - <a href="../api/org/codehaus/groovy/grails/web/servlet/mvc/GrailsWebRequest.html" class="api">GrailsWebRequest</a> 인스턴스</li>
</ul><p class="paragraph"/><h2><a name="6.2.1.2 Logic and Iteration">6.2.1.2 Logic and Iteration</a></h2>물론 다음과 같이 &#60;% %&#62; 문법을 이용하여 loop을 구현할수도 있다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;html&#62;</span>
   <span class="xml&#45;tag">&#60;body&#62;</span>
      <span class="xml&#45;tag">&#60;% &#91;1,2,3,4&#93;.each &#123; num &#45;&#62;</span> %&#62;
         <span class="xml&#45;tag">&#60;p&#62;</span><span class="xml&#45;tag">&#60;%=<span class="xml&#45;quote">"Hello $&#123;num&#125;!"</span> %&#62;</span><span class="xml&#45;tag">&#60;/p&#62;</span>
      <span class="xml&#45;tag">&#60;%&#125;%&#62;</span>
   <span class="xml&#45;tag">&#60;/body&#62;</span>
<span class="xml&#45;tag">&#60;/html&#62;</span></pre></div><p class="paragraph"/>또한 조건분기문도 사용할 수 있다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;html&#62;</span>
   <span class="xml&#45;tag">&#60;body&#62;</span>
      <span class="xml&#45;tag">&#60;% if(params.hello == 'true' )%&#62;</span>	
      <span class="xml&#45;tag">&#60;%=<span class="xml&#45;quote">"Hello!"</span>%&#62;</span>
      <span class="xml&#45;tag">&#60;% else %&#62;</span>
      <span class="xml&#45;tag">&#60;%=<span class="xml&#45;quote">"Goodbye!"</span>%&#62;</span>
   <span class="xml&#45;tag">&#60;/body&#62;</span>
<span class="xml&#45;tag">&#60;/html&#62;</span></pre></div><h2><a name="6.2.1.3 Page Directives">6.2.1.3 Page Directives</a></h2>GSP는 JSP 스타일의 페이지 지시자를 지원한다.<p class="paragraph"/>import 지시자는 페이지에 클래스를 import할 수 있게 해준다. 하지만 Groovy가 기본적으로 import해주는 것들과 <a href="../guide/single.html#6.2.2 GSP Tags" class="guide">GSP Tags</a>가 있기 때문에 거의 필요 없다.<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;%@ page import=<span class="xml&#45;quote">"java.awt.&#42;"</span> %&#62;</span></pre></div><p class="paragraph"/>GSP는 contentType 지시자도 지원한다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;%@ page contentType=<span class="xml&#45;quote">"text/json"</span> %&#62;</span></pre></div><p class="paragraph"/>contentType 지시자는 GSP를 사용하여 다른 형식으로 렌더링할 수 있도록 해준다.
<h2><a name="6.2.1.4 Expressions">6.2.1.4 Expressions</a></h2>GSP에 <code>&#60;%= %&#62;</code> 문법이 초기에 도입됐지만 GSP 표현식이 있기 때문에 거의 사용되지 않는다. ASP와 JSP 개발자들은 이 것이 편안하게 느낄 것이다. GSP 표현식은 JSP의 EL 표현식, Groovy의 GString과 유사할 뿐만 아니라 <code>${표현식}</code>의 행태로 사용한다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;html&#62;</span>
  <span class="xml&#45;tag">&#60;body&#62;</span>
    Hello $&#123;params.name&#125;
  <span class="xml&#45;tag">&#60;/body&#62;</span>
<span class="xml&#45;tag">&#60;/html&#62;</span></pre></div><p class="paragraph"/>그러나 JSP EL과 다르게 <code>${..}</code> 블럭 안에 모든 Groovy 표현식을 사용할 수 있다. 기본적으로 <code>${..}</code> 블럭에 있는 변수의 값에 아무일도 <strong class="bold">하지 않는다</strong>. 그래서 스트링 변수에 있는 모든 HTML은 페이지로 바로 출력된다. XSS(Cross-Site-Scripting) 공격의 위험을 줄이기 위해서 자동으로 HTML을 제거하도록 설정할 수 있다. <code>grails-app/conf/Config.groovy</code>파일의 <code>grails.views.default.codec</code>를 설정하면 된다:<p class="paragraph"/><div class="code"><pre>grails.views.<span class="java&#45;keyword">default</span>.codec='html'</pre></div><p class="paragraph"/>다른 가능한 값들로는 'none'(기본 인코딩이 없음)과 'base64'가 있다.
<h2><a name="6.2.2 GSP Tags">6.2.2 GSP Tags</a></h2>매력적인 JSP의 유산들을 다루었다. 이제부터는 GSP 페이지를 편리하게 만들 수 있는 GSP의 빌트인 태그들을 다룬다.<p class="paragraph"/><blockquote class="note">
태그 라이브러리(<a href="../guide/single.html#6.3 Tag Libraries" class="guide">Tag Libraries</a>)절에서는 테그 라이브러리를 만드는 방법에 대해서 다룬다.
</blockquote><p class="paragraph"/>빌트인 GSP 태그들은 <code>g:</code>로 시작한다. JSP와는 다르게 어떤 태그 라이브러리를 사용할 것인지를 명시해야 한다. 만약 태그가 <code>g:</code>로 시작한다면 GSP 태그로 간주한다. GSP를 사용한 예제를 보자:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:example /&#62;</span></pre></div><p class="paragraph"/>GSP 태그는 다음과 같이 바디를 가질 수 있다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:example&#62;</span>
   Hello world
<span class="xml&#45;tag">&#60;/g:example&#62;</span></pre></div><p class="paragraph"/>GSP 표현식은 GSP 태그 속성에도 사용할 수 있다. 만약 표현식이 아니라 다른 것이 사용된다면 문자열이라고 간주한다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:example attr=<span class="xml&#45;quote">"$&#123;new Date()&#125;"</span>&#62;</span>
   Hello world
<span class="xml&#45;tag">&#60;/g:example&#62;</span></pre></div><p class="paragraph"/>맵도 GSP 태그 속성에 사용될 수 있고 네임드 파라미터 형식으로 자주 사용된다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:example attr=<span class="xml&#45;quote">"$&#123;new Date()&#125;"</span> attr2=<span class="xml&#45;quote">"&#91;one:1, two:2, three:3&#93;"</span>&#62;</span>
   Hello world
<span class="xml&#45;tag">&#60;/g:example&#62;</span></pre></div><p class="paragraph"/>속성의 값들로 문자열을 정의할 때 작은 따옴표를 사용한다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:example attr=<span class="xml&#45;quote">"$&#123;new Date()&#125;"</span> attr2=<span class="xml&#45;quote">"&#91;one:'one', two:'two'&#93;"</span>&#62;</span>
   Hello world
<span class="xml&#45;tag">&#60;/g:example&#62;</span></pre></div><p class="paragraph"/>기본 문법은 이제 끝났다. 다음 절에서는 빌트인 태그들을 살펴볼 것이다.<p class="paragraph"/><h2><a name="6.2.2.1 Variables and Scopes">6.2.2.1 Variables and Scopes</a></h2>GSP에서 <a href="../ref/Tags/set.html" class="tags">set</a> 태그를 이용하여 변수를 정의할 수 있다.<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:set var=<span class="xml&#45;quote">"now"</span> value=<span class="xml&#45;quote">"$&#123;new Date()&#125;"</span> /&#62;</span></pre></div><p class="paragraph"/>간단하게 <code>java.util.Date</code> 인스턴스를 만들어서 GSP표현식을 이용하여 변수에 현재시간을 할당한다. 변수의 값을 <code>&#60;g:set&#62;</code> 태그의 바디에 정의할 수도 있다.<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:set var=<span class="xml&#45;quote">"myHTML"</span>&#62;</span>
   Some re&#45;usable code on: $&#123;new Date()&#125;
<span class="xml&#45;tag">&#60;/g:set&#62;</span></pre></div><p class="paragraph"/>변수의 스콥는 다음과 같다:
<ul class="star">
<li><code>page</code> - 현재 페이지에서만(기본).</li>
<li><code>request</code> - 현재 요청에서만</li>
<li><code>flash</code> - <a href="../ref/Controllers/flash.html" class="controllers">flash</a> 스콥에 저장되므로 다음 요청까지 살아남는다.</li>
<li><code>session</code> - 사용자의 세션에서</li>
<li><code>application</code> - 어플리케이션 어디에서나 살아남는다.</li>
</ul><p class="paragraph"/>변수의 스콥를 결정하기 위해서 <code>scope</code> 속성을 이용한다.<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:set var=<span class="xml&#45;quote">"now"</span> value=<span class="xml&#45;quote">"$&#123;new Date()&#125;"</span> scope=<span class="xml&#45;quote">"request"</span> /&#62;</span></pre></div><h2><a name="6.2.2.2 Logic and Iteration">6.2.2.2 Logic and Iteration</a></h2>GSP는 조건과 반복을 위한 태그도 지원한다. 일반적인 분기 시나리오를 위해 <a href="../ref/Tags/if.html" class="tags">if</a>, <a href="../ref/Tags/else.html" class="tags">else</a>, <a href="../ref/Tags/elseif.html" class="tags">elseif</a> 같은 태그를 다음과 같이 사용할 수 있다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:if test=<span class="xml&#45;quote">"$&#123;session.role == 'admin'&#125;"</span>&#62;</span>
   <span class="xml&#45;tag">&#60;%&#45;&#45; show administrative functions &#45;&#45;%&#62;</span>
<span class="xml&#45;tag">&#60;/g:if&#62;</span>
<span class="xml&#45;tag">&#60;g:else&#62;</span>
   <span class="xml&#45;tag">&#60;%&#45;&#45; show basic functions &#45;&#45;%&#62;</span>
<span class="xml&#45;tag">&#60;/g:else&#62;</span></pre></div><p class="paragraph"/><a href="../ref/Tags/each.html" class="tags">each</a>와 <a href="../ref/Tags/while.html" class="tags">while</a> 태그로 GSP에서 반복 시나리오도 작성할 수 있다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:each in=<span class="xml&#45;quote">"$&#123;&#91;1,2,3&#93;&#125;"</span> var=<span class="xml&#45;quote">"num"</span>&#62;</span>
   <span class="xml&#45;tag">&#60;p&#62;</span>Number $&#123;num&#125;<span class="xml&#45;tag">&#60;/p&#62;</span>
<span class="xml&#45;tag">&#60;/g:each&#62;</span><p class="paragraph"/><span class="xml&#45;tag">&#60;g:set var=<span class="xml&#45;quote">"num"</span> value=<span class="xml&#45;quote">"$&#123;1&#125;"</span> /&#62;</span>
<span class="xml&#45;tag">&#60;g:while test=<span class="xml&#45;quote">"$&#123;num &#60; 5 &#125;"</span>&#62;</span>
    <span class="xml&#45;tag">&#60;p&#62;</span>Number $&#123;num++&#125;<span class="xml&#45;tag">&#60;/p&#62;</span>
<span class="xml&#45;tag">&#60;/g:while&#62;</span></pre></div><h2><a name="6.2.2.3 Search and Filtering">6.2.2.3 Search and Filtering</a></h2>종종 객체의 컬랙션을 정렬하고 필터링이 필요할 때가 있다. GSP는 이 것을 위해 <a href="../ref/Tags/findAll.html" class="tags">findAll</a>과 <a href="../ref/Tags/grep.html" class="tags">grep</a>을 지원한다.<p class="paragraph"/><div class="code"><pre>Stephen King's Books:
<span class="xml&#45;tag">&#60;g:findAll in=<span class="xml&#45;quote">"$&#123;books&#125;"</span> expr=<span class="xml&#45;quote">"it.author == 'Stephen King'"</span>&#62;</span>
     <span class="xml&#45;tag">&#60;p&#62;</span>Title: $&#123;it.title&#125;<span class="xml&#45;tag">&#60;/p&#62;</span>
<span class="xml&#45;tag">&#60;/g:findAll&#62;</span></pre></div><p class="paragraph"/>필터링하기 위해 <code>expr</code> 속성에 Groovy 표현식을 사용한다. <a href="../ref/Tags/grep.html" class="tags">grep</a> 태그를 이용하여 클래스로 필터링할 수도 있다.<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:grep in=<span class="xml&#45;quote">"$&#123;books&#125;"</span> filter=<span class="xml&#45;quote">"NonFictionBooks.class"</span>&#62;</span>
     <span class="xml&#45;tag">&#60;p&#62;</span>Title: $&#123;it.title&#125;<span class="xml&#45;tag">&#60;/p&#62;</span>
<span class="xml&#45;tag">&#60;/g:grep&#62;</span></pre></div><p class="paragraph"/>정규 표현식도 사용할 수 있다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:grep in=<span class="xml&#45;quote">"$&#123;books.title&#125;"</span> filter=<span class="xml&#45;quote">"~/.&#42;?Groovy.&#42;?/"</span>&#62;</span>
     <span class="xml&#45;tag">&#60;p&#62;</span>Title: $&#123;it&#125;<span class="xml&#45;tag">&#60;/p&#62;</span>
<span class="xml&#45;tag">&#60;/g:grep&#62;</span></pre></div><p class="paragraph"/>이 예제에서는 GPath가 사용됐다. GPath는 Groovy가 지원하는 XPath같은 언어이다. 구체적으로 설명하자면 <code>books</code> 컬랙션은 <code>Book</code> 인스턴스들의 컬랙션이다. 그리고 <code>Book</code>이 <code>title</code>을 가지고 있다고 가정하면 <code>books.title</code> 표현식을 사용하여 <code>Book</code>의 <code>title</code>들을 리스트로 얻어올 수 있다. Groovy는 자동으로 Book 인스턴스들의 리스트를 이용하여 title의 리스트를 만들어 반환한다!
<h2><a name="6.2.2.4 Links and Resources">6.2.2.4 Links and Resources</a></h2>GSP는 컨트롤러와 액션을 쉽게 연결 할 수 있는 태그도 지원한다. <a href="../ref/Tags/link.html" class="tags">link</a> 태그에 컨트롤러와 액션 이름을 명시하여 링크를 만들 수 있다. 이 것은 URL 매핑(<a href="../guide/single.html#6.4 URL Mappings" class="guide">URL Mappings</a>)에 의존하여 자동으로 행해진다(매핑을 변경하지 않으면). 다음은 <a href="../ref/Tags/link.html" class="tags">link</a> 태그를 사용한 예제이다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:link action=<span class="xml&#45;quote">"show"</span> id=<span class="xml&#45;quote">"1"</span>&#62;</span>Book 1<span class="xml&#45;tag">&#60;/g:link&#62;</span>
<span class="xml&#45;tag">&#60;g:link action=<span class="xml&#45;quote">"show"</span> id=<span class="xml&#45;quote">"$&#123;currentBook.id&#125;"</span>&#62;</span>$&#123;currentBook.name&#125;<span class="xml&#45;tag">&#60;/g:link&#62;</span>
<span class="xml&#45;tag">&#60;g:link controller=<span class="xml&#45;quote">"book"</span>&#62;</span>Book Home<span class="xml&#45;tag">&#60;/g:link&#62;</span>
<span class="xml&#45;tag">&#60;g:link controller=<span class="xml&#45;quote">"book"</span> action=<span class="xml&#45;quote">"list"</span>&#62;</span>Book List<span class="xml&#45;tag">&#60;/g:link&#62;</span>
<span class="xml&#45;tag">&#60;g:link url=<span class="xml&#45;quote">"&#91;action:'list',controller:'book'&#93;"</span>&#62;</span>Book List<span class="xml&#45;tag">&#60;/g:link&#62;</span>
<span class="xml&#45;tag">&#60;g:link action=<span class="xml&#45;quote">"list"</span> params=<span class="xml&#45;quote">"&#91;sort:'title',order:'asc',author:currentBook.author&#93;"</span>&#62;</span>
     Book List
<span class="xml&#45;tag">&#60;/g:link&#62;</span></pre></div>
<h2><a name="6.2.2.5 Forms and Fields">6.2.2.5 Forms and Fields</a></h2><h4>Form Basics(폼의 기초)</h4><p class="paragraph"/>GSP에는 HTML 폼과 필드를 다루는 많은 태그들이 있다. <code>form</code> 태그가 가장 기초적인 것이다. <a href="../ref/Tags/form.html" class="tags">form</a> 태그는 단지 HTML의 form 태그에 컨트롤러/액션을 이해할 수 있도록 한 것에 불과하다. <code>url</code> 속성에 컨트롤러와 액션을 명시한다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:form name=<span class="xml&#45;quote">"myForm"</span> url=<span class="xml&#45;quote">"&#91;controller:'book',action:'list'&#93;"</span>&#62;</span>...<span class="xml&#45;tag">&#60;/g:form&#62;</span></pre></div><p class="paragraph"/>이 경우에 우리는 <code>BookController</code>의 <code>list</code>액션에 전송하는 <code>myForm</code>이라고 불리는 폼 태그를 만들었다. 나머지는 HTML의 속성와 모두 동일하다.<p class="paragraph"/><h4>Form Fields(폼 필드)</h4><p class="paragraph"/>GSP는 폼 필드와 관련된 다양한 태그를 지원하기 때문에 폼을 쉽게 만들 수 있다.<p class="paragraph"/>textField - 'text' 타입을 위한 입력 필드
checkBox - 'checkbox' 타입을 위한 입력 필드
radio - 'radio' 타입을 위한 입력 필드
hiddenField - 'hidden' 타입을 위한 입력 필드
select - HTML의 select 박스를 위한 태그<p class="paragraph"/>이 태그들의 value 속성에 GSP 표현식을 사용할 수 있다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:textField name=<span class="xml&#45;quote">"myField"</span> value=<span class="xml&#45;quote">"$&#123;myValue&#125;"</span> /&#62;</span></pre></div><p class="paragraph"/>GSP는 <a href="../ref/Tags/radioGroup.html" class="tags">radioGroup</a>, <a href="../ref/Tags/localeSelect.html" class="tags">localeSelect</a>, <a href="../ref/Tags/currencySelect.html" class="tags">currencySelect</a>, <a href="../ref/Tags/timeZoneSelect.html" class="tags">timeZoneSelect</a>처럼 위에 설명한 태그들을 확장한 태그들도 지원한다. radioGroup은 <a href="../ref/Tags/radio.html" class="tags">radio</a> 태그를 그룹으로 묶기 위함이고 localeSelect는 로케일을, currencySelect는 화페 단위를, timezoneSelect는 timezone을 선택을 단순화 해준다.<p class="paragraph"/><h4>Multiple Submit Buttons(여러 개의 Submit 버튼)</h4><p class="paragraph"/>Grails는 여러 개의 Submit 버튼을 다루어야하는 역사 깊은 문제도 우아하게 처리할 수 있도록 <a href="../ref/Tags/actionSubmit.html" class="tags">actionSubmit</a> 태그를 지원한다. 이 것은 일반 submit과 동일하지만 action을 명시할 수 있다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:actionSubmit value=<span class="xml&#45;quote">"Some update label"</span> action=<span class="xml&#45;quote">"update"</span> /&#62;</span></pre></div><p class="paragraph"/><h2><a name="6.2.2.6 Tags as Method Calls">6.2.2.6 Tags as Method Calls</a></h2>이 것이 GSP 태그와 다른 태그 기술들과의 중요한 차이점이다. GSP 태그는 <a href="../guide/single.html#6.1 Controllers" class="guide">controllers</a>, <a href="../guide/single.html#6.3 Tag Libraries" class="guide">tag libraries</a>, GSP 뷰에서 일반 태그처럼 사용할 수도 있고 메소드를 호출하듯이 사용할 수도 있다.<p class="paragraph"/><h4>Tags as method calls from GSPs(GSP에서 태그 호출하기)</h4><p class="paragraph"/>태그를 호출하면 그 결과는 바로 응답에 쓰여지는 것이 아니라 문자열로 반환된다. 예를 들어 <a href="../ref/Tags/createLinkTo.html" class="tags">createLinkTo</a> 태그는 메소드처럼 호출 될 수 있다:<p class="paragraph"/><div class="code"><pre>Static Resource: $&#123;createLinkTo(dir:<span class="xml&#45;quote">"images"</span>, file:<span class="xml&#45;quote">"logo.jpg"</span>)&#125;</pre></div><p class="paragraph"/>이 것은 속성에 태그를 사용해야 할때 매우 유용하다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;img src=<span class="xml&#45;quote">"$&#123;createLinkTo(dir:'images', file:'logo.jpg')&#125;"</span> /&#62;</span></pre></div><p class="paragraph"/>이 기능을 지원하지 않는 뷰 기술에서는 태그 안에 GSP 태그를 네스트(nest)시켜야 한다. 이 방법은 코드를 매우 지져분하게 만들고 마크업을 엉터리로(not well-formed) 렌더링하는 Dreamweaver같은 WSYWIG 도구를 사용하기 어렵게 만든다(an adverse effect of WYSWIG tools).<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;img src=<span class="xml&#45;quote">"&#60;g:createLinkTo dir="</span>images<span class="xml&#45;quote">" file="</span>logo.jpg<span class="xml&#45;quote">" /&#62;</span>"</span> /&#62;</pre></div><p class="paragraph"/><h4>Tags as method calls from Controllers and Tag Libraries(컨트롤러와 태그 라이브러리에서 태그 호출 하기)</h4><p class="paragraph"/>컨트롤러와 태그 라이브러리에서도 태그를 호출할 수 있다. <code>g:</code>로 시작하는 태그들은 접두어(<a href="../guide/single.html#6.3.4 Tag Namespaces" class="guide">namespace</a>, 역자주 - <code>g:</code>) 없이 실행 가능할 수 있고 결과는 문자열로 반환된다:<p class="paragraph"/><div class="code"><pre>def imageLocation = createLinkTo(dir:<span class="java&#45;quote">"images"</span>, file:<span class="java&#45;quote">"logo.jpg"</span>)</pre></div><p class="paragraph"/>그리고 이름이 충돌되지 않게 하기 위해 접두어를 사용할 수 있다:<p class="paragraph"/><div class="code"><pre>def imageLocation = g.createLinkTo(dir:<span class="java&#45;quote">"images"</span>, file:<span class="java&#45;quote">"logo.jpg"</span>)</pre></div><p class="paragraph"/>Grails 네임스페이스가 아니라면(<a href="../guide/single.html#6.3.4 Tag Namespaces" class="guide">custom namespace</a>) 접두어를 사용해야 한다(<a href="http://grails.org/FCK+editor+plugin" target="blank">FCK Editor plugin</a> 을 사용하는 예제를 보면):<p class="paragraph"/><div class="code"><pre>def editor = fck.editor()</pre></div><p class="paragraph"/><p class="paragraph"/><h2><a name="6.2.3 Views and Templates">6.2.3 Views and Templates</a></h2>Grails는 뷰뿐만 아니라 템플릿도 지원한다. 템플릿은 뷰를 쉽게 관리할 수 있게 만들기 때문에 유용하고 구조적인 뷰를 위해 훌륭한 재사용 매커니즘을 제공하는 <a href="../guide/single.html#6.2.4 Layouts with Sitemesh" class="guide">Layouts</a>과 함께 사용할 수 있다.<p class="paragraph"/><h4>Template Basics(템플릿의 기초)</h4><p class="paragraph"/>Grails는 템플릿을 식별하기 위해서 뷰의 이름 앞에 '_'를 붙이는 관례를 사용한다. 예를 들어 Book을 렌더링하는 템플릿은 <code>grails-app/views/book/_bookTemplate.gsp</code>에 위치한다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;div class=<span class="xml&#45;quote">"book"</span> id=<span class="xml&#45;quote">"$&#123;book?.id&#125;"</span>&#62;</span>
   <span class="xml&#45;tag">&#60;div&#62;</span>Title: $&#123;book?.title&#125;<span class="xml&#45;tag">&#60;/div&#62;</span>
   <span class="xml&#45;tag">&#60;div&#62;</span>Author: $&#123;book?.author?.name&#125;<span class="xml&#45;tag">&#60;/div&#62;</span>
<span class="xml&#45;tag">&#60;/div&#62;</span></pre></div><p class="paragraph"/><code>grails-app/views/book</code>에 있는 뷰에서 템플릿을 렌더링하려면 <a href="../ref/Tags/render.html" class="tags">render</a> 태그를 사용해야 한다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:render template=<span class="xml&#45;quote">"bookTemplate"</span> model=<span class="xml&#45;quote">"&#91;book:myBook&#93;"</span> /&#62;</span></pre></div><p class="paragraph"/><code>render</code> 태그의 <code>model</code> 속성이 어떻게 사용되고 있는지 기억하라. <code>Book</code> 인스턴스가 많을 때 <code>render</code> 태그와 템플릿을 사용하여 Book 인스턴스들을 렌더링할 수 있다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:render template=<span class="xml&#45;quote">"bookTemplate"</span> var=<span class="xml&#45;quote">"book"</span> collection=<span class="xml&#45;quote">"$&#123;bookList&#125;"</span> /&#62;</span></pre></div><p class="paragraph"/><h4>Shared Templates(템플릿 공유하기)</h4><p class="paragraph"/>위의 예제에서 우리는 템플릿을 BookController와 grails-app/views/book에서만 사용했다. 그러나 템플릿을 어플리케에션 전체에서 공유할 수도 있다.<p class="paragraph"/>이 경우에 뷰들의 루트 디렉토리인 grails-app/views나 그 하위 디렉토리에 템플릿을 위치시킨다. 그리고 template 속성에 템플릿 이름 앞에 '/'과 상대경로를 더해서 명시한다. grails-app/views/shared/_mySharedTemplate.gsp라는 템플릿이 있으면 다음과 같이 사용할 수 있다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:render template=<span class="xml&#45;quote">"/shared/mySharedTemplate"</span> /&#62;</span></pre></div><p class="paragraph"/>뷰와 컨트롤러의 디렉토리에 있는 템플릿도 사용할 수 있다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:render template=<span class="xml&#45;quote">"/book/bookTemplate"</span> model=<span class="xml&#45;quote">"&#91;book:myBook&#93;"</span> /&#62;</span></pre></div><p class="paragraph"/><h4>Templates in Controllers and Tag Libraries(컨트롤러와 테그 라이브러리에서 템플릿 사용하기)</h4><p class="paragraph"/>컨트롤러에서도 <a href="../ref/Controllers/render.html" class="controllers">render</a> 메소드를 사용하여 템플릿을 렌더링할 수 있다. 이 것은 <a href="../guide/single.html#6.7 Ajax" class="guide">Ajax</a> 어플리케이션에 유용하다:<p class="paragraph"/><div class="code"><pre>def show = &#123;
    def b = Book.get(params.id)
	render(template:<span class="java&#45;quote">"bookTemplate"</span>, model:&#91;book:b&#93;)
&#125;</pre></div><p class="paragraph"/>컨트롤러에서 <a href="../ref/Controllers/render.html" class="controllers">render</a> 메소드를 사용하면 응답에 바로 씌여진다. 이 것이 가장 일반적인 용법이지만 템플릿의 결과를 알고 싶다면 다음과 같이 <a href="../ref/Tags/render.html" class="tags">render</a> 태그를 사용할 수 있다:<p class="paragraph"/><div class="code"><pre>def show = &#123;
    def b = Book.get(params.id)
	<span class="java&#45;object">String</span> content = g.render(template:<span class="java&#45;quote">"bookTemplate"</span>, model:&#91;book:b&#93;)
	render content
&#125;</pre></div><p class="paragraph"/><code>g.</code> 네임스페이스를 사용하면 Grails는 <a href="../ref/Controllers/render.html" class="controllers">render</a> 메소드가 아니라 <a href="../guide/single.html#6.2.2.6 Tags as Method Calls" class="guide">render 태그</a>를 사용하는 것이라고 해석한다.
<h2><a name="6.2.4 Layouts with Sitemesh">6.2.4 Layouts with Sitemesh</a></h2><h4>Creating Layouts(레이아웃 만들기)</h4><p class="paragraph"/>Grails는 데코레이터 엔진인 <a href="http://www.opensymphony.com/sitemesh/" target="blank">Sitemesh</a>에 기반한 레이아웃을 지원한다. 레이아웃은 <code>grails-app/views/layouts</code> 디렉토리에 위치한다. 일반적인 레이아웃은 다음과 같다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;html&#62;</span>
      <span class="xml&#45;tag">&#60;head&#62;</span>
          <span class="xml&#45;tag">&#60;title&#62;</span><span class="xml&#45;tag">&#60;g:layoutTitle default=<span class="xml&#45;quote">"An example decorator"</span> /&#62;</span><span class="xml&#45;tag">&#60;/title&#62;</span>
          <span class="xml&#45;tag">&#60;g:layoutHead /&#62;</span>
      <span class="xml&#45;tag">&#60;/head&#62;</span>
      <span class="xml&#45;tag">&#60;body onload=<span class="xml&#45;quote">"$&#123;pageProperty(name:'body.onload')&#125;"</span>&#62;</span>
            <span class="xml&#45;tag">&#60;div class=<span class="xml&#45;quote">"menu"</span>&#62;</span><span class="xml&#45;comment">&#60;!&#45;&#45;my common menu goes here&#45;&#45;&#62;</span><span class="xml&#45;tag">&#60;/menu&#62;</span>
                 <span class="xml&#45;tag">&#60;div class=<span class="xml&#45;quote">"body"</span>&#62;</span>
                      <span class="xml&#45;tag">&#60;g:layoutBody /&#62;</span>
                 <span class="xml&#45;tag">&#60;/div&#62;</span>
            <span class="xml&#45;tag">&#60;/div&#62;</span>
      <span class="xml&#45;tag">&#60;/body&#62;</span>
<span class="xml&#45;tag">&#60;/html&#62;</span></pre></div><p class="paragraph"/>핵심은 <a href="../ref/Tags/layoutHead.html" class="tags">layoutHead</a>, <a href="../ref/Tags/layoutTitle.html" class="tags">layoutTitle</a>, <a href="../ref/Tags/layoutBody.html" class="tags">layoutBody</a> 태그를 사용한 것이다. 각각의 태그의 의미는 다음과 같다:
<ul class="star">
<li><code>layoutTitle</code> - 대상 페이지의 제목을 출력</li>
<li><code>layoutHead</code> - 대상 페이지의 head 태그의 내용을 출력</li>
<li><code>layoutBody</code> - 대상 페이지의 body 태그의 내용을 출력</li>
</ul><p class="paragraph"/>위의 예제의 <a href="../ref/Tags/pageProperty.html" class="tags">pageProperty</a> 태그는 대상 페이지의 모습(aspect)를 검사하고(inspect) 반환하기 위해 사용했다.<p class="paragraph"/><h4>Triggering Layouts(레이아웃 사용하기)</h4><p class="paragraph"/>레이아웃을 사용하는 방법은 여러가지이다. 가장 단순한 방법은 meta 태그를 뷰에 삽입하는 것이다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;html&#62;</span>
    <span class="xml&#45;tag">&#60;head&#62;</span>
	    <span class="xml&#45;tag">&#60;title&#62;</span>An Example Page<span class="xml&#45;tag">&#60;/title&#62;</span>
        <span class="xml&#45;tag">&#60;meta name=<span class="xml&#45;quote">"layout"</span> content=<span class="xml&#45;quote">"main"</span>&#62;</span><span class="xml&#45;tag">&#60;/meta&#62;</span>
    <span class="xml&#45;tag">&#60;/head&#62;</span>
    <span class="xml&#45;tag">&#60;body&#62;</span>This is my content!<span class="xml&#45;tag">&#60;/body&#62;</span>
<span class="xml&#45;tag">&#60;/html&#62;</span></pre></div><p class="paragraph"/>이 경우에는 grails-app/views/layouts/main.gsp라는 레이아웃이 사용된다. 위에서 설명한 레이아웃에 적용한다면 다음과 같은 결과를 얻게될 것이다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;html&#62;</span>
      <span class="xml&#45;tag">&#60;head&#62;</span>
          <span class="xml&#45;tag">&#60;title&#62;</span>An Example Page<span class="xml&#45;tag">&#60;/title&#62;</span>
      <span class="xml&#45;tag">&#60;/head&#62;</span>
      <span class="xml&#45;tag">&#60;body onload=<span class="xml&#45;quote">""</span>&#62;</span>
        <span class="xml&#45;tag">&#60;div class=<span class="xml&#45;quote">"menu"</span>&#62;</span><span class="xml&#45;comment">&#60;!&#45;&#45;my common menu goes here&#45;&#45;&#62;</span><span class="xml&#45;tag">&#60;/div&#62;</span>
                 <span class="xml&#45;tag">&#60;div class=<span class="xml&#45;quote">"body"</span>&#62;</span>
					This is my content!
                 <span class="xml&#45;tag">&#60;/div&#62;</span>
      <span class="xml&#45;tag">&#60;/body&#62;</span>
<span class="xml&#45;tag">&#60;/html&#62;</span></pre></div><p class="paragraph"/><h4>Layout by Convention(관례에 따르는 레이아웃)</h4><p class="paragraph"/>레이아웃을 사용하는 두번째 방법은 관례를 따르는 것이다. 예를 들어 다음과 같은 컨트롤러를 가지고 있다면:<p class="paragraph"/><div class="code"><pre>class BookController &#123;
    def list = &#123;  &#8230; &#125;
&#125;</pre></div><p class="paragraph"/>grails-app/views/layouts/book.gsp이라는 레이아웃을 만들면 관례에 따라 BookController와 관련된 모든 뷰에 적용될 것이다.<p class="paragraph"/>BookController의 list 액션에만 적용되는 레이아웃은 grails-app/views/layouts/book/list.gsp에 만들면 된다.<p class="paragraph"/>list 액션이 실행될 때 여기에서 언급한 레이아웃이 모두 존재한다면 액션의 레이아웃이 적용될 것이다.<p class="paragraph"/><h4>Inline Layouts(인라인 레이아웃)</h4><p class="paragraph"/>Grails는 applyLayout 태그를 통해 Sitemesh의 인라인 레이아웃의 개념도 지원한다. <a href="../ref/Tags/applyLayout.html" class="tags">applyLayout</a> 태그는 템플릿, URL, 내용중 일부에만 레이아웃을 적용하는데 사용한다. 근본적으로 이 것은 템플릿과 함께 뷰 구조를 모듈화할 수 있게 해준다.<p class="paragraph"/>다음은 이 것을 보여주는 몇 가지 예제들이다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:applyLayout name=<span class="xml&#45;quote">"myLayout"</span> template=<span class="xml&#45;quote">"bookTemplate"</span> collection=<span class="xml&#45;quote">"$&#123;books&#125;"</span> /&#62;</span><p class="paragraph"/><span class="xml&#45;tag">&#60;g:applyLayout name=<span class="xml&#45;quote">"myLayout"</span> url=<span class="xml&#45;quote">"http://www.google.com"</span> /&#62;</span><p class="paragraph"/><span class="xml&#45;tag">&#60;g:applyLayout name=<span class="xml&#45;quote">"myLayout"</span>&#62;</span>
The content to apply a layout to
<span class="xml&#45;tag">&#60;/g:applyLayout&#62;</span></pre></div><p class="paragraph"/><h2><a name="6.3 Tag Libraries">6.3 Tag Libraries</a></h2><a href="":http://java.sun.com/products/jsp/">JSP</a> 처럼 GSP는 사용자 정의 태그 라이브러리를 지원한다. 하지만 JSP랑은 다르게 Grails의 태그 라이브러리는 훨씬 간단하고 우아할 뿐만 아니라 런타임에 완벽하게 리로드될 수 있다.<p class="paragraph"/><code>Taglib</code>으로 끝나는 Groovy 클래스를 만들고 <code>grails-app/taglib</code> 디렉토리에 넣는 것만으로 간단하게 태그 라이브러리를 만들 수 있다:<p class="paragraph"/><div class="code"><pre>class SimpleTagLib &#123;<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/>태그 속성와 바디 내용의 두 인자를 취하는 코드 블럭을 할당하는 것만으로 간단하게 속성을 만들 수 있다:<p class="paragraph"/><div class="code"><pre>class SimpleTagLib &#123;
	def simple = &#123; attrs, body &#45;&#62;<p class="paragraph"/>    &#125;
&#125;</pre></div><p class="paragraph"/><code>attrs</code> 인자는 단순히 태그 속성들이 있는 맵이다. 하지만 <code>body</code> 인자는 바디 내용을 반환하는 실행가능한 코드 블럭이다:<p class="paragraph"/><div class="code"><pre>class SimpleTagLib &#123;
	def emoticon = &#123; attrs, body &#45;&#62;
	   out &#60;&#60; body() &#60;&#60; attrs.happy == '<span class="java&#45;keyword">true</span>' ? <span class="java&#45;quote">" :&#45;)"</span> : <span class="java&#45;quote">" :&#45;("</span>	
    &#125;
&#125;</pre></div><p class="paragraph"/>이 예제에서 <code>out</code> 변수는 output Writer에 대한 참조다. 이를 이용하여 응답에 내용을 추가할 수 있다. imports문 없이도 간단하게 GSP에서 이 태그를 사용할 수 있다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:emoticon happy=<span class="xml&#45;quote">"true"</span>&#62;</span>Hi John<span class="xml&#45;tag">&#60;/g:emoticon&#62;</span></pre></div><h2><a name="6.3.1 Simple Tags">6.3.1 Simple Tags</a></h2>이전 예제에서 설명한 것처럼 바디도 없고 단순히 내용을 출력하는 태그를 작성하는 일은 아무일도 아니다. 여기에 <code>dateFormat</code> 형식의 태그에 대한 예제도 살펴보자:<p class="paragraph"/><div class="code"><pre>def dateFormat = &#123; attrs, body &#45;&#62;
	out &#60;&#60; <span class="java&#45;keyword">new</span> java.text.SimpleDateFormat(attrs.format).format(attrs.date)
&#125;</pre></div><p class="paragraph"/>날자형식을 위해서 Java의 <code>SimpleDateFormat</code> 클래스를 사용했고 그 것을 응답에 출력했다. GSP에서 다음과 같이 이 태그를 사용할 수 있다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:dateFormat format=<span class="xml&#45;quote">"dd&#45;MM&#45;yyyy"</span> date=<span class="xml&#45;quote">"$&#123;new Date()&#125;"</span> /&#62;</span></pre></div><p class="paragraph"/>HTML 마크업을 응답에 출력해야 하는 태그를 작성해야 할 수도 있다. 출력할 내용을 바로 삽입하는 방법이 있다:<p class="paragraph"/><div class="code"><pre>def formatBook = &#123; attrs, body &#45;&#62;
    out &#60;&#60; <span class="java&#45;quote">"&#60;div id=&#34;$&#123;attrs.book.id&#125;&#34;&#62;"</span>	
    out &#60;&#60; <span class="java&#45;quote">"Title : $&#123;attrs.book.title&#125;"</span>	
	out &#60;&#60; <span class="java&#45;quote">"&#60;/div&#62;"</span>
&#125;</pre></div><p class="paragraph"/>이 방법은 실제로 사용하기엔 너무 지저분하다. <a href="../ref/Tags/render.html" class="tags">render</a> 태그를 사용하여 더 낫게 할 수 있다:<p class="paragraph"/><div class="code"><pre>def formatBook = &#123; attrs, body &#45;&#62;
    out &#60;&#60; render(template:<span class="java&#45;quote">"bookTemplate"</span>, model:&#91;book:attrs.book&#93;)	
&#125;</pre></div><p class="paragraph"/>이제 실제로 렌더링되는 GSP 템플릿을 만들었다.<p class="paragraph"/><h2><a name="6.3.2 Logical Tags">6.3.2 Logical Tags</a></h2>특정 조건이 만족돼야만 결과를 출력하는 논리 태그를 만들 수도 있다. 다음의 예제는 보안 태그를 만들어 본 것이다:<p class="paragraph"/><div class="code"><pre>def isAdmin = &#123; attrs, body &#45;&#62;
     def user = attrs&#91;'user'&#93;
     <span class="java&#45;keyword">if</span>(user != <span class="java&#45;keyword">null</span> &#38;&#38; checkUserPrivs(user)) &#123;
           out &#60;&#60; body()
     &#125;
&#125;</pre></div><p class="paragraph"/>이 태그는 사용자가 관리자인지를 검사하고 오직 접근권한이 있을 때만 body의 내용을 출력한다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:isAdmin user=<span class="xml&#45;quote">"$&#123;myUser&#125;"</span>&#62;</span>
    // some restricted content
<span class="xml&#45;tag">&#60;/g:isAdmin&#62;</span></pre></div><p class="paragraph"/>
<h2><a name="6.3.3 Iterative Tags">6.3.3 Iterative Tags</a></h2>반복 태그도 역시 간단한다. 다음과 같이 body를 여러번 실행하게 할 수 있다.<p class="paragraph"/><div class="code"><pre>def repeat = &#123; attrs, body &#45;&#62;
    attrs.times?.toInteger().times &#123; num &#45;&#62;
        out &#60;&#60; body(num)
    &#125;
&#125;</pre></div><p class="paragraph"/>이 예제에서는 <code>times</code> 속성을 검사하고 만약 숫자로 변환되면 Groovy의 <code>times</code> 메소드를 사용하여 명시된 횟수만큼 반복한다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:repeat times=<span class="xml&#45;quote">"3"</span>&#62;</span>
<span class="xml&#45;tag">&#60;p&#62;</span>Repeat this 3 times! Current repeat = $&#123;it&#125;<span class="xml&#45;tag">&#60;/p&#62;</span>
<span class="xml&#45;tag">&#60;/g:repeat&#62;</span></pre></div><p class="paragraph"/>이 예제의 <code>it</code> 변수가 어떻게 현재 반복 횟수를 의미되었는지를 기억하라. 이 것은 반복 코드에 현재 반복 횟수를 인자로 넘겨줬기 때문에 가능한 일이다:<p class="paragraph"/><div class="code"><pre>out &#60;&#60; body(num)</pre></div><p class="paragraph"/>이 값은 태그에서 사용할 수 있는 변수 <code>it</code>으로 넘겨진다. 만약 중첩하여 태그를 사용하면 충돌을 일으킬 수 있다. 따라서 바디에서 사용할 변수이름을 지정해야 한다:<p class="paragraph"/><div class="code"><pre>def repeat = &#123; attrs, body &#45;&#62;
	def <span class="java&#45;keyword">var</span> = attrs.<span class="java&#45;keyword">var</span> ? attrs.<span class="java&#45;keyword">var</span> : <span class="java&#45;quote">"num"</span>
    attrs.times?.toInteger().times &#123; num &#45;&#62;
        out &#60;&#60; body((<span class="java&#45;keyword">var</span>):num)
    &#125;
&#125;</pre></div><p class="paragraph"/><code>var</code> 속성이 있는지 검사하고 만약 속성이 존재하면 바디를 호출하는 줄에서 파라미터로 사용한다:<p class="paragraph"/><div class="code"><pre>out &#60;&#60; body((<span class="java&#45;keyword">var</span>):num)</pre></div><p class="paragraph"/><blockquote class="note">
변수 이름에 괄호를 사용한 것을 기억하라. 괄호를 생략하면 Groovy는 var 변수를 사용하는 것이 아니라 문자열 키를 사용한다고 간주한다.
</blockquote><p class="paragraph"/>이제 다음과 같이 태그를 사용할 수 있다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:repeat times=<span class="xml&#45;quote">"3"</span> var=<span class="xml&#45;quote">"j"</span>&#62;</span>
<span class="xml&#45;tag">&#60;p&#62;</span>Repeat this 3 times! Current repeat = $&#123;j&#125;<span class="xml&#45;tag">&#60;/p&#62;</span>
<span class="xml&#45;tag">&#60;/g:repeat&#62;</span></pre></div><p class="paragraph"/>변수 <code>j</code>를 정의하기 위해서 <code>var</code> 속성을 어떻게 사용했는지를 기억하라. 이제 태그의 바디에서 이 변수를 참조할 수 있다.
<h2><a name="6.3.4 Tag Namespaces">6.3.4 Tag Namespaces</a></h2>태그는 자동으로 Grails의 기본 네임스페이스에 추가되고 GSP 페이지에서 'g:' 접두어로 태그를 사용할 수 있다. 그러나 TagLib 클래스에 static namespace 프로퍼티에 사용해서 다른 네임스페이스를 명시할 수 있다:<p class="paragraph"/><div class="code"><pre>class SimpleTagLib &#123;
    <span class="java&#45;keyword">static</span> namespace = <span class="java&#45;quote">"my"</span><p class="paragraph"/>    def example = &#123; attrs &#45;&#62;
        &#8230;
    &#125;
&#125;</pre></div><p class="paragraph"/>이 예제에서 “my” 네임스페이스를 명시했다. 이 태그 라이브러리의 태그는 GSP 페이지에서 다음과 같이 사용해야 한다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;my:example name=<span class="xml&#45;quote">"..."</span> /&#62;</span></pre></div><p class="paragraph"/>이 접두어는 static namespace 프로퍼티에 명시한 값이다. 네임스페이스는 플러그인에 특히 유용하다.<p class="paragraph"/>네임스페이스를 접두어로 사용해서 네임스페이스의 태그를 매소드처럼 호출할 수 있다:
<div class="code"><pre>out &#60;&#60; my.example(name:<span class="java&#45;quote">"foo"</span>)</pre></div><p class="paragraph"/>이 것은 GSP, 컨트롤러, 태그 라이브러리에서 잘 동작한다.
<h2><a name="6.4 URL Mappings">6.4 URL Mappings</a></h2>지금까지 이 문서에서는 URL을 /controller/action/id라는 관례에 따라서만 사용했다. 그러나 이 관례는 Grails에서 고정된 것(hard wired)이 아니고 실제로 URL 매핑 클래스를 grails-app/conf/UrlMappings.groovy에 구현하여 제어할 수 있다.<p class="paragraph"/>UrlMappings 클래스는 코드의 블럭을 할당할 수 있는 mappings이라는 프로퍼티 하나만 가진다:<p class="paragraph"/><div class="code"><pre>class UrlMappings &#123;
    <span class="java&#45;keyword">static</span> mappings = &#123;
    &#125;	
&#125;</pre></div><p class="paragraph"/><h2><a name="6.4.1 Mapping to Controllers and Actions">6.4.1 Mapping to Controllers and Actions</a></h2>쉽게 매핑을 정의하려면 메소드 이름으로 하위 URL을 만들고 매핑할 컨트롤러와 액션을 네임드 파라미터를 사용하여 명시한다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;quote">"/product"</span>(controller:<span class="java&#45;quote">"product"</span>, action:<span class="java&#45;quote">"list"</span>)</pre></div><p class="paragraph"/>이 예제는 ProductController의 list 액션에 /product URL이 매핑된다는 의미이다. 물론 action을 생략하여 컨트롤러의 기본 액션에 매핑되도록 할 수 있다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;quote">"/product"</span>(controller:<span class="java&#45;quote">"product"</span>)</pre></div><p class="paragraph"/>메소드에 넘기는 블력 안에 컨트롤러와 액션을 명시하는 방법도 있다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;quote">"/product"</span> &#123;
	controller = <span class="java&#45;quote">"product"</span>
	action = <span class="java&#45;quote">"list"</span>
&#125;</pre></div><p class="paragraph"/>'어떤 방법을 사용하는 가?'는 전적으로 개인의 취향에 달려있다.<p class="paragraph"/><h2><a name="6.4.2 Embedded Variables">6.4.2 Embedded Variables</a></h2><h4>Simple Variables(간단한 변수)</h4><p class="paragraph"/>위의 절에서는 평범한 URL을 명확한 “토근”으로 매핑하는 방법을 설명했다. URL 매핑에서 말하는 토큰은 ”/” 문자 사이에 있는 문자열이다. 명확한 토큰은 /product처럼 고정된 것을 말한다. 그러나 실행할 때까지 토큰을 알 수 없는 경우도 많다. 이 경우에 다음과 같이 URL에 대치 가능한 변수를 사용한다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">static</span> mappings = &#123;
  <span class="java&#45;quote">"/product/$id"</span>(controller:<span class="java&#45;quote">"product"</span>)
&#125;</pre></div><p class="paragraph"/>여기서는 $id 변수를 두번째 토큰으로 내장시키므로써 Grails는 자동으로 두번째 토큰을 파라미터로 매핑한다. 이 토근은 params 객체의 id 프로퍼티로 접근될 수 있다. 예를 들어 /product/MacBook이라는 URL 있다면 다음 코드는 MacBook을 출력한다:<p class="paragraph"/><div class="code"><pre>class ProductController &#123;
     def index = &#123; render params.id &#125;
&#125;</pre></div><p class="paragraph"/>
물론 좀더 복잡한 매핑도 정의할 수 있다. 예를 들어 전통적인 블로그의 URL을 매핑하는 것을 정의하면 다음과 같다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">static</span> mappings = &#123;
   <span class="java&#45;quote">"/$blog/$year/$month/$day/$id"</span>(controller:<span class="java&#45;quote">"blog"</span>, action:<span class="java&#45;quote">"show"</span>)
&#125;</pre></div><p class="paragraph"/>이 예제에서 다음과 같은 URL이 매핑될 수 있다.<p class="paragraph"/><div class="code"><pre>/graemerocher/2007/01/10/my_funky_blog_entry</pre></div><p class="paragraph"/>URL의 각 토큰들은 <a href="../ref/Controllers/params.html" class="controllers">params</a> 객체의 year, month, day, id 등의 변수로 매핑된다:<p class="paragraph"/>
<h4>Dynamic Controller and Action Names(동적 컨트롤러와 액션 이름)</h4><p class="paragraph"/>변수는 동적으로 컨트롤러와 액션의 이름을 매핑하는 데에도 사용할 수 있다. 다음과 같이 Grails의 기본적은 매핑 규칙을 표현할 수 있다.:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">static</span> mappings = &#123;
    <span class="java&#45;quote">"/$controller/$action?/$id?"</span>()
&#125;</pre></div><p class="paragraph"/>이 예제에서는 URL에 포함된 컨트롤러, 액션, id의 이름을 controller, action, id 변수를 통해서 쉽게 얻을 수 있다.<p class="paragraph"/><h4>Optional Variables(필수가 아닌 변수)</h4><p class="paragraph"/>기본 매핑의 다른 특징은 토큰이 생략될 수 있도록 변수 이름의 끝에 ”?”를 사용했다는 것이다. 이 기술을 적용하여 좀 더 유연한 블로그 URL 매핑도 정의할 수 있다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">static</span> mappings = &#123;
   <span class="java&#45;quote">"/$blog/$year?/$month?/$day?/$id?"</span>(controller:<span class="java&#45;quote">"blog"</span>, action:<span class="java&#45;quote">"show"</span>)
&#125;</pre></div><p class="paragraph"/>다음 URL들은 모두 이 매핑을 따라 적절한 파라미터로 매핑되어 <a href="../ref/Controllers/params.html" class="controllers">params</a> 객체에 할당된다.<p class="paragraph"/><div class="code"><pre>/graemerocher/2007/01/10/my_funky_blog_entry
/graemerocher/2007/01/10
/graemerocher/2007/01
/graemerocher/2007
/graemerocher</pre></div><p class="paragraph"/><h4>Arbitrary Variables(임의 변수)</h4><p class="paragraph"/>URL이 매핑될 때 임의의 파라미터를 넘기도록 할 수 있다. 단지 매핑시 넘겨지는 블럭에 임의의 파라미터들을 설정하면 된다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;quote">"/holiday/win"</span> &#123;
     id = <span class="java&#45;quote">"Marrakech"</span>
     year = 2007
&#125;</pre></div><p class="paragraph"/>이 변수들은 컨트롤러에 넘겨진 <a href="../ref/Controllers/params.html" class="controllers">params</a> 객체를 통해서 사용할 수 있다:<p class="paragraph"/>
<h4>Dynamically Resolved Variables(동적으로 변수 이름 결정하기)</h4><p class="paragraph"/>하드코딩된 임의의 변수도 유용하지만 때때로 변수의 이름을 런타임에 결정해야 할 때도 있다. 이 것은 변수 이름에 블럭을 할당함으로써 가능하다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;quote">"/holiday/win"</span> &#123;
     id = &#123; params.id &#125; 
     isEligible = &#123; session.user != <span class="java&#45;keyword">null</span> &#125; // 로그인해야 한다
&#125;</pre></div><p class="paragraph"/>블럭 안에 있는 코드는 URL이 매핑될때 실행되기 때문에 다양한 로직을 결합하여 사용할 수 있다.<h2><a name="6.4.3 Mapping to Views">6.4.3 Mapping to Views</a></h2>URL을 컨트롤러나 액션 없이 뷰에 매핑하고 싶다면 그렇게 할 수 있다. 예를 들어 루트 URL ”/“를 grails-app/views/index.gsp에 바로 매핑하고 싶다면 다음과 같이 할 수 있다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">static</span> mappings = &#123;
      <span class="java&#45;quote">"/"</span>(view:<span class="java&#45;quote">"/index"</span>)  // // 루트 URL이 매핑된다.
&#125;</pre></div><p class="paragraph"/>뷰뿐만 아니라 컨트롤러도 명시하고 싶다면 다음과 같이 할 수 있다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">static</span> mappings = &#123;
   <span class="java&#45;quote">"/help"</span>(controller:<span class="java&#45;quote">"site"</span>,view:<span class="java&#45;quote">"help"</span>) // to a view <span class="java&#45;keyword">for</span> a controller
&#125;</pre></div><h2><a name="6.4.4 Mapping to Response Codes">6.4.4 Mapping to Response Codes</a></h2>Grails는 HTTP 응답 코드를 컨트롤러, 액션, 뷰에 매핑할 수 있도록 허용한다. 응답 코드를 매소드에 매핑시키고 싶다면 그렇게 할 수 있다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">static</span> mappings = &#123;
   <span class="java&#45;quote">"500"</span>(controller:<span class="java&#45;quote">"errors"</span>, action:<span class="java&#45;quote">"serverError"</span>)
   <span class="java&#45;quote">"404"</span>(controller:<span class="java&#45;quote">"errors"</span>, action:<span class="java&#45;quote">"notFound"</span>)
   <span class="java&#45;quote">"403"</span>(controller:<span class="java&#45;quote">"errors"</span>, action:<span class="java&#45;quote">"forbidden"</span>)
&#125;</pre></div><p class="paragraph"/>응답코드를 사용자가 정의한 에러 페이지에 매핑할 수도 있다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">static</span> mappings = &#123;
   <span class="java&#45;quote">"500"</span>(view:<span class="java&#45;quote">"/errors/serverError"</span>)
   <span class="java&#45;quote">"404"</span>(view:<span class="java&#45;quote">"/errors/notFound"</span>)
   <span class="java&#45;quote">"403"</span>(view:<span class="java&#45;quote">"/errors/forbidden"</span>)
&#125;</pre></div><h2><a name="6.4.5 Mapping to HTTP methods">6.4.5 Mapping to HTTP methods</a></h2>HTTP 메소드(GET, POST, PUT, DELETE)에 따라 URL이 다르게 매핑되도록 설정할 수 있다. 이 것은 RESTful API와 HTTP 메소드에 따라 매핑되도록 제약할 수 있기에 굉장히 유용하다.<p class="paragraph"/>다음은 BookControler에 RESTful API를 위해 URL 매핑되도록 하는 예제이다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">static</span> mappings = &#123;
   <span class="java&#45;quote">"/product/$id"</span>(controller:<span class="java&#45;quote">"product"</span>)&#123;
       action = &#91;GET:<span class="java&#45;quote">"show"</span>, PUT:<span class="java&#45;quote">"update"</span>, DELETE:<span class="java&#45;quote">"delete"</span>, POST:<span class="java&#45;quote">"save"</span>&#93;
   &#125;	
&#125;</pre></div><h2><a name="6.4.6 Mapping Wildcards">6.4.6 Mapping Wildcards</a></h2>Grails의 URL 매핑 메커니즘은 와일드카드도 지원한다. 다음과 같이 사용할 수 있다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">static</span> mappings = &#123;
	<span class="java&#45;quote">"/images/&#42;.jpg"</span>(controllers:<span class="java&#45;quote">"image"</span>)
&#125;</pre></div><p class="paragraph"/>이 예제에서는 /image/logo.jpg처럼 이미지에 대한 모든 경로가 매핑될 것이다. 물론 변수를 사용해서 동일한 결과를 얻을 수도 있다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">static</span> mappings = &#123;
	<span class="java&#45;quote">"/images/$name.jpg"</span>(controllers:<span class="java&#45;quote">"image"</span>)
&#125;</pre></div><p class="paragraph"/>한 단계 이상의 것들이 매핑되도록 와일드카드를 두 개 사용할 수도 있다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">static</span> mappings = &#123;
	<span class="java&#45;quote">"/images/&#42;&#42;.jpg"</span>(controllers:<span class="java&#45;quote">"image"</span>)
&#125;</pre></div><p class="paragraph"/>이 경우에 /image/logo.jpg 뿐만아니라 /image/other/logo.jpg도 매핑된다. 와일드카드와 변수를 함께 사용할 수 있다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">static</span> mappings = &#123;
	// will match /image/logo.jpg and /image/other/logo.jpg 
	<span class="java&#45;quote">"/images/$name&#42;&#42;.jpg"</span>(controllers:<span class="java&#45;quote">"image"</span>)
&#125;</pre></div><p class="paragraph"/>와일드카드로 매핑된 경로가 <a href="../ref/Controllers/params.html" class="controllers">params</a> 객체에서 얻을 수 있는 name 파라미터에 저장될 것이다:<p class="paragraph"/><div class="code"><pre>def name = params.name
println name // <span class="java&#45;quote">"logo.jpg"</span>나 <span class="java&#45;quote">"other/logo.jpg"</span>가 출력된다</pre></div><p class="paragraph"/><p class="paragraph"/>
<h2><a name="6.4.7 Automatic Link Re-Writing">6.4.7 Automatic Link Re-Writing</a></h2>URL 매핑의 강력한 기능이 하나 더 있다. 이 기능은 자동으로 <a href="../ref/Tags/link.html" class="tags">link</a>를 수정한다. mapping 프로퍼티을 수정하지 않고서도 모든 링크를 수정할 수 있다.<p class="paragraph"/>이것은 URL 매핑시 링크를 리버스엔지니어링하는 URL rewrite 기술을 통해 이루어진다. 다음과 같이 위에서 설명한 블로그 매핑이 있다면:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">static</span> mappings = &#123;
   <span class="java&#45;quote">"/$blog/$year?/$month?/$day?/$id?"</span>(controller:<span class="java&#45;quote">"blog"</span>, action:<span class="java&#45;quote">"show"</span>)
&#125;</pre></div><p class="paragraph"/>다음과 같이 link 태그를 사용할 수 있다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:link controller=<span class="xml&#45;quote">"blog"</span> action=<span class="xml&#45;quote">"show"</span> params=<span class="xml&#45;quote">"&#91;blog:'fred', year:2007&#93;"</span>&#62;</span>My Blog<span class="xml&#45;tag">&#60;/g:link&#62;</span>
<span class="xml&#45;tag">&#60;g:link controller=<span class="xml&#45;quote">"blog"</span> action=<span class="xml&#45;quote">"show"</span> params=<span class="xml&#45;quote">"&#91;blog:'fred', year:2007, month:10&#93;"</span>&#62;</span>My Blog &#45; October 2007 Posts<span class="xml&#45;tag">&#60;/g:link&#62;</span></pre></div><p class="paragraph"/>자동으로 올바른 URL로 rewrite될 것이다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;a href=<span class="xml&#45;quote">"/fred/2007"</span>&#62;</span>My Blog<span class="xml&#45;tag">&#60;/a&#62;</span>
<span class="xml&#45;tag">&#60;a href=<span class="xml&#45;quote">"/fred/2007/10"</span>&#62;</span>My Blog &#45; October 2007 Posts<span class="xml&#45;tag">&#60;/a&#62;</span></pre></div><h2><a name="6.4.8 Applying Constraints">6.4.8 Applying Constraints</a></h2>URL 매핑은 Grails의 유효성 검사 제약조건(<a href="../guide/single.html#7.1 Declaring Constraints" class="guide">validation constraints</a>) 매커니즘과 통합돼 있다. 이것은 URL이 매핑될때 제약조건을 달 수 있게 해준다. 다음과 같이 위의 블로그 예제에 적용해 본다면:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">static</span> mappings = &#123;
   <span class="java&#45;quote">"/$blog/$year?/$month?/$day?/$id?"</span>(controller:<span class="java&#45;quote">"blog"</span>, action:<span class="java&#45;quote">"show"</span>)
&#125;</pre></div><p class="paragraph"/>다음의 URL은 매핑된다:<p class="paragraph"/><div class="code"><pre>/graemerocher/2007/01/10/my_funky_blog_entry</pre></div><p class="paragraph"/>그러나 이것은 다음의 URL도 허용할 것이다:<p class="paragraph"/><div class="code"><pre>/graemerocher/not_a_year/not_a_month/not_a_day/my_funky_blog_entry</pre></div><p class="paragraph"/>하지만 컨트롤러에서 url을 파싱해야 하는 것은 큰 문제가 아닐 수 없다. 운좋게도 URL 매핑에 제약조건을 정의해서 URL 토큰의 유효성을 검사할 수 있다.<p class="paragraph"/><div class="code"><pre><span class="java&#45;quote">"/$blog/$year?/$month?/$day?/$id?"</span> &#123;
     controller = <span class="java&#45;quote">"blog"</span>
     action = <span class="java&#45;quote">"show"</span>
     constraints &#123;
          year(matches:/&#100;&#123;4&#125;/)
          month(matches:/&#100;&#123;2&#125;/)
          day(matches:/&#100;&#123;2&#125;/)
     &#125;
&#125;</pre></div><p class="paragraph"/>이 예제에서 contraints 블럭은 year, month, day 파라미터가 특별한 형식을 따르도록 보증한다. 그래서 우리가 해야 할 일을 줄여 준다.
<h2><a name="6.5 Web Flow">6.5 Web Flow</a></h2><h4>Overview(소개)</h4><p class="paragraph"/>Grails는 <a href="http://opensource.atlassian.com/confluence/spring/display/WEBFLOW" target="blank">Spring의 웹 플로우</a> 프로젝트에 기반하여 웹 플로우를 지원한다. 하나의 웹 플로우는 다양한 요구와 상태를 유지하는 컨버세이션(conversation)이라고 할 수 있다. 웹 플로우는 시작과 끝 상태를 가진다.<p class="paragraph"/>웹 플로우는 HTTP 세션을 요구하지 않지만 대신 상태를 저장할 때 직렬화시킨다. 이 방법은 Grails가 차례대로 넘기는 요청 파라미터인 플로우 실행 키를 사용하여 복원된다. 이 것은 HttpSession이나 메모리나 클러스터링에 상주시키는 기술을 사용하는 것보다 상태가 있는 어플리케이션의 플로우를 좀 더 쉽게 확장할 수 있게 만들어 준다.<p class="paragraph"/>웹 플로우는 본질적으로 고급 상태 머신이다. 이 것은 한 상태에서 다음 상태로 전이되는 실행의 “플로우”을 관장한다. 웹 플로우가 대신 관리함으로써 상태는 자동으로 관리되기 때문에 진행중에 사용자의 액션을 관리하는 일을 덜어 준다. 이것은 쇼핑 카트, 호텔 예약등의 여러개의 페이지를 가진 웍 플로우(work flow)들의 유즈 케이스를 위한 웹 플로우를 완벽하게 만들어 준다.<p class="paragraph"/><h4>Creating a Flow(플로우 만들기)</h4><p class="paragraph"/>플로우를 만들면 다음과 같이 평범한 Grails 컨트롤러가 생성되고 관례에 따라 Flow로 끝나는 액션이 추가된다:<p class="paragraph"/><div class="code"><pre>class BookController &#123;
   def index = &#123;
      redirect(action:<span class="java&#45;quote">"shoppingCart"</span>)
   &#125;
   def shoppingCartFlow = &#123;
        &#8230;
   &#125;
&#125;</pre></div><p class="paragraph"/>Flow 접미어를 생락한 채로 액션에서 플로우를 참조시키거나 리다이렉트시킨다는 것을 기억하라. 다시 말해서 위의 플로우 액션의 이름은 shoppingCart이다.<h2><a name="6.5.1 Start and End States">6.5.1 Start and End States</a></h2>플로우는 시작과 끝 상태를 갖는 다고 언급했었다. 시작 상태는 사용자가 컨버세이션(혹은 플로우)를 초기화 시키는 첫 상태를 의미한다. Grails 플로우의 시작 상태는 블럭에서 제일 처음 호출하는 메소드이다. 예를 들어:<p class="paragraph"/><div class="code"><pre>class BookController &#123;
   &#8230;
   def shoppingCartFlow = &#123;
       showCart &#123;
           on(<span class="java&#45;quote">"checkout"</span>).to <span class="java&#45;quote">"enterPersonalDetails"</span>           
           on(<span class="java&#45;quote">"continueShopping"</span>).to <span class="java&#45;quote">"displayCatalogue"</span>
       &#125;
       &#8230;
       displayCatalogue &#123;
            redirect(controller:<span class="java&#45;quote">"catalogue"</span>, action:<span class="java&#45;quote">"show"</span>)
       &#125;
       displayInvoice()
   &#125;
&#125;</pre></div><p class="paragraph"/>showCart 노드는 플로우의 시작 상태이다. showCart 플로우는 액션을 정의하거나 리다이렉트 시키지 않았기 때문에 관례에 따라 뷰 상태(<a href="../guide/single.html#6.5.2 Action States and View States" class="guide">view state</a>)로 간주되고 grails-app/views/book/shoppingCart/showCart.gsp라는 뷰를 참조한다.<p class="paragraph"/>다른 컨트롤러의 액션들과는 다르게 이 뷰는 플로우의 이름과 동일한 디렉토리에 저장된다는 것을 기억하라.<p class="paragraph"/>이 shoppingCart 플로우는 두 가지 끝 상태를 가지고 있다. 먼저 displayCatalogue는 다른 컨트롤러의 액션으로 리다이렉트 시킨다. 둘째로 displayInvoice는 아무것도 없는 끝 상태이기 때문에 즉시 플로우를 종료시키고 바로 grails-app/views/book/shoppingCart/displayInvoice.gsp라는 뷰가 렌더링될 것이다.<p class="paragraph"/>이 showCart 플로우는 한번 끝나면 시작 상태를 통해서만 다시 시작될 수 있다. 다른 상태를 통해서는 진입될 수 없다.<h2><a name="6.5.2 Action States and View States">6.5.2 Action States and View States</a></h2><h4>View states(뷰 상태)</h4><p class="paragraph"/>뷰 상태는 액션이나 리다이렉트를 정의하지 않는 상태를 말한다. 다음은 뷰 상태의 예제이다:<p class="paragraph"/><div class="code"><pre>enterPersonalDetails &#123;
   on(<span class="java&#45;quote">"submit"</span>).to <span class="java&#45;quote">"enterShipping"</span>
   on(<span class="java&#45;quote">"<span class="java&#45;keyword">return</span>"</span>).to <span class="java&#45;quote">"showCart"</span>
&#125;</pre></div><p class="paragraph"/>이것은 기본적으로 grails-app/views/book/shoppingCart/enterPersonalDetails.gsp라는 뷰를 찾는다. enterPersonalDetails 상태에는 summit과 return이라는 두 개의 이벤트가 정의됐다는 것을 살펴하자. 이 이벤트들은 처리돼야(<a href="../guide/single.html#6.5.3 Flow Execution Events" class="guide">triggering</a>) 하고 만약 렌더링할 뷰를 변경하고 싶다면 render 메소드를 사용하면 된다:<p class="paragraph"/><div class="code"><pre>enterPersonalDetails &#123;
   render(view:<span class="java&#45;quote">"enterDetailsView"</span>)
   on(<span class="java&#45;quote">"submit"</span>).to <span class="java&#45;quote">"enterShipping"</span>
   on(<span class="java&#45;quote">"<span class="java&#45;keyword">return</span>"</span>).to <span class="java&#45;quote">"showCart"</span>
&#125;</pre></div><p class="paragraph"/>지금 이것은 grails-app/views/book/shoppingCart/enterDetailsView.gsp를 찾을 것이다. 만약 공유되는 뷰를 사용하고 싶다면 다음과 같이 파리미터로 넘길 뷰 이름을 ”/shared”로 시작하게 하라:<p class="paragraph"/><div class="code"><pre>enterPersonalDetails &#123;
   render(view:<span class="java&#45;quote">"/shared/enterDetailsView"</span>)
   on(<span class="java&#45;quote">"submit"</span>).to <span class="java&#45;quote">"enterShipping"</span>
   on(<span class="java&#45;quote">"<span class="java&#45;keyword">return</span>"</span>).to <span class="java&#45;quote">"showCart"</span>
&#125;</pre></div><p class="paragraph"/>이것은 grails-app/views/shared/enterDetailsView.gsp를 찾을 것이다.<p class="paragraph"/><h4>Action States(액션 상태)</h4><p class="paragraph"/>액션 상태는 뷰를 렌더링하지 않고 코드를 실행하는 상태를 말한다. 이 액션의 결과로 플로우는 전이된다. 액션 상태를 만들려면 실행할 액션를 정의해야 한다. 이 액션은 action 메소드를 호출하고 실행할 코드블럭에 넘겨서 수행된다:<p class="paragraph"/><div class="code"><pre>listBooks &#123;
   action &#123; 
	  &#91; bookList:Book.list() &#93;
   &#125;
   on(<span class="java&#45;quote">"success"</span>).to <span class="java&#45;quote">"showCatalogue"</span>
   on(Exception).to <span class="java&#45;quote">"handleError"</span>
&#125;</pre></div><p class="paragraph"/>컨트롤러의 액션과 매우 유사하게 생긴 액션을 볼 수 있다. 실제로 컨트롤러의 액션을 재사용할 수도 있다. 액션이 에러없이 성공적으로 반한되면 성공 이벤트가 발생한다. 이 예제에서는 맵을 반환하는데 이 맵은 “모델”로 간주되고 flow 스콥(<a href="../guide/single.html#6.5.4 Flow Scopes" class="guide">flow scope</a>)에 자동으로 저장된다.<p class="paragraph"/>추가로 이 예제에서 우리는 발생한 에러를 처리하기 위해 예외 핸들러를 사용하였다:<p class="paragraph"/><div class="code"><pre>on(Exception).to <span class="java&#45;quote">"handleError"</span></pre></div><p class="paragraph"/>이 예제에서 예외가 발생하면 플로우는 handleError라는 상태로 전이된다.<p class="paragraph"/>flow 요청 컨텍스트를 사용하는 좀 더 복잡한 액션을 작성할 수 있다:<p class="paragraph"/><div class="code"><pre>processPurchaseOrder  &#123;
     action &#123;
         def a =  flow.address
         def p = flow.person
         def pd = flow.paymentDetails
         def cartItems = flow.cartItems
         flow.clear()<p class="paragraph"/>         def o = <span class="java&#45;keyword">new</span> Order(person:p, shippingAddress:a, paymentDetails:pd)
         o.invoiceNumber = <span class="java&#45;keyword">new</span> Random().nextInt(9999999)
         cartItems.each &#123; o.addToItems(it) &#125;
         o.save()
         &#91;order:o&#93;
     &#125;
     on(<span class="java&#45;quote">"error"</span>).to <span class="java&#45;quote">"confirmPurchase"</span>
     on(Exception).to <span class="java&#45;quote">"confirmPurchase"</span>
     on(<span class="java&#45;quote">"success"</span>).to <span class="java&#45;quote">"displayInvoice"</span>
&#125;</pre></div><p class="paragraph"/>이 예제에는 flow 스콥에 통합된 정보를 사용하여 Order 객체를 생성하는 좀 더 복잡한 액션이 정의돼 있다. 이 객체는 모델로 반환된다. 요청 컨텍스트와 “flow” 스콥을 사용하는 것은 매우 중요하다.<p class="paragraph"/><h4>Transition Actions(전이 액션)</h4><p class="paragraph"/>액선의 또 다른 형태로 전이 액션이라는 것이 있다. 전이 액션은 이벤트(<a href="../guide/single.html#6.5.3 Flow Execution Events" class="guide">event</a>)가 발생하면 다른 상태로 전이되기 전에 실행된다. 다음은 전이 액션의 예제이다:<p class="paragraph"/><div class="code"><pre>enterPersonalDetails &#123;
   on(<span class="java&#45;quote">"submit"</span>) &#123;
       log.trace <span class="java&#45;quote">"Going to enter shipping"</span>	
   &#125;.to <span class="java&#45;quote">"enterShipping"</span>
   on(<span class="java&#45;quote">"<span class="java&#45;keyword">return</span>"</span>).to <span class="java&#45;quote">"showCart"</span>
&#125;</pre></div><p class="paragraph"/>우리가 단순히 전이 로그를 남기는 코드 블럭을 submit 이벤트에 어떻게 넘겼는지를 주목하라. 전이 상태는 데이터를 바인딩(<a href="../guide/single.html#6.5.5 Data Binding and Validation" class="guide">data binding and validation</a>)하고 그 유효성을 검사할 때 매우 유용하다. 유효성 검사는 나중에 다시 설명한다.<p class="paragraph"/><h2><a name="6.5.3 Flow Execution Events">6.5.3 Flow Execution Events</a></h2>플로우의 상태를 다른 상태로 전이 시키기 위해서 플로우가 무슨 상태로 전이 해야 하는지를 알리는 이벤트를 발생시켜야 한다. 이벤트는 뷰 상태와 액션 상태에서 발생시킬 수 있다.<p class="paragraph"/><h4>Triggering Events from a View State(뷰 상태에서 이벤트 발생시키키)</h4><p class="paragraph"/>위에서 다뤘던 플로우의 시작 상태는 checkout과 continueShopping이라는 두 가지 이벤트를 처리할 수 있었다:<p class="paragraph"/><div class="code"><pre>def shoppingCartFlow = &#123;
    showCart &#123;
        on(<span class="java&#45;quote">"checkout"</span>).to <span class="java&#45;quote">"enterPersonalDetails"</span>           
        on(<span class="java&#45;quote">"continueShopping"</span>).to <span class="java&#45;quote">"displayCatalogue"</span>
    &#125;
    &#8230;
&#125;</pre></div><p class="paragraph"/>showCart는 뷰 상태이기 때문에 grails-app/book/shoppingCart/showCart.gsp를 렌더링할 것이다. 이 뷰에는 플로우를 실행하는 요소가 포함돼야 한다. 폼에 <a href="../ref/Tags/submitButton.html" class="tags">submitButton</a> 태그를 사용하여 플로우를 실행시킨다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:form action=<span class="xml&#45;quote">"shoppingCart"</span>&#62;</span>
    <span class="xml&#45;tag">&#60;g:submitButton name=<span class="xml&#45;quote">"continueShopping"</span> value=<span class="xml&#45;quote">"Continue Shopping"</span>&#62;</span><span class="xml&#45;tag">&#60;/g:submitButton&#62;</span>
    <span class="xml&#45;tag">&#60;g:submitButton name=<span class="xml&#45;quote">"checkout"</span> value=<span class="xml&#45;quote">"Checkout"</span>&#62;</span><span class="xml&#45;tag">&#60;/g:submitButton&#62;</span>
<span class="xml&#45;tag">&#60;/g:form&#62;</span></pre></div><p class="paragraph"/>이 폼은 shoppingCart 플로우에 전송(submit)된다. 각 <a href="../ref/Tags/submitButton.html" class="tags">submitButton</a> 태그의 name 속성은 발생되는 이벤트를 의미한다. <a href="../ref/Tags/link.html" class="tags">link</a> 태그를 사용하여 폼없이 이벤트를 발생시킬 수 있다.<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:link action=<span class="xml&#45;quote">"shoppingCart"</span> event=<span class="xml&#45;quote">"checkout"</span> /&#62;</span></pre></div><p class="paragraph"/><h4>Triggering Events from an Action(액션에서 이벤트 발생시키기)</h4><p class="paragraph"/>액션에서 이벤트를 발생시키려면 메소드를 실행해야 한다. 예를 들어 error()와 success()라는 빌트인 메소드가 있다. 다음 예제는 전이 액션에서 유효성 감사에 실패했을 때 error() 이벤트를 발생시킨다:<p class="paragraph"/><div class="code"><pre>enterPersonalDetails &#123;
   on(<span class="java&#45;quote">"submit"</span>) &#123;
         def p = <span class="java&#45;keyword">new</span> Person(params)
         flow.person = p
         <span class="java&#45;keyword">if</span>(!p.validate())<span class="java&#45;keyword">return</span> error()
   &#125;.to <span class="java&#45;quote">"enterShipping"</span>
   on(<span class="java&#45;quote">"<span class="java&#45;keyword">return</span>"</span>).to <span class="java&#45;quote">"showCart"</span>
&#125;</pre></div><p class="paragraph"/>전이 액션에서 에러가 발생하면 플로우를 enterPersonalDetails 상태로 되돌아 가게 만들 것이다.<p class="paragraph"/>액션 상태에서 플로우를 리다이렉트 시키기위해 이벤트를 발생시킬 수 있다:<p class="paragraph"/><div class="code"><pre>shippingNeeded &#123;
   action &#123;
       <span class="java&#45;keyword">if</span>(params.shippingRequired) yes()
       <span class="java&#45;keyword">else</span> no()
   &#125;
   on(<span class="java&#45;quote">"yes"</span>).to <span class="java&#45;quote">"enterShipping"</span>
   on(<span class="java&#45;quote">"no"</span>).to <span class="java&#45;quote">"enterPayment"</span>
&#125;</pre></div><p class="paragraph"/><h2><a name="6.5.4 Flow Scopes">6.5.4 Flow Scopes</a></h2><h4>Scope Basics(스콥의 기초)</h4><p class="paragraph"/>이전 예제에서 플로우 스콥에 객체를 저장하기 위해 “flow”라고 불리는 특별한 객체를 사용했던 것을 기억할 것이다. Grails의 플로우에서는 유용한 다섯 개의 스콥를 사용할 수 있다.
<ul class="star">
<li>request - 현재 요청에서 사용할 객체를 저장한다.</li>
<li>flash - 현재 요청과 다음 요청에서 사용할 객체를 저장한다.</li>
<li>flow - 현 플로우에서 사용할 객체를 저장한다. 플로우가 끝 상태에 도달해야 저장된 객체들이 제거된다.</li>
<li>conversation - 루트 플로우와 네스티드(nested) 서브플로우에서 사용할 객체를 저장한다.</li>
<li>session - 사용자의 세션에서 사용할 객체를 저장한다.</li>
</ul><p class="paragraph"/><blockquote class="note">
Grails의 서비스 클래스는 자동으로 웹 플로우 스콥에 포함된다. 더 자세한 정보는 <a href="../guide/single.html#8. The Service Layer" class="guide">Services</a>에 대한 문서를 참고하라.
</blockquote><p class="paragraph"/>액션에서 반환하는 모델 맵은 자동으로 flow 스콥의 모델이 될 것이다. 다음과 같이 전이 액션에서 반환한 맵은 자동으로 flow 스콥에 저장된다:<p class="paragraph"/><div class="code"><pre>enterPersonalDetails &#123;
   on(<span class="java&#45;quote">"submit"</span>) &#123;
         &#91;person:<span class="java&#45;keyword">new</span> Person(params)&#93;
   &#125;.to <span class="java&#45;quote">"enterShipping"</span>
   on(<span class="java&#45;quote">"<span class="java&#45;keyword">return</span>"</span>).to <span class="java&#45;quote">"showCart"</span>
&#125;</pre></div><p class="paragraph"/>각 생태마다 새로운 request가 만들어짐에 유의해야 한다. 액션 상태에서의 request 스콥에 저장된 객체는 뒤에 이어지는 뷰 상태에서 이용할 수 없다. 다른 상태로 전이할 때 다른 스콥으로 객체를 넘겨라. 또 웹 플로우에서 다음과 같은 것을 기억해야 한다:
<ol>
<li>상태를 전이시킬 때 flash 스콥에서 request 스콥로 객체를 이동시킨다.</li>
<li>렌더링하기 전에 flow 스콥과 conversation 스콥에서 view 모델로 객체를 합친다(GSP 페이지 같은 뷰에서 객체를 참조할 때 스콥 접두어를 포함시키지 않는 것이 좋다).</li>
</ol><p class="paragraph"/><h4>Flow Scopes and Serialization(플로우 스콥과 직렬화)</h4><p class="paragraph"/>flash, flow, converstion 스콥에 객체를 저장하려면 그 객체들은 java.io.Serializable을 구현해야 한다. 그렇지 않으면 에러가 발생한다. 이것은 스콥에 저장될 <a href="../guide/single.html#5. Object Relational Mapping (GORM)" class="guide">domain classes</a>에 영향을 주고 뷰에서 렌더링할 수 있게 만든다. 예를 들어 다음과 같은 도메인 클래스를 살펴보자:<p class="paragraph"/>When placing objects in <code>flash</code>, <code>flow</code> or <code>conversation</code> scope they must implement <code>java.io.Serializable</code> otherwise you will get an error. This has an impact on <a href="../guide/single.html#5. Object Relational Mapping (GORM)" class="guide">domain classes</a> in that domain classes are typically placed within a scope so that they can be rendered in a view. For example consider the following domain class:<p class="paragraph"/><div class="code"><pre>class Book &#123;
	<span class="java&#45;object">String</span> title
&#125;</pre></div><p class="paragraph"/>flow 스콥에 Book 클래스의 인스턴스를 저장하기 위해 다음과 같이 이 클래스를 수정해야 한다:<p class="paragraph"/><div class="code"><pre>class Book <span class="java&#45;keyword">implements</span> Serializable &#123;
	<span class="java&#45;object">String</span> title
&#125;</pre></div><p class="paragraph"/>이 것은 도메인 클래스에 정의한 관계(association)와 클로저에도 영향을 끼친다. 다음의 예제를 보면:<p class="paragraph"/><div class="code"><pre>class Book <span class="java&#45;keyword">implements</span> Serializable &#123;
	<span class="java&#45;object">String</span> title
	Author author
&#125;</pre></div><p class="paragraph"/>만약 Author 클래스에 Serializable을 구현하지 않았다면 에러가 발생한다. onLoad, onSave, 등과 같은 <a href="../guide/single.html#5.5.1 Events and Auto Timestamping" class="guide">GORM events</a>에서 사용한 클로저에도 영향을 끼친다. 다음의 도메인 클래스의 인스턴스가 flow 스콥에 저장되면 에러가 발생한다:<p class="paragraph"/><div class="code"><pre>class Book <span class="java&#45;keyword">implements</span> Serializable &#123;
	<span class="java&#45;object">String</span> title
	def onLoad = &#123;
		println <span class="java&#45;quote">"I'm loading"</span>
	&#125;
&#125;</pre></div><p class="paragraph"/>onload 이벤트에 할당된 블럭은 직렬화될 수 없기 때문이다. 이 것을 방지하기 위해 모든 이벤트는 transient로 정의돼야 한다:<p class="paragraph"/><div class="code"><pre>class Book <span class="java&#45;keyword">implements</span> Serializable &#123;
	<span class="java&#45;object">String</span> title
	<span class="java&#45;keyword">transient</span> onLoad = &#123;
		println <span class="java&#45;quote">"I'm loading"</span>
	&#125;
&#125;</pre></div>
<h2><a name="6.5.5 Data Binding and Validation">6.5.5 Data Binding and Validation</a></h2>시작과 끝 상태를 다룬 절에서 첫 예제의 시작상태는 enterPersonalDetails 상태로 전이를 일으켰다. 이 상태는 뷰를 렌더링하고 사용자가 요구된 정보를 입력할 때까지 기다린다:<p class="paragraph"/><div class="code"><pre>enterPersonalDetails &#123;
   on(<span class="java&#45;quote">"submit"</span>).to <span class="java&#45;quote">"enterShipping"</span>
   on(<span class="java&#45;quote">"<span class="java&#45;keyword">return</span>"</span>).to <span class="java&#45;quote">"showCart"</span>
&#125;</pre></div><p class="paragraph"/>이 뷰에는 submit 이벤트와 return 이벤트를 발생시킬 수 있는 두 개의 submit 버튼이 있다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:form action=<span class="xml&#45;quote">"shoppingCart"</span>&#62;</span>
    <span class="xml&#45;comment">&#60;!&#45;&#45; Other fields &#45;&#45;&#62;</span>
    <span class="xml&#45;tag">&#60;g:submitButton name=<span class="xml&#45;quote">"submit"</span> value=<span class="xml&#45;quote">"Continue"</span>&#62;</span><span class="xml&#45;tag">&#60;/g:submitButton&#62;</span>
    <span class="xml&#45;tag">&#60;g:submitButton name=<span class="xml&#45;quote">"return"</span> value=<span class="xml&#45;quote">"Back"</span>&#62;</span><span class="xml&#45;tag">&#60;/g:submitButton&#62;</span>
<span class="xml&#45;tag">&#60;/g:form&#62;</span></pre></div><p class="paragraph"/>그러나 폼에 제출된 정보를 가로챌 수는 없을까? 폼의 정보를 가로 채기 위해서 플로우의 전이 액션을 사용할 수 있다:<p class="paragraph"/><div class="code"><pre>enterPersonalDetails &#123;
   on(<span class="java&#45;quote">"submit"</span>) &#123;
         flow.person = <span class="java&#45;keyword">new</span> Person(params)
         !flow.person.validate() ? error() : success()
   &#125;.to <span class="java&#45;quote">"enterShipping"</span>
   on(<span class="java&#45;quote">"<span class="java&#45;keyword">return</span>"</span>).to <span class="java&#45;quote">"showCart"</span>
&#125;</pre></div><p class="paragraph"/>요청 파라미터로 부터 데이터를 어떻게 바인딩할 수 있고 flow 스콥에 Person 인스턴스가 어떻게 저장되는지 알아보자. 흥미로운 것은 유효성을 검사하고 유효성 검사(<a href="../guide/single.html#7. Validation" class="guide">validation</a>)가 실패했을 때 error() 메소드를 실행시키는 것이다. 이 것은 플로우의 전이를 중지하고 enterPersonalDetails 뷰로 되돌아가야 한다는 것을 의미한다. 그 결과로 사용자는 올바른 정보만 입력할 수 있다. 실패하지 않으면 enterShipping 상태로 계속 전이할 것이다.
<h2><a name="6.5.6 Subflows and Conversations">6.5.6 Subflows and Conversations</a></h2>Grails의 웹 플로우는 서브플로우를 지원한다. 서브플로우는 플로우안에 있는 플로우를 말한다. 검색 플로우의 예를 보면:<p class="paragraph"/><div class="code"><pre>def searchFlow = &#123;
            displaySearchForm &#123;
                on(<span class="java&#45;quote">"submit"</span>).to <span class="java&#45;quote">"executeSearch"</span>
            &#125;
            executeSearch &#123;
                action &#123;
                    &#91;results:searchService.executeSearch(params.q)&#93;
                &#125;
                on(<span class="java&#45;quote">"success"</span>).to <span class="java&#45;quote">"displayResults"</span>
                on(<span class="java&#45;quote">"error"</span>).to <span class="java&#45;quote">"displaySearchForm"</span>
            &#125;
            displayResults &#123;
                on(<span class="java&#45;quote">"searchDeeper"</span>).to <span class="java&#45;quote">"extendedSearch"</span>
                on(<span class="java&#45;quote">"searchAgain"</span>).to <span class="java&#45;quote">"displaySearchForm"</span>
            &#125;
            extendedSearch &#123;
                subflow(extendedSearchFlow)   // &#60;&#45;&#45;&#45; 확장된 검색 서브플로우
                on(<span class="java&#45;quote">"moreResults"</span>).to <span class="java&#45;quote">"displayMoreResults"</span>
                on(<span class="java&#45;quote">"noResults"</span>).to <span class="java&#45;quote">"displayNoMoreResults"</span>
            &#125;
            displayMoreResults()
            displayNoMoreResults()
&#125;</pre></div><p class="paragraph"/>이 것은 extendedSearch 상태에 있는 서브플로우를 참조한다. 서브플로우는 다른 플로우와 완전히 동일하다:<p class="paragraph"/><div class="code"><pre>def extendedSearchFlow = &#123;
       startExtendedSearch &#123;
           on(<span class="java&#45;quote">"findMore"</span>).to <span class="java&#45;quote">"searchMore"</span>
           on(<span class="java&#45;quote">"searchAgain"</span>).to <span class="java&#45;quote">"noResults"</span>
       &#125;
       searchMore &#123;
           action &#123;
              def results = searchService.deepSearch(ctx.conversation.query)
              <span class="java&#45;keyword">if</span>(!results)<span class="java&#45;keyword">return</span> error()
              conversation.extendedResults = results
           &#125;
           on(<span class="java&#45;quote">"success"</span>).to <span class="java&#45;quote">"moreResults"</span>
           on(<span class="java&#45;quote">"error"</span>).to <span class="java&#45;quote">"noResults"</span>
       &#125;
       moreResults()
       noResults()
&#125;</pre></div><p class="paragraph"/>extendedResults가 conversation 스콥에 어떻게 저장되는지 살펴보자. 이 스콥는 conversation 전체에 걸친 모든 상태에 공유되므로 flow 스콥와 다르다. 서브플로우의 끝 상태인 noResults와 moreResults는 이벤트를 주 플로우에 발생킨다:<p class="paragraph"/><div class="code"><pre>extendedSearch &#123;
         subflow(extendedSearchFlow)   // &#60;&#45;&#45;&#45; extended search subflow
         on(<span class="java&#45;quote">"moreResults"</span>).to <span class="java&#45;quote">"displayMoreResults"</span>
         on(<span class="java&#45;quote">"noResults"</span>).to <span class="java&#45;quote">"displayNoMoreResults"</span>
&#125;</pre></div><p class="paragraph"/><h2><a name="6.6 Filters">6.6 Filters</a></h2>Grails 컨트롤러(<a href="../guide/single.html#6.1 Controllers" class="guide">controllers</a>)는 잘 만드러진 인터셉터를 지원한다. 인터셉터는 적은 수의 컨트롤러에는 정말 유용하지만 대형 어플리케이션에서 관리하는 것은 매우 어렵다. 반면에 필터는 컨트롤러, URI 공간(space), 액션들의 그룹에 적용될 수 있다. 필터는 주 컨트롤러 로직과 분리하여 쉽게 끼워넣고plug-in 관리할 수 있고 보안, 로깅, 등에 필요한 크로스커팅(cross cutting)을 지원한다.<p class="paragraph"/><h2><a name="6.6.1 Applying Filters">6.6.1 Applying Filters</a></h2>필터를 만드는 방법은 관례에 따라 grails-app/conf 디렉토리에 “Filters”로 끝나는 클래스를 만들면 된다. 이 클래스 안에 filters라고 불리는 코드 블럭을 만들고 이 블럭에 필터의 내용을 정의한다:<p class="paragraph"/><div class="code"><pre>class ExampleFilters &#123;
   def filters = &#123;
        // 여기에 필터를 정의한다
   &#125;
&#125;</pre></div><p class="paragraph"/>filters 블럭안의 필터들에는 이름과 스콥을 지정할 수 있다. 이름은 메소드 이름이고 스콥는 네임드 파라미터를 사용하여 정의할 수 있다. 예를 들어 모든 컨트롤러와 액션에 적용되는 필터를 정의하고 싶다면 다음과 같이 와일드카드를 사용한다:<p class="paragraph"/><div class="code"><pre>sampleFilter(controller:'&#42;', action:'&#42;') &#123;
  // interceptor definitions
&#125;</pre></div><p class="paragraph"/>가능한 이 필터의 스콥은 다음과 같다:
<ul class="star">
<li>생략가능한 와일드카드를 사용한 컨트롤러나 액션 이름</li>
<li>Ant의 매칭 문법으로 표현한 URI</li>
</ul><p class="paragraph"/>필터의 예제들:
<ul class="star">
<li>모든 컨트롤러와 액션에 적용되는 필터</li>
</ul><p class="paragraph"/><div class="code"><pre>all(controller:'&#42;', action:'&#42;') &#123;<p class="paragraph"/>&#125;</pre></div>
<ul class="star">
<li>BookController에만 적용되는 필터</li>
</ul><p class="paragraph"/><div class="code"><pre>justBook(controller:'book', action:'&#42;') &#123;<p class="paragraph"/>&#125;</pre></div>
<ul class="star">
<li>URI에 적용되는 필터</li>
</ul><p class="paragraph"/><div class="code"><pre>someURIs(uri:'/book/&#42;&#42;') &#123;<p class="paragraph"/>&#125;</pre></div>
<ul class="star">
<li>모든 URI에 적용되는 필터</li>
</ul><p class="paragraph"/><div class="code"><pre>allURIs(uri:'/&#42;&#42;') &#123;<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/>필터들은 정의한 순서대로 실행된다.
<h2><a name="6.6.2 Filter Types">6.6.2 Filter Types</a></h2>필터의 바디에 정의할 수 있는 인터셉터의 타입은 다음과 같다:
<ul class="star">
<li><code>before</code> - 액션이 실행되기 전에 실행된다. false를 반환하면 뒤따르는 모든 필터와 액션이 실행되지 않음</li>
<li><code>after</code> - 액션이 실행된 후에 실행된다. 첫번째 파라미터로 뷰 모델을 넘겨 받음</li>
<li><code>afterView</code> - 뷰가 렌더링된 후에 실행</li>
</ul><p class="paragraph"/>예를 들어 보통의 인증 유즈 케이스를 구현하기 위해서 다음과 같이 정의한다:<p class="paragraph"/><div class="code"><pre>class SecurityFilters &#123;
   def filters = &#123;
       loginCheck(controller:'&#42;', action:'&#42;') &#123;
           before = &#123;
              <span class="java&#45;keyword">if</span>(!session.user &#38;&#38; !actionName.equals('login')) &#123;
                  redirect(action:'login')
                  <span class="java&#45;keyword">return</span> <span class="java&#45;keyword">false</span>
               &#125;
           &#125;<p class="paragraph"/>       &#125;
   &#125;
&#125;</pre></div><p class="paragraph"/>
이 예제의 loginCheck 필터는 before 인터셉터를 사용한다. 이 인터셉터는 사용자의 세션이 열려있고 login 액션으로 리다이렉트시켜야 하는지를 검사한다. false가 반환되면 액션이 실행되지 않는다는 것을 기억하라.
<h2><a name="6.6.3 Filter Capabilities">6.6.3 Filter Capabilities</a></h2>필터는 <a href="../guide/single.html#6.1 Controllers" class="guide">controllers</a>, 태그 라이브러리(<a href="../guide/single.html#6.3 Tag Libraries" class="guide">tag libraries</a>), 어플리케이션 컨텍스트에서 사용되는 모든 프로퍼티들을 지원한다:
<ul class="star">
<li><a href="../ref/Controllers/request.html" class="controllers">request</a> - HttpServletRequest 객체</li>
<li><a href="../ref/Controllers/response.html" class="controllers">response</a> - HttpServletResponse 객체</li>
<li><a href="../ref/Controllers/session.html" class="controllers">session</a> - HttpSession 객체</li>
<li><a href="../ref/Controllers/servletContext.html" class="controllers">servletContext</a> - ServletContext 객체</li>
<li><a href="../ref/Controllers/flash.html" class="controllers">flash</a> - flash 객체</li>
<li><a href="../ref/Controllers/params.html" class="controllers">params</a> - 요청 파라미터 객체</li>
<li><a href="../ref/Controllers/actionName.html" class="controllers">actionName</a> - 가로챈 액션의 이름</li>
<li><a href="../ref/Controllers/controllerName.html" class="controllers">controllerName</a> - 가로챈 컨트롤러의 이름</li>
<li><a href="../ref/Controllers/grailsApplication.html" class="controllers">grailsApplication</a> - 현재 실행중인 Grails 어플리케이션</li>
<li><a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/context/ApplicationContext.html" class="api">applicationContext</a> -  ApplicationContext 객체</li>
</ul><p class="paragraph"/>하지만 필터는 컨트롤러나 태그 라이브러리들에서 사용 가능한 모든 메소드들이 아니라 일부분만 지원한다:
<ul class="star">
<li><a href="../ref/Controllers/redirect.html" class="controllers">redirect</a> - 컨트롤러와 다른 액션으로 리다이렉트시키기 위해 사용</li>
<li><a href="../ref/Controllers/render.html" class="controllers">render</a> - 사용자 정의 응답을 렌더링하기 위해 사용한다</li>
</ul><p class="paragraph"/><h2><a name="6.7 Ajax">6.7 Ajax</a></h2>Ajax는 Asynchronous Javascript and XML의 약어이고 좀 더 풍부한(rich) 웹 어플리케이션을 만들 수 있게 해주었다. 일반적으로 이런 형태의 어플리케이션에는 <a href="http://www.ruby-lang.org/나" target="blank">Ruby</a> <a href="http://groovy.codehaus.org" target="blank">Groovy</a> 같은 언어를 사용하는 애자일하고 동적인 프레임웍이 더 적합하다. Grails는 Ajax 태그 라이브러리를 통해서 Ajax 어플리케이션을 쉽게 만들 수 있도록 돕는다. 이에 대한 모든 정보는 태그 라이브러리 레퍼런스를 참고하라.
<h2><a name="6.7.1 Ajax using Prototype">6.7.1 Ajax using Prototype</a></h2>Grails에는 기본적으로 <a href="http://www.prototypejs.org/" target="blank">Prototype</a> 라이브러리가 탑재되어 있다. 그러나 플러그인 시스템(<a href="../guide/single.html#12. Plug-ins" class="guide">Plug-in system</a>)을 통해서 <a href="http://dojotoolkit.org/," target="blank">Dojo</a> <a href="http://developer.yahoo.com/yui/," target="blank">Yahoo UI</a> <a href="http://code.google.com/webtoolkit/" target="blank">Google Web Toolkit</a> 같은 다른 프레임웍도 지원한다.<p class="paragraph"/>이 절에서는 Prototype을 위해 Grails가 지원하는 것들에 대해 다룬다. 페이지의 &#60;head&#62; 태그에 다음의 라인을 추가하는 것으로 시작한다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:javascript library=<span class="xml&#45;quote">"prototype"</span> /&#62;</span></pre></div><p class="paragraph"/><a href="../ref/Tags/javascript.html" class="tags">javascript</a> 태그를 사용하면 자동으로 올바른 Prototype을 사용할 수 있다. 만약 <a href="http://script.aculo.us/" target="blank">Scriptaculous</a> 도 필요하면 다음과 같이 할 수 있다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:javascript library=<span class="xml&#45;quote">"scriptaculous"</span> /&#62;</span></pre></div><p class="paragraph"/>
<h2><a name="6.7.1.1 Remoting Linking">6.7.1.1 Remoting Linking</a></h2>원격에 있는 내용을 로드하는 방법은 매우 다양하다. <a href="../ref/Tags/remoteLink.html" class="tags">remoteLink</a> 태그를 사용하는 것이 가장 일반적인 방법이다. 이 태그는 HTML anchor 태그를 생성하고 비동기적으로 요청한다. 추가적으로 엘리먼트에 응답도 설정한다. remote link를 만드는 가장 단순한 방법은 다음과 같다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:remoteLink action=<span class="xml&#45;quote">"delete"</span> id=<span class="xml&#45;quote">"1"</span>&#62;</span>Delete Book<span class="xml&#45;tag">&#60;/g:remoteLink&#62;</span></pre></div><p class="paragraph"/>이 링크는 현 컨트롤러의 delete 액션에 값이 “1”인 id를 비동기적으로 요청을 보낸다.
<h2><a name="6.7.1.2 Updating Content">6.7.1.2 Updating Content</a></h2>이 것은 굉장하지만 보통 무슨 일이 일어났는지에 대한 피드백을 사용자에게 주는 것이 필요하다:<p class="paragraph"/><div class="code"><pre>def delete = &#123;
      def b = Book.get( params.id )
      b.delete()
      render <span class="java&#45;quote">"Book $&#123;b.id&#125; was deleted"</span>
&#125;</pre></div><p class="paragraph"/>GSP 코드:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;div id=<span class="xml&#45;quote">"message"</span>&#62;</span><span class="xml&#45;tag">&#60;/div&#62;</span>
<span class="xml&#45;tag">&#60;g:remoteLink action=<span class="xml&#45;quote">"delete"</span> id=<span class="xml&#45;quote">"1"</span> update=<span class="xml&#45;quote">"message"</span>&#62;</span>Delete Book<span class="xml&#45;tag">&#60;/g:remoteLink&#62;</span></pre></div><p class="paragraph"/>이 예제는 액션을 호출하고 “Book 1 was deleted”라는 응답을 message div 태그의 내용으로 설정할 것이다. 이 것은 태그의 update 속성이 해주는 일이고 실패했을 때 업데이트돼야 하는 것도 명시할 수 있다:<p class="paragraph"/>
<div class="code"><pre><span class="xml&#45;tag">&#60;div id=<span class="xml&#45;quote">"message"</span>&#62;</span><span class="xml&#45;tag">&#60;/div&#62;</span>
<span class="xml&#45;tag">&#60;div id=<span class="xml&#45;quote">"error"</span>&#62;</span><span class="xml&#45;tag">&#60;/div&#62;</span>
<span class="xml&#45;tag">&#60;g:remoteLink action=<span class="xml&#45;quote">"delete"</span> id=<span class="xml&#45;quote">"1"</span>
              update=<span class="xml&#45;quote">"&#91;success:'message',failure:'error'&#93;"</span>&#62;</span>Delete Book<span class="xml&#45;tag">&#60;/g:remoteLink&#62;</span></pre></div><p class="paragraph"/>이 예제의 error div는 요청이 실패하면 업데이트된다.
<h2><a name="6.7.1.3 Remote Form Submission">6.7.1.3 Remote Form Submission</a></h2>HTML 폼을 비동기적으로 제출하는 방법도 두 가지이다. 첫째는 <a href="../ref/Tags/formRemote.html" class="tags">formRemote</a> 태그를 사용하는 것이다. 이 태그는 <a href="../ref/Tags/remoteLink.html" class="tags">remoteLink</a> 태그의 속성과 유사한 속성들을 가지고 있다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:formRemote url=<span class="xml&#45;quote">"&#91;controller:'book',action:'delete'&#93;"</span> update=<span class="xml&#45;quote">"&#91;success:'message',failure:'error'&#93;"</span>&#62;</span>
       <span class="xml&#45;tag">&#60;input type=<span class="xml&#45;quote">"hidden"</span> name=<span class="xml&#45;quote">"id"</span> value=<span class="xml&#45;quote">"1"</span> /&#62;</span>
       <span class="xml&#45;tag">&#60;input type=<span class="xml&#45;quote">"submit"</span> value=<span class="xml&#45;quote">"Delete Book!"</span> /&#62;</span>
<span class="xml&#45;tag">&#60;/g:formRemote &#62;</span></pre></div><p class="paragraph"/>둘째로 <a href="../ref/Tags/submitToRemote.html" class="tags">submitToRemote</a> 태그를 사용하여 submit 버튼을 만들 수 있다. 이 태그의 버튼을 클릭하면 원격에 제출되지만 액션을 사용하지 않는 버튼도 만들 수 있다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;form action=<span class="xml&#45;quote">"delete"</span>&#62;</span>
       <span class="xml&#45;tag">&#60;input type=<span class="xml&#45;quote">"hidden"</span> name=<span class="xml&#45;quote">"id"</span> value=<span class="xml&#45;quote">"1"</span> /&#62;</span>
       <span class="xml&#45;tag">&#60;g:submitToRemote action=<span class="xml&#45;quote">"delete"</span> update=<span class="xml&#45;quote">"&#91;success:'message',failure:'error'&#93;"</span> /&#62;</span>
<span class="xml&#45;tag">&#60;/form&#62;</span></pre></div><p class="paragraph"/><h2><a name="6.7.1.4 Ajax Events">6.7.1.4 Ajax Events</a></h2>이벤트가 발생하면 자바스크립트가 호출되도록 할 수 있다. 모든 이벤트는 "on"으로 시작하고 적당한 유저에게 피드백을 주거나 다른 액션이 실행되도록 한다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:remoteLink action=<span class="xml&#45;quote">"show"</span> 
              id=<span class="xml&#45;quote">"1"</span> 
              update=<span class="xml&#45;quote">"success"</span> 
              onLoading=<span class="xml&#45;quote">"showProgress()"</span> 
              onComplete=<span class="xml&#45;quote">"hideProgress()"</span>&#62;</span>Show Book 1<span class="xml&#45;tag">&#60;/g:remoteLink&#62;</span></pre></div><p class="paragraph"/>이 예제는 진행 바가 보여지도록 "showProgress()" 함수를 실행하거나 다른 적절한 함수가 실행할 것이다. 가능한 이벤트들은 다음과 같다:
<ul class="star">
<li><code>onSuccess</code>  - 성공하면 호출되는 자바스크립트 함수</li>
<li><code>onFailure</code>  - 실패하면 호출되는 자바스크립트 함수</li>
<li><code>on_ERROR_CODE</code>  - 명시한 에러 코드(예 - on404=“alert('not found!')”)를 처리하기 하기위한 자바스크립트 함수</li>
<li><code>onUninitialized</code>  - Ajax 엔진이 초기화하는데 실패하면 호출되는 자바스크립트 함수</li>
<li><code>onLoading</code>  - 원격 함수(remote function)가 응답을 로딩하기 시작하면 호출되는 자바스크립트 함수</li>
<li><code>onLoaded</code>  - 원격 함수가 응답을 모두 로딩하면 호출되는 자바스크립트 함수</li>
<li><code>onComplete</code>  - 원격 함수가 업데이트를 포함한 모든 일을 완료하면 호출되는 자바스크립트 함수</li>
</ul><p class="paragraph"/>XmlHttpRequest 객체를 참조해야 한다면 암묵적 event 파라미터 e를 사용할 수 있다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:javascript&#62;</span>
   function fireMe(e) &#123;
	   alert(<span class="xml&#45;quote">"XmlHttpRequest = "</span> + e)
   &#125;
&#125;
<span class="xml&#45;tag">&#60;/g:javascript&#62;</span>
<span class="xml&#45;tag">&#60;g:remoteLink action=<span class="xml&#45;quote">"example"</span> 
              update=<span class="xml&#45;quote">"success"</span> 
              onSuccess=<span class="xml&#45;quote">"fireMe(e)"</span>&#62;</span>Ajax Link<span class="xml&#45;tag">&#60;/g:remoteLink&#62;</span></pre></div><p class="paragraph"/><h2><a name="6.7.2 Ajax with Dojo">6.7.2 Ajax with Dojo</a></h2><a href="http://dojotoolkit.org/" target="blank">Dojo</a> 플러그인을 Grails에 추가하여 사용한다. 터미널 윈도우를 띄우고 프로젝트 루트 디렉토리에서 다음과 같은 명령어를 사용하여 플러그인을 설치한다:<p class="paragraph"/><div class="code"><pre>grails install&#45;plugin dojo</pre></div><p class="paragraph"/>이 것은 현재 지원하는 Dojo버전을 다운로드하고 Grails 프로젝트에 설치할 것이다. 그리고 페이지에 다음과 같이 참조 태그를 추가해서 사용할 수 있다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:javascript library=<span class="xml&#45;quote">"dojo"</span> /&#62;</span></pre></div><p class="paragraph"/>현재 <a href="../ref/Tags/remoteLink.html" class="tags">remoteLink</a>, <a href="../ref/Tags/formRemote.html" class="tags">formRemote</a>, <a href="../ref/Tags/submitToRemote.html" class="tags">submitToRemote</a>같은 모든 Grails 태그는 Dojo에서도 잘 동작한다.
<h2><a name="6.7.3 Ajax with GWT">6.7.3 Ajax with GWT</a></h2>Grails는 <a href="http://code.google.com/webtoolkit/" target="blank">Google Web Toolkit</a> 도 지원한다. Grails wiki에서 이 플러그인에 대한 문서(<a href="http://grails.org/GWT+Plugin" target="blank">documentation</a>)를 찾을 수 있다.
<h2><a name="6.7.4 Ajax on the Server">6.7.4 Ajax on the Server</a></h2>Ajax의 X는 XML을 의미하고 Ajax를 구현하는 방법은 매우 다양하지만 일반적으로 다음과 같이 나눌 수 있다:
<ul class="star">
<li>내용을 위한 Ajax(Content Centric Ajax) - 단지 페이지를 업데이트하기 위해 HTML의 결과만을 사용한다.</li>
<li>데이터를 위한 Ajax(Data Centric Ajax) - 서버에서는 XML이나 JSON형식의 응답을 보내고 페이지를 프로그램적으로 업데이트한다.</li>
<li>스크립트를 위한 Ajax(Script Centric Ajax) - 서버는 바로 실행될 자바스크립트를 보낸다.</li>
</ul><p class="paragraph"/><a href="../guide/single.html#6.7 Ajax" class="guide">Ajax</a> 절의 예제들은 대부분 페이지를 업데이트하는 내용을 위한 Ajax에 대해 다룬다. 그러나 데이터나 스크립트를 위한 Ajax도 필요할 것이다. 이 문서는 그런 스타일의 Ajax도 다룬다.<p class="paragraph"/><h4>Content Centric Ajax(내용을 위한 Ajax)</h4><p class="paragraph"/>내용을 위한 Ajax는 서버에서 HTML을 전송하는 것을 말한다. 이 것은 일반적으로 <a href="../ref/Controllers/render.html" class="controllers">render</a> 메소드로 템플릿을 렌더링함으로써 이루어진다:<p class="paragraph"/><div class="code"><pre>def showBook = &#123;
	def b = Book.get(params.id)<p class="paragraph"/>	render(template:<span class="java&#45;quote">"bookTemplate"</span>, model:&#91;book:b&#93;)
&#125;</pre></div><p class="paragraph"/>클라이언트에서는 <a href="../ref/Tags/remoteLink.html" class="tags">remoteLink</a> 태그로 이 속성을 호출한다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:remoteLink action=<span class="xml&#45;quote">"showBook"</span> id=<span class="xml&#45;quote">"$&#123;book.id&#125;"</span> update=<span class="xml&#45;quote">"book$&#123;book.id&#125;"</span>&#62;</span>Update Book<span class="xml&#45;tag">&#60;/g:remoteLink&#62;</span>
<span class="xml&#45;tag">&#60;div id=<span class="xml&#45;quote">"book$&#123;book.id&#125;"</span>&#62;</span>
   <span class="xml&#45;comment">&#60;!&#45;&#45;existing book mark&#45;up &#45;&#45;&#62;</span>
<span class="xml&#45;tag">&#60;/div&#62;</span></pre></div><p class="paragraph"/><h4>Data Centric Ajax with JSON(Ajax 데이터에 JSON 사용하기)</h4><p class="paragraph"/>데이터를 위한 Ajax는 일반적으로 클라이언트에서 이 응답을 처리한 후 프로그램으로 페이지를 업데이트 하는 것을 말한다. Grails에서 JSON 응답을 사용하기 위해 Grails의 JSON 마샬링(<a href="../guide/single.html#6.1.7 XML and JSON Responses" class="guide">JSON marshaling</a>) 기능을 사용 할 수 있다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> grails.converters.&#42;<p class="paragraph"/>def showBook = &#123;
	def b = Book.get(params.id)<p class="paragraph"/>    render b as JSON	
&#125;</pre></div><p class="paragraph"/>그리고 클라이언트에서는 Ajax 이벤트 핸들러를 사용하여 JSON 요청을 파싱한다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:javascript&#62;</span>
function updateBook(e) &#123;
	var book = eval(<span class="xml&#45;quote">"("</span>+e.responseText+<span class="xml&#45;quote">")"</span>) // evaluate the JSON
	$(<span class="xml&#45;quote">"book"</span>+book.id+<span class="xml&#45;quote">"_title"</span>).innerHTML = book.title
&#125;
<span class="xml&#45;tag">&#60;g:javascript&#62;</span>
<span class="xml&#45;tag">&#60;g:remoteLink action=<span class="xml&#45;quote">"test"</span> update=<span class="xml&#45;quote">"foo"</span> onSuccess=<span class="xml&#45;quote">"updateBook(e)"</span>&#62;</span>Update Book<span class="xml&#45;tag">&#60;/g:remoteLink&#62;</span>
<span class="xml&#45;tag">&#60;g:set var=<span class="xml&#45;quote">"bookId"</span>&#62;</span>book$&#123;book.id&#125;<span class="xml&#45;tag">&#60;/g:set&#62;</span>
<span class="xml&#45;tag">&#60;div id=<span class="xml&#45;quote">"$&#123;bookId&#125;"</span>&#62;</span>
	<span class="xml&#45;tag">&#60;div id=<span class="xml&#45;quote">"$&#123;bookId&#125;_title"</span>&#62;</span>The Stand<span class="xml&#45;tag">&#60;/div&#62;</span>
<span class="xml&#45;tag">&#60;/div&#62;</span></pre></div><p class="paragraph"/><h4>Data Centric Ajax with XML(Ajax 데이터에 XML 사용하기)</h4><p class="paragraph"/>서버에서 XML을 사용하는 것도 매우 쉽다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> grails.converters.&#42;<p class="paragraph"/>def showBook = &#123;
	def b = Book.get(params.id)<p class="paragraph"/>    render b as XML	
&#125;</pre></div><p class="paragraph"/>하지만 클라이언트에서 DOM을 처리해야 하기 때문에 좀 더 복잡하다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:javascript&#62;</span>
function updateBook(e) &#123;
	var xml = e.responseXML
	var id = xml.getElementsByTagName(<span class="xml&#45;quote">"book"</span>).getAttribute(<span class="xml&#45;quote">"id"</span>)
	$(<span class="xml&#45;quote">"book"</span>+id+<span class="xml&#45;quote">"_title"</span>)=xml.getElementsByTagName(<span class="xml&#45;quote">"title"</span>)&#91;0&#93;.textContent
&#125;
<span class="xml&#45;tag">&#60;g:javascript&#62;</span>
<span class="xml&#45;tag">&#60;g:remoteLink action=<span class="xml&#45;quote">"test"</span> update=<span class="xml&#45;quote">"foo"</span> onSuccess=<span class="xml&#45;quote">"updateBook(e)"</span>&#62;</span>Update Book<span class="xml&#45;tag">&#60;/g:remoteLink&#62;</span>
<span class="xml&#45;tag">&#60;g:set var=<span class="xml&#45;quote">"bookId"</span>&#62;</span>book$&#123;book.id&#125;<span class="xml&#45;tag">&#60;/g:set&#62;</span>
<span class="xml&#45;tag">&#60;div id=<span class="xml&#45;quote">"$&#123;bookId&#125;"</span>&#62;</span>
	<span class="xml&#45;tag">&#60;div id=<span class="xml&#45;quote">"$&#123;bookId&#125;_title"</span>&#62;</span>The Stand<span class="xml&#45;tag">&#60;/div&#62;</span>
<span class="xml&#45;tag">&#60;/div&#62;</span></pre></div><p class="paragraph"/><h4>Script Centric Ajax with JavaScript(스크립트를 위한 Ajax에서 자바스크립트 사용하기)</h4><p class="paragraph"/>스크립트를 위한 Ajax는 실제로 클라이언트에서 실행할 수 있는 자바스크트를 전송한다. 다음은 이 것에 대한 예제이다:<p class="paragraph"/><div class="code"><pre>def showBook = &#123;
	def b = Book.get(params.id)<p class="paragraph"/>    response.contentType = <span class="java&#45;quote">"text/javascript"</span>
    <span class="java&#45;object">String</span> title = b.title.encodeAsJavascript()
    render <span class="java&#45;quote">"&#36;('book$&#123;b.id&#125;_title')='$&#123;title&#125;'"</span>
&#125;</pre></div><p class="paragraph"/>contentType을 text/javascript로 설정해야 하는 것을 기억하라. 만약 Prototype을 사용하고 있다면 contentType을 설정한 것 때문에 반환된 Javacript가 자동으로 실행된다.<p class="paragraph"/>클라이언트가 수정되서 서버가 망가지길 바라지 않는다면 클라이언트에서 약속된agreed API를 사용해야 한다. 이 것은 Rails의 RJS같은 것이 필요한 이유이다. Grails에는 RJS같은 기능은 없지만 동적 자바스크립트 플러그인(<a href="http://grails.org/Dynamic+Javascript+Plugin" target="blank">Dynamic JavaScript Plug-in</a>)으로 유사한 일을 할 수 있다.<p class="paragraph"/><h2><a name="6.8 Content Negotiation">6.8 Content Negotiation</a></h2>Grails는 HTTP의 Accept 헤더, 명시적 포멧의 요청 파라미터(explicit format request parameter), 매핑된 URI의 확장자을 사용하여 <a href="http://en.wikipedia.org/wiki/Content_negotiation" target="blank">Content negotiation</a>을 지원한다.<p class="paragraph"/><h4>Configuring Mime Types(마임타입 설정하기)</h4><p class="paragraph"/>Content Negotiation을 처리하는 법을 다루기 전에 Grails에 어떤 컨텐트 타입에 적용되길 바라는지 알려주어야 한다. Grails는 기본적으로 grails-app/conf/Config.groovy 파일의 grails.mime.types에 많은 컨텐트 타입이 설정되어 있다:<p class="paragraph"/><div class="code"><pre>grails.mime.types = &#91; xml: &#91;'text/xml', 'application/xml'&#93;,
                      text: 'text&#45;plain',
                      js: 'text/javascript',
                      rss: 'application/rss+xml',
                      atom: 'application/atom+xml',
                      css: 'text/css',
                      cvs: 'text/csv',
                      all: '&#42;/&#42;',
                      json: 'text/json',
                      html: &#91;'text/html','application/xhtml+xml'&#93;
                    &#93;</pre></div><p class="paragraph"/>이 설정은 Grails가 'text/xml, 'application/xml'을 포함하는 요청 형식을 xml로 감지할 수 있게 해준다. Grail는 단순히 맵에 새로운 내용을 추가하는 것만으로 새로운 컨텐트 타입을 감지할 수 있다.<p class="paragraph"/><h4>Content Negotiation using the Accept header(Accept 헤더를 사용한 Content Negotiation)</h4><p class="paragraph"/>모든 HTTP 요청에는 무슨 미디어 타입(마임 타입이나)인지를 정의한 <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html" target="blank">Accept</a> 헤더가 있다. 이 헤더는 클라이언트에서 받아 들일 수 있는 형식을 의미한다. 예전 브라우져들의 Accept 헤더 내용은 일반적으로 다음과 같다:<p class="paragraph"/><div class="code"><pre>&#42;/&#42;</pre></div><p class="paragraph"/>이 것은 단순히 모든 것을 의미한다. 하지만 요즘의 브라우져들은 다음과 같이 좀 더 유용한 정보를 보낸다(다음의 예는 Firefox의 Accept 헤더이다):<p class="paragraph"/><div class="code"><pre>text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,&#42;/&#42;;q=0.5</pre></div><p class="paragraph"/>Grails는 이 정보를 파싱하고 최선의(prefered) <a href="../ref/Servlet API/request.html" class="servletAPI">request</a> 형식을 요청 객체의 프로퍼티에 추가한다. 이 예제는 다음과 같은 assert문을 통과할 것이다:<p class="paragraph"/><div class="code"><pre>assert 'html' == request.format</pre></div><p class="paragraph"/>text/html 미디어 타입은 “quality” 비율이 0.9이다. 따라서 가장 우선순위가 높다. 예전 브라우저를 사용하고 있다면 약간 다른 결과를 얻게 될 것이다:<p class="paragraph"/><div class="code"><pre>assert 'all' == request.format</pre></div><p class="paragraph"/>이 경우 클라이언트가 '모든' 포멧을 수용할 수 있다는 것을 의미한다. 다양한 요청을 처리하기 위해 컨트롤러(<a href="../guide/single.html#6.1 Controllers" class="guide">Controllers</a>)에서 <a href="../ref/Controllers/withFormat.html" class="controllers">withFormat</a> 메소드를 사용한다. 이 메소드는 switch문처럼 동작한다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> grails.converters.&#42;<p class="paragraph"/>class BookController &#123;
	def books
	def list = &#123;
		<span class="java&#45;keyword">this</span>.books = Book.list()
		withFormat &#123;
			html bookList:books
			js &#123; render <span class="java&#45;quote">"alert('hello')"</span> &#125; 
			xml &#123; render books as XML &#125;
		&#125;
	&#125;
&#125;</pre></div><p class="paragraph"/>최선의 포멧이 html이라면 Grails는 html()만 호출 할 것이다. 이 것은 Grails가 grails-app/views/books/list.html.gsp나 grails-app/views/books/list.gsp를 찾도록 만든다. 만약 이 포멧이 xml이라면 클로저가 실행되서 XML로 응답한다.<p class="paragraph"/>예전 브라우저들처럼 Accept 헤더가 모든 형식인 경우에는 withFormat 메소드에 정의한 순서대로 포멧이 선택되어 호출된다. 위의 예제에서는 html 메소드가 먼저 실행될 것이다.<p class="paragraph"/><blockquote class="note">
액션의 <a href="../ref/Controllers/withFormat.html" class="controllers">withFormat</a> 메소드가 반환하는 값이 다음에 무엇을 해야하는지를 의미하기 때문에 컨트롤러의 액션에서 마지막에 무엇이 호출되는지를 분명하게 해야 한다.
</blockquote><p class="paragraph"/><h4>Content Negotiation with the format Request Parameter(포멧 요청 파라미터를 사용하는 Content Negotiation)</h4><p class="paragraph"/>요청 헤더를 처리하는 것이 싫다면 덮어쓰도록(override) 요청 파라미터에 다음과 같은 형식으로 명시할 수 있다:<p class="paragraph"/><div class="code"><pre>/book/list?format=xml</pre></div><p class="paragraph"/>그리고 이 파라미터를 URL 매핑(<a href="../guide/single.html#6.4 URL Mappings" class="guide">URL Mappings</a>)에도 정의할 수 있다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;quote">"/book/list"</span>(controller:<span class="java&#45;quote">"book"</span>, action:<span class="java&#45;quote">"list"</span>) &#123;
	format = <span class="java&#45;quote">"xml"</span>
&#125;</pre></div><p class="paragraph"/><h4>Content Negotiation with URI Extensions(URI의 확장자를 이용한 Content Negotiation)</h4><p class="paragraph"/>Grails는 URI의 확장자를 이용한 Content Negotiation도 지원한다. 예를 들어 다음과 같은 URI가 있을 때:<p class="paragraph"/><div class="code"><pre>/book/list.xml</pre></div><p class="paragraph"/>Grails는 확장자에 따라 컨텐트 포멧을 xml로 설정하고 확장자를 잘라버린 후 /book/list 메소드에 매핑시킨다. 이 것은 아무것도 설정하지 않고 기본적으로 사용가능하다. 이 기능을 끄고 싶다면 grails-app/conf/Config.groovy 파일의 grails.mime.file.extensions 프로퍼티를 false로 설정해야 한다:<p class="paragraph"/><div class="code"><pre>grails.mime.file.extensions = <span class="java&#45;keyword">false</span></pre></div><p class="paragraph"/><h4>Testing Content Negotiation(Content Negotiation 테스트하기)</h4><p class="paragraph"/>통합(integration) 테스트시 요청 헤더를 조작하여 Content Negotiation을 테스트(<a href="../guide/single.html#9. Testing" class="guide">Testing</a>)할 수 있다:<p class="paragraph"/><div class="code"><pre>void testJavascriptOutput() &#123;
	def controller = <span class="java&#45;keyword">new</span> TestController()
	controller.request.addHeader <span class="java&#45;quote">"Accept"</span>, <span class="java&#45;quote">"text/javascript, text/html, application/xml, text/xml, &#42;/&#42;"</span><p class="paragraph"/>	controller.testAction()
	assertEquals <span class="java&#45;quote">"alert('hello')"</span>, controller.response.contentAsString
&#125;</pre></div><p class="paragraph"/>다른 방법으로 format 파라미터를 직접 설정하여 동일한 효과를 낼 수 있다:<p class="paragraph"/><div class="code"><pre>void testJavascriptOutput() &#123;
	def controller = <span class="java&#45;keyword">new</span> TestController()
	controller.params.format = 'js'<p class="paragraph"/>	controller.testAction()
	assertEquals <span class="java&#45;quote">"alert('hello')"</span>, controller.response.contentAsString
&#125;</pre></div>
<h1><a name="7. Validation">7. Validation</a></h1>Grails의 유효성 검사 기능은 Spring의 <a href="http://static.springframework.org/spring/docs/2.0.x/api/org/springframework/validation/package-summary.html" target="blank">Validator API</a>와 바인딩 기능에 의존한다. 하지만 Grails는 이 것을 더 발전시켜서 제약조건을 정의하는 통합된 방법을 제공한다.<p class="paragraph"/>Grails의 제약조건은 유효성 검사 규칙을 명시하는 것을 말한다. 대부분의 경우 도메인 클래스(<a href="../guide/single.html#5. Object Relational Mapping (GORM)" class="guide">domain classes</a>)에 정의하지만 URL 매핑(<a href="../guide/single.html#6.4 URL Mappings" class="guide">URL Mappings</a>)과 일반 객체(<a href="../guide/single.html#6.1.9 Command Objects" class="guide">Command Objects</a>)에도 정의할 수 있다.<p class="paragraph"/>
<h2><a name="7.1 Declaring Constraints">7.1 Declaring Constraints</a></h2>제약 조건를 정의하기 위해서는 도메인 클래스의 <a href="../ref/Domain Classes/constraints.html" class="domainClasses">constraints</a> 속성에 코드 블럭을 할당한다:<p class="paragraph"/><div class="code"><pre>class User &#123;
    <span class="java&#45;object">String</span> login
    <span class="java&#45;object">String</span> password
    <span class="java&#45;object">String</span> email
    <span class="java&#45;object">Integer</span> age<p class="paragraph"/>    <span class="java&#45;keyword">static</span> constraints = &#123;
	  &#8230;
    &#125;
&#125;</pre></div><p class="paragraph"/>constraints 블럭에 속성의 이름과 일치하는 메소드를 호출하고 네임드 파라미터를 사용하여 제약조건을 명시한다:<p class="paragraph"/><div class="code"><pre>class User &#123;
    ...<p class="paragraph"/>    <span class="java&#45;keyword">static</span> constraints = &#123;
        login(size:5..15, blank:<span class="java&#45;keyword">false</span>, unique:<span class="java&#45;keyword">true</span>)
        password(size:5..15, blank:<span class="java&#45;keyword">false</span>)
        email(email:<span class="java&#45;keyword">true</span>, blank:<span class="java&#45;keyword">false</span>)
        age(min:18, nullable:<span class="java&#45;keyword">false</span>)
    &#125;
&#125;</pre></div><p class="paragraph"/>이 예제의 login 속성 값은 5에서 15 사이로 문자열의 길이를 제한하고, 공백이 될 수 없고, 유일(unique)해야 한다. 그 뿐만 아니라 password, email, age 속성에도 제약조건을 정의했다.<p class="paragraph"/>
<blockquote class="note">
이용가능한 제약조건에 대한 내용은 레퍼런스 가이드를 참고하라.
</blockquote><h2><a name="7.2 Validating Constraints">7.2 Validating Constraints</a></h2><h4>Validation Basics(유효성 검사의 기초)</h4><p class="paragraph"/>도메인 클래스의 유효성을 검사하기 위해 모든 인스턴스의 <a href="../ref/Domain Classes/validate.html" class="domainClasses">validate</a> 메소드를 호출할 수 있다:<p class="paragraph"/><div class="code"><pre>def user =  <span class="java&#45;keyword">new</span> User(params)<p class="paragraph"/><span class="java&#45;keyword">if</span>(user.validate()) &#123;
    // <span class="java&#45;keyword">do</span> something with user
&#125;
<span class="java&#45;keyword">else</span> &#123;
    user.errors.allErrors.each &#123;
        println it
    &#125;
&#125;</pre></div><p class="paragraph"/>도메인 클래스의 errors 속성은 Spring의 <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/validation/Errors.html" class="api">Errors</a> 인터페이스의 인스턴스이다. Errors 인터페이스는 유효성 검사의 에러를 살펴보는(navigate) 방법과 원래 값을 얻어 오는 방법을 제공한다.<p class="paragraph"/><h4>Validation Phases(유효성 검사 시점)</h4><p class="paragraph"/>Grails의 유효성 검사는 본질적으로 두 가지로 나뉜다. 먼저 다음과 같이 인스턴스에 요청 파리미터를 바인딩(<a href="../guide/single.html#6.1.6 Data Binding" class="guide">data binding</a>)할 때 유효성이 검사된다:<p class="paragraph"/><div class="code"><pre>def user = <span class="java&#45;keyword">new</span> User(params)</pre></div><p class="paragraph"/>이 시점에서 String을 Date로 변환하는 것 같은 형 변환 에러가 errors 속성에 이미 넣어진다. Errors API를 이용해 이 에러를 확인하고 원래 값을 얻을 수 있다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">if</span>(user.hasErrors()) &#123;
	<span class="java&#45;keyword">if</span>(user.hasFieldError(<span class="java&#45;quote">"login"</span>)) &#123;
		println user.getFieldError(<span class="java&#45;quote">"login"</span>).rejectedValue
	&#125;
&#125;</pre></div><p class="paragraph"/><a href="../ref/Domain Classes/validate.html" class="domainClasses">validate</a>나 <a href="../ref/Domain Classes/save.html" class="domainClasses">save</a>를 호출될 때도 유효성이 검사된다. 이 때 <a href="../ref/Domain Classes/constraints.html" class="domainClasses">constraints</a> 속성에 정의한 조건에 만족하는지 검사된다. 기본적으로 영속적 <a href="../ref/Domain Classes/save.html" class="domainClasses">save</a> 메소드는 유효성을 검사하기 때문에 다음과 같이 코드를 작성할 수 있다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">if</span>(user.save()) &#123;
    <span class="java&#45;keyword">return</span> user
&#125;
<span class="java&#45;keyword">else</span> &#123;
    user.errors.allErrors.each &#123;
        println it
    &#125;
&#125;</pre></div><p class="paragraph"/><h2><a name="7.3 Validation on the Client">7.3 Validation on the Client</a></h2><h4>Displaying Errors(에러 출력하기)</h4><p class="paragraph"/>보통 유효성 검사 에러가 발생하면 그 뷰를 다시 보여줘야 할 것이고 에러를 출력할 어떤 방법이 필요하다. Grails에는 에러를 처리하는 태그들이 많이 있다. <a href="../ref/Tags/renderErrors.html" class="tags">renderErrors</a>를 사용하여 단순히 에러의 목록을 출력할 수 있다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:renderErrors bean=<span class="xml&#45;quote">"$&#123;user&#125;"</span> /&#62;</span></pre></div><p class="paragraph"/><a href="../ref/Tags/hasErrors.html" class="tags">hasErrors</a>와 <a href="../ref/Tags/eachError.html" class="tags">eachError</a>를 사용하여 상세하게 제어할 수도 있다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:hasErrors bean=<span class="xml&#45;quote">"$&#123;user&#125;"</span>&#62;</span>
  <span class="xml&#45;tag">&#60;ul&#62;</span>
   <span class="xml&#45;tag">&#60;g:eachError var=<span class="xml&#45;quote">"err"</span> bean=<span class="xml&#45;quote">"$&#123;user&#125;"</span>&#62;</span>
       <span class="xml&#45;tag">&#60;li&#62;</span>$&#123;err&#125;<span class="xml&#45;tag">&#60;/li&#62;</span> 
   <span class="xml&#45;tag">&#60;/g:eachError&#62;</span>
  <span class="xml&#45;tag">&#60;/ul&#62;</span>
<span class="xml&#45;tag">&#60;/g:hasErrors&#62;</span></pre></div><p class="paragraph"/><h4>Highlighting Errors(에러 꾸미기)</h4><p class="paragraph"/>잘못된 값이 입력되면 붉은 박스나 어떤 지시자를 사용하여 꾸미는 것이 매우 유용하다. 이 것은 <a href="../ref/Tags/hasErrors.html" class="tags">hasErrors</a>를 메소드처럼 호출하여 처리한다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;div class='value $&#123;hasErrors(bean:user,field:'login','errors')&#125;'&#62;</span>
   <span class="xml&#45;tag">&#60;input type=<span class="xml&#45;quote">"text"</span> name=<span class="xml&#45;quote">"login"</span> value=<span class="xml&#45;quote">"$&#123;fieldValue(bean:user,field:'login')&#125;"</span>/&#62;</span>
<span class="xml&#45;tag">&#60;/div&#62;</span></pre></div><p class="paragraph"/>이 코드가 하는 일은 user Bean과 관련된 login 필드에 에러가 있는지 검사하고 에러가 있으면 div 태그의 class 속성에 “errors”를 추가한다. 그래서 CSS 규칙을 정의하여 div 태그를 꾸밀 수 있다.<p class="paragraph"/><h4>Retrieving Input Values(입력 값 가져오기)</h4><p class="paragraph"/>각각의 에러는 실질적으로 Spring의 <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/validation/FieldError.html" class="api">FieldError</a> 클래스의 인스턴스이다. 이 인스턴스에는 원래 값이 저장돼 있다. 이 것은 <a href="../ref/Tags/fieldValue.html" class="tags">fieldValue</a> 태그를 통해서 사용자가 입력 값을 고칠 수 있도록 에러 값을 재사용할 수 있다.<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;input type=<span class="xml&#45;quote">"text"</span> name=<span class="xml&#45;quote">"login"</span> value=<span class="xml&#45;quote">"$&#123;fieldValue(bean:user,field:'login')&#125;"</span>/&#62;</span></pre></div><p class="paragraph"/>이 코드는 user Bean에 FieldError가 있는지 확인하고 만약 존재하면 login 필드에 입력된 값을 다시 넣는다.
<h2><a name="7.4 Validation and Internationalization">7.4 Validation and Internationalization</a></h2>에러를 출력하는 코드가 어느곳에도 하드코딩되지 않아야 한다는 것은 Grails에서도 역시 중요하다. Spring의 <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/validation/FieldError.html" class="api">FieldError</a> 클래스는 내부적으로 Grails의 <a href="../guide/single.html#10. Internationalization" class="guide">i18n</a> 기능에서 메시지들을 읽어온다.<p class="paragraph"/><h4>Constraints and Message Codes(제약조건과 메시지 코드)</h4><p class="paragraph"/>메시지 코드 자체는 관례에 따른다. 예를 들어 위에 예시했던 제약조건을 살펴보면:<p class="paragraph"/><div class="code"><pre>class User &#123;
    ...<p class="paragraph"/>    <span class="java&#45;keyword">static</span> constraints = &#123;
        login(size:5..15, blank:<span class="java&#45;keyword">false</span>, unique:<span class="java&#45;keyword">true</span>)
        password(size:5..15, blank:<span class="java&#45;keyword">false</span>)
        email(email:<span class="java&#45;keyword">true</span>, blank:<span class="java&#45;keyword">false</span>)
        age(min:18, nullable:<span class="java&#45;keyword">false</span>)
    &#125;
&#125;</pre></div><p class="paragraph"/>blank 제약 조건을 위반하게 되면 Grails는 다음과 같은 관례에 따라 메시지를 찾는다:<p class="paragraph"/><div class="code"><pre>&#91;<span class="java&#45;object">Class</span> Name&#93;.&#91;Property Name&#93;.&#91;Constraint Code&#93;</pre></div><p class="paragraph"/>blank 제약 조건을 위반한 경우에의 메시지 코드는 user.login.blank가 될 것이기 때문에 grails-app/i18n/messages.properties 파일에 다음과 같이 메시지를 정의해야 한다:<p class="paragraph"/><div class="code"><pre>user.login.blank=Your login name must be specified!</pre></div><p class="paragraph"/>어떤 제약조건이 어떤 메시지 코드를 사용하는 지를 알고 싶다면 레퍼런스 가이드를 참고하라.<p class="paragraph"/><h4>Displaying Messages(메시지 출력하기)</h4><p class="paragraph"/><a href="../ref/Tags/renderErrors.html" class="tags">renderErrors</a> 태그는 자동으로 <a href="../ref/Tags/message.html" class="tags">message</a> 태그에 사용할 메시지를 찾는다. 하지만 다음과 같이 원하는 대로 메시지를 출력할 수 있다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:hasErrors bean=<span class="xml&#45;quote">"$&#123;user&#125;"</span>&#62;</span>
  <span class="xml&#45;tag">&#60;ul&#62;</span>
   <span class="xml&#45;tag">&#60;g:eachError var=<span class="xml&#45;quote">"err"</span> bean=<span class="xml&#45;quote">"$&#123;user&#125;"</span>&#62;</span>
       <span class="xml&#45;tag">&#60;li&#62;</span><span class="xml&#45;tag">&#60;g:message error=<span class="xml&#45;quote">"$&#123;err&#125;"</span> /&#62;</span><span class="xml&#45;tag">&#60;/li&#62;</span> 
   <span class="xml&#45;tag">&#60;/g:eachError&#62;</span>
  <span class="xml&#45;tag">&#60;/ul&#62;</span>
<span class="xml&#45;tag">&#60;/g:hasErrors&#62;</span></pre></div><p class="paragraph"/>이 예제에서는 에러 메시지를 읽어오기 위해 <a href="../ref/Tags/eachError.html" class="tags">eachError</a> 태그의 바디에 <a href="../ref/Tags/message.html" class="tags">message</a> 태그를 넣고 err 인자를 사용했다.<p class="paragraph"/>
<h1><a name="8. The Service Layer">8. The Service Layer</a></h1>Grails는 웹 레이어(<a href="../guide/single.html#6. The Web Layer" class="guide">Web layer</a>) 뿐만아니라 서비스 레이어 개념도 지원한다. Grails 팀은 컨트롤러에 어플리케이션의 중요한(core) 로직을 내장시키는 것을 권장하지 않는다. 내장시키는 일은 재사용을 어렵게 만들고 깨끗하게 분리되지 않게 만든다.<p class="paragraph"/>리다이렉트등의 요청을 처리하는 것은 컨트롤러의 책임으로 남겨두고 어플리케이션의 로직들은 Grails의 서비스에 구현하는 것이 낫다.<p class="paragraph"/><h4>Creating a Service(서비스 만들기)</h4><p class="paragraph"/>터미널 윈도우를 띄우고 프로젝트 루트 디렉토리로 가서 <a href="../ref/Command Line/create-service.html" class="commandLine">create-service</a> 명렁어를 실행하면 Grails 서비스가 만들어진다:<p class="paragraph"/><div class="code"><pre>grails create&#45;service simple</pre></div><p class="paragraph"/>이 예제를 실행하면 grails-app/services/SimpleService.groovy라는 서비스가 생성된다. 서비스는 보통의 Groovy 클래스이고 서비스의 이름은 관례에 따라 Service로 끝난다:<p class="paragraph"/><div class="code"><pre>class SimpleService &#123;	
&#125;</pre></div><h2><a name="8.1 Declarative Transactions">8.1 Declarative Transactions</a></h2>서로 다른 도메인 클래스(<a href="../guide/single.html#5. Object Relational Mapping (GORM)" class="guide">domain classes</a>)들을 결합하는(co-ordinating) 로직은 보통 서비스에 구현되고 종종 많은 오퍼레이션이 영속성을 사용한다. 이런 서비스의 특징은 트랜잭션을 관리해야만 하게 만든다. 물론 <a href="../ref/Domain Classes/withTransaction.html" class="domainClasses">withTransaction</a> 메소드로 트랜잭션을 프로그래밍할 수 있지만 이 것은 매우 소모적일 뿐만아니라 스프링의 트랜잭션 추상화의 힘을 활용한 것이 아니다.<p class="paragraph"/>서비스가 트랜잭션(transaction demarcation)을 사용해야 한다고 선언하면 트랜잭션이 활성화되고 모든 메소드는 트랜잭션을 사용한다. 모든 서비스에는 기본적으로 트랜잭션이 활성화되있고 transactional 프로퍼티의 값을 false로 설정하여 불활성화시킬 수 있다.<p class="paragraph"/><div class="code"><pre>class CountryService &#123;
    <span class="java&#45;keyword">static</span> transactional = <span class="java&#45;keyword">false</span>
&#125;</pre></div><p class="paragraph"/>서비스가 트랜잭션을 필요로 한다는 것을 명시하려면 단순히 이 프로퍼티의 값을 기본 값인 “true”로 설정하면 된다.<p class="paragraph"/><blockquote class="warning">
선언적 트랜잭션을 사용하는 방법은 <a href="../guide/single.html#8.3 Dependency Injection and Services" class="guide">의존성 주입</a>하는 방법뿐이다. “new BookService()“처럼 new 연산자를 사용해서 트랜잭션 서비스로 만들 수 없다.
</blockquote><p class="paragraph"/>
그래서 모든 메소드들은 트랜잭션을 사용하고 메소드에서 예외가 발생하면 자동으로 롤백된다. 트랜잭션의 전파(propagation) 수준은 기본적으로 <a href="http://static.springframework.org/spring/docs/2.0.x/api/org/springframework/transaction/TransactionDefinition.html#PROPAGATION_REQUIRED" target="blank">PROPAGATION_REQUIRED</a>로 설정되어 있다.
<h2><a name="8.2 Scoped Services">8.2 Scoped Services</a></h2>기본적으로 서비스 메소드들은 동기화되지 않는다. 서비스의 어떤 함수도 동시에concurrent 실행할 수 있도록 고려되지 않았다. 하지만 서비스는 싱글톤이고 동시에 접근될 수 있기 때문에 서비스에 상태를 저장할때는 주의해야 한다. 하지만 손 쉽게 읽기만 사용하고 서비스에 절대로 상태를 저장하지 않는 것이 더 낫다.<p class="paragraph"/>서비스를 다른 스콥에 넣어서 이 행동을 변경할 수 있다. 지원되는 스콥은 다음과 같다:
<ul class="star">
<li>prototype - 서비스는 항상 생성되어 다른 클래스로 주입된다.</li>
<li>request - 서비스는 매 요청마다 생성된다.</li>
<li>flash - 서비스는 현재 요청부터 다음 요청까지만 생성된다.</li>
<li>flow - 서비스는 웹 플로우의 flow 스콥에 따라 생성되고 해제된다.</li>
<li>conversation - 서비스는 웹 플로우의 conversation 스콥에 따라 생성되고 해제된다. 이 스콥은 루트 플로우와 이 것의 모든 서브 플로우들까지 포함된 스콥이다.</li>
<li>session - 사용자 세션마다 서비스가 생성된다.</li>
<li>singleton(기본값) - 서비스의 인스턴스는 단 한개만 존재할 수 있다.</li>
</ul><p class="paragraph"/><blockquote class="note">
서비스가 flash, flow, conversation 스콥에 해당되면 java.io.Serializable를 구현해야 하고 웹 플로우(<a href="../guide/single.html#6.5 Web Flow" class="guide">Web Flow</a>) 컨텍스트에서만 사용할 수 있다.
</blockquote><p class="paragraph"/>스콥을 변경하려면 클래스에 정적 프로퍼티 scope을 추가하고 위에 설명한 것들 중에서 하나로 값을 설정한다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">static</span> scope = <span class="java&#45;quote">"flow"</span></pre></div><p class="paragraph"/><h2><a name="8.3 Dependency Injection and Services">8.3 Dependency Injection and Services</a></h2><h4>Dependency Injection Basics(의존성 주입의 기초)</h4><p class="paragraph"/><a href="http://www.springframework.org/" target="blank">Spring</a> 의 의존성 주입 기능을 이용하는 것은 Grails 서비스의 중요한 특징이다. Grails의 "의존성 주입은 관례를 사용"한다. 구체적으로 말해서 서비스의 클래스 이름으로 된 프로퍼티를 사용하면 자동으로 컨트롤러, 태그 라이브러리, 등에 의존성이 주입된다.<p class="paragraph"/>예를 들어 BookService라고 불리는 서비스가 있다고 하자. 컨트롤러에 bookService 프로퍼티를 다음과 같이 넣는다:<p class="paragraph"/><div class="code"><pre>class BookController &#123;
   def bookService
   &#8230;
&#125;</pre></div><p class="paragraph"/>스프링 컨테이너는 자동으로 설정된 스콥에 기반하여 서비스의 인스턴스를 주입할 것이다. 모든 의존성은 이름으로 주입된다. Grails는 타입을 이용한 의존성 주입을 지원하지 않는다. 하지만, 다음과 같이 타입을 명시할 수 있다:<p class="paragraph"/><div class="code"><pre>class AuthorService &#123;
	BookService bookService
&#125;</pre></div><p class="paragraph"/>그러나 이 것은 개발중에 BookService가 변경되면 다시 로딩되면서 에러를 발생시키는 문제가 있다.<p class="paragraph"/><h4>Dependency Injection and Services(의존성 주입과 서비스)</h4><p class="paragraph"/>서비스에도 동일한 방법으로 의존성을 주입할 수 있다. BookService를 사용해야 하는 AuthorService가 있을 때 AuthorService에 다음과 같이 의존성을 주입한다:<p class="paragraph"/><div class="code"><pre>class AuthorService &#123;
	def bookService
&#125;</pre></div><p class="paragraph"/><h4>Dependency Injection and Domain Classes(의존성 주입과 도메인 클래스)</h4><p class="paragraph"/>도메인 클래스에도 서비스를 주입할 수 있다. 이를 통해서 풍부한(rich) 도메인 모델을을 개발 할 수 있다:<p class="paragraph"/><div class="code"><pre>class Book &#123;	
	&#8230;
	def bookService
	def buyBook() &#123;
		bookService.buyBook(<span class="java&#45;keyword">this</span>)
	&#125;
&#125;</pre></div>
<h2><a name="8.4 Using Services from Java">8.4 Using Services from Java</a></h2>서비스가 강력한 이유중에 하나는 다른 클래스에서 로직을 재사용할 수 있도록 캡슐화(encapsulate)하는 것이다. 그리고 자바 클래스에서도 서비스를 재사용할 수 있다. 자바에서 서비스를 재사용하는 방법은 두 가지이다. 가장 간단한 방법은 패키지를 the grails-app/services 디렉토리에 있는 서비스에 정의하는 것이다. 자바 클래스는 기본 패키지에 있는 서비스를 사용import할 수 없기 때문에 이 것은 중요하다. 아무런 패키지를 정의하지 않으면 자동으로 기본 패키지에 포함된다. 그래서 다음과 같은 BookService는 Java에서 사용할 수 없다:<p class="paragraph"/><div class="code"><pre>class BookService &#123;
	void buyBook(Book book) &#123;
		// logic
	&#125;
&#125;</pre></div><p class="paragraph"/>그러나 이것은 클래스에 패키지를 정의하면 해결된다. 클래스를 grails-app/services/bookstore처럼 하위디렉토리로 옮기고 package 키워드로 패키지를 정의한다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">package</span> bookstore
class BookService &#123;
	void buyBook(Book book) &#123;
		// logic
	&#125;
&#125;</pre></div><p class="paragraph"/>패키지를 정의하는 다른 벙법으로 service의 인터페이스에 패키지를 정의하는 방법도 있다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">package</span> bookstore;
<span class="java&#45;keyword">interface</span> BookStore &#123;
	void buyBook(Book book);
&#125;</pre></div><p class="paragraph"/>그리고 서비스를 구현한다:<p class="paragraph"/><div class="code"><pre>class BookService <span class="java&#45;keyword">implements</span> bookstore.BookStore &#123;
	void buyBook(Book b) &#123;
		// logic
	&#125;
&#125;</pre></div><p class="paragraph"/>어쩌면 두번째 방법이 더 깔끔할지도 모른다. 자바 세계에서는 구현된 클래스가 아니라 오직 인터페이스만을 사용할 수 있다. 어떤 방법이든지 목표는 컴파일할때 자바에서 클래스나 인터페이스를 정적으로 찾을 수 있게 하는 것이다. 이제 src/java 패키지에 자바 클래스를 만들고 Spring이 Bean의 타입과 이름을 사용할 수 있도록 setter를 구현해야 한다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">package</span> bookstore;
// note: <span class="java&#45;keyword">this</span> is Java class
<span class="java&#45;keyword">public</span> class BookConsumer &#123;
	<span class="java&#45;keyword">private</span> BookStore store;<p class="paragraph"/>	<span class="java&#45;keyword">public</span> void setBookStore(BookStore storeInstance) &#123;
		<span class="java&#45;keyword">this</span>.store = storeInstance;
	&#125;	
	&#8230;
&#125;</pre></div><p class="paragraph"/>그리고 나서 grails-app/conf/spring/resources.xml에 자바 클래스를 Spring의 Bean으로 설정한다(좀 더 자세한 정보는 <a href="../guide/single.html#14. Grails and Spring" class="guide">Grails and Spring</a> 장을 참고하라):<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;bean id=<span class="xml&#45;quote">"bookConsumer"</span> class=<span class="xml&#45;quote">"bookstore.BookConsumer"</span>&#62;</span>
	<span class="xml&#45;tag">&#60;property name=<span class="xml&#45;quote">"bookStore"</span> ref=<span class="xml&#45;quote">"bookService"</span> /&#62;</span>
<span class="xml&#45;tag">&#60;/bean&#62;</span></pre></div><p class="paragraph"/><h1><a name="9. Testing">9. Testing</a></h1>테스트 자동화는 Grails의 핵심 기능중 하나이고 <a href="http://groovy.codehaus.org/Testing+Guide" target="blank">Groovy Test</a>를 이용하여 구현됐다. 그래서 Grails에서는 저 수준 유닛 테스트부터 고 수준 기능 테스트까지 쉽게 작성할 수 있다. 이 절에서는 테스트를 위해 Grails가 지원하는 것들에 대해 설명한다.<p class="paragraph"/>먼저 모든 create-* 명령어들은 명령을 마칠 때 자동으로 "통합 테스트(integration test)"를 생성한다는 것을 알아야 한다. 예를 들어 다음과 같이 <a href="../ref/Command Line/create-controller.html" class="commandLine">create-controller</a> 명령을 실행하면:<p class="paragraph"/><div class="code"><pre>grails create&#45;controller simple</pre></div><p class="paragraph"/>Grails는 grails-app/controllers/SimpleController.groovy에 컨트롤러를 생성할 뿐만 아니라 test/integration/SimpleControllerTests.groovy에 통합 테스트도 생성한다. 하지만 Grails가 테스트 로직까지 채워주지 않기 때문에 직접 해야 한다.<p class="paragraph"/>이렇게 했다면 모든 테스트를 <a href="../ref/Command Line/test-app.html" class="commandLine">test-app</a> 명령어로 테스트를 실행할 수 있다:<p class="paragraph"/><div class="code"><pre>grails test&#45;app</pre></div><p class="paragraph"/>이 명령어를 실행하면 다음과 같이 출력된다:<p class="paragraph"/><div class="code"><pre>&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;
Running Unit Tests&#8230;
Running test FooTests...FAILURE
Unit Tests Completed in 464ms &#8230;
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;<p class="paragraph"/>Tests failed: 0 errors, 1 failures</pre></div><p class="paragraph"/>테스트 보고서는 test/reports 디렉토리에 저장될 것이다. 그리고 테스트 이름을 명시해서 테스트 별로 실행할 수도 있다(이때 테스트 접미어는 생략한다):<p class="paragraph"/><div class="code"><pre>grails test&#45;app SimpleController</pre></div><p class="paragraph"/>스페이스를 구분자로 테스트의 이름들을 나열하는 식으로 여러 테스트를 한꺼번에 실행시킬 수도 있다:<p class="paragraph"/><div class="code"><pre>grails test&#45;app SimpleController BookController</pre></div><p class="paragraph"/><h2><a name="9.1 Unit Testing">9.1 Unit Testing</a></h2>유닛 테스팅은 "유닛" 수준에서 수행하는 테스트를 말한다. 즉, 기반 구조에 대한 고려없이 각각의 메소드나 코드 블럭을 테스트하는 것이다. Grails의 유닛 테스트와 통합 테스트의 차이점을 알아야 한다. Grails는 런타임이나 통합 테스트를 할 때처럼 유닛 테스트에 어떠한 동적 메소드도 주입하지 않는다.<p class="paragraph"/>This makes sense if you consider that the methods injected by Grails typically community with the database (with GORM) or the underlying Servlet engine (with Controllers).<p class="paragraph"/>Grails가 데이터베이스(GORM)와 통신하기 위해 주입하는 메소드나 서블릿 엔진에 의해 컨트롤러에 주입되는 메소드와 함께 이해할 수 있다. 예를 들어 <code>BookController</code>에 다음과 같은 액션이 있다고 하면:<p class="paragraph"/><div class="code"><pre>class MyService &#123;
    def otherService<p class="paragraph"/>	<span class="java&#45;object">String</span> createSomething() &#123; 
		def stringId = otherService.newIdentifier()
		def item = <span class="java&#45;keyword">new</span> Item(code: stringId, name: <span class="java&#45;quote">"Bangle"</span>) 
		item.save() 
		<span class="java&#45;keyword">return</span> stringId 
	&#125;<p class="paragraph"/>	<span class="java&#45;object">int</span> countItems(<span class="java&#45;object">String</span> name) &#123; 
		def items = Item.findAllByName(name) 
		<span class="java&#45;keyword">return</span> items.size() 
	&#125; 
&#125;</pre></div><p class="paragraph"/>
As you can see the service takes advantage of GORM methods. So how do you go about testing the above code in a unit test? The answer can be found in Grails' testing support classes.<p class="paragraph"/><h3>The Testing Framework</h3><p class="paragraph"/>The core of the testing plugin is the <code>grails.test.GrailsUnitTestCase</code> class. This is a sub-class of <code>GroovyTestCase</code> geared towards Grails applications and their artifacts. It provides several methods for mocking particular types as well as support for general mocking a la Groovy's MockFor and StubFor classes.<p class="paragraph"/>Normally you might look at the <code>MyService</code> example shown previously and the dependency on another service and the use of dynamic domain class methods with a bit of a groan. You can use meta-class programming and the "map as object" idiom, but these can quickly get ugly. How might we write the test with GrailsUnitTestCase ?<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> grails.test.GrailsUnitTestCase<p class="paragraph"/>class MyServiceTests <span class="java&#45;keyword">extends</span> GrailsUnitTestCase &#123; 
	void testCreateSomething() &#123; 
		// Mock the domain class. 
		def testInstances = &#91;&#93; 
		mockDomain(Item, testInstances)<p class="paragraph"/>		// Mock the <span class="java&#45;quote">"other"</span> service. 
		<span class="java&#45;object">String</span> testId = <span class="java&#45;quote">"NH&#45;12347686"</span> 
		def otherControl = mockFor(OtherService) 
		otherControl.demand.newIdentifier(1..1) &#123;&#45;&#62; <span class="java&#45;keyword">return</span> testId &#125;<p class="paragraph"/>		// 	Initialise the service and test the target method. 
		def testService = <span class="java&#45;keyword">new</span> MyService() 
		testService.otherService = otherControl.createMock()<p class="paragraph"/>		def retval = testService.createSomething()<p class="paragraph"/>		// Check that the method returns the identifier returned by the 
		// mock <span class="java&#45;quote">"other"</span> service and also that a <span class="java&#45;keyword">new</span> Item instance has 
		// been saved. 
		assertEquals testId, retval 
		assertEquals 1, testInstances 
		assertTrue testInstances&#91;0&#93; <span class="java&#45;keyword">instanceof</span> Item 
	&#125;<p class="paragraph"/>	void testCountItems() &#123; 
		// Mock the domain class, <span class="java&#45;keyword">this</span> time providing a list of test 
		// Item instances that can be searched. 
		def testInstances = &#91; <span class="java&#45;keyword">new</span> Item(code: <span class="java&#45;quote">"NH&#45;4273997"</span>, name: <span class="java&#45;quote">"Laptop"</span>), 
							  <span class="java&#45;keyword">new</span> Item(code: <span class="java&#45;quote">"EC&#45;4395734"</span>, name: <span class="java&#45;quote">"Lamp"</span>), 
							  <span class="java&#45;keyword">new</span> Item(code: <span class="java&#45;quote">"TF&#45;4927324"</span>, name: <span class="java&#45;quote">"Laptop"</span>) &#93; 
		mockDomain(Item, testInstances)<p class="paragraph"/>		// Initialise the service and test the target method. def testService = <span class="java&#45;keyword">new</span> MyService()<p class="paragraph"/>		assertEquals 2, testService.countItems(<span class="java&#45;quote">"Laptop"</span>) 
		assertEquals 1, testService.countItems(<span class="java&#45;quote">"Lamp"</span>) 
		assertEquals 0, testService.countItems(<span class="java&#45;quote">"Chair"</span>) 
	&#125; 
&#125;</pre></div><p class="paragraph"/>OK, so a fair bit of new stuff there, but once we break it down you should quickly see how easy it is to use the methods available to you. Take a look at the "testCreateSomething()" test method. The first thing you will probably notice is the <code>mockDomain()</code> method, which is one of several provided by <code>GrailsUnitTestCase</code>:<p class="paragraph"/><div class="code"><pre>def testInstances = &#91;&#93; 
mockDomain(Item, testInstances)</pre></div><p class="paragraph"/>It adds all the common domain methods (both instance and static) to the given class so that any code using it sees it as a full-blown domain class. So for example, once the <code>Item</code> class has been mocked, we can safely call the <code>save()</code> method on instances of it. Speaking of which, what happens when we call that method on a mocked domain class? Simple: the new instance is added to the <code>testInstances</code> list we passed into the <code>mockDomain()</code> method.<p class="paragraph"/>The next bit we want to look at is centered on the <code>mockFor</code> method:<p class="paragraph"/><div class="code"><pre>def otherControl = mockFor(OtherService) 
otherControl.demand.newIdentifier(1..1) &#123;&#45;&#62; <span class="java&#45;keyword">return</span> testId &#125;</pre></div><p class="paragraph"/>This is analagous to the <code>MockFor</code> and <code>StubFor</code> classes that come with Groovy and it can be used to mock any class you want. In fact, the "demand" syntax is identical to that used by Mock/StubFor, so you should feel right at home. Of course you often need to inject a mock instance as a dependency, but that is pretty straight forward with the <code>createMock()</code> method, which you simply call on the mock control as shown. For those familiar with EasyMock, the name <code>otherControl</code> highlights the role of the object returned by <code>mockFor()</code> - it is a control object rather than the mock itself.<p class="paragraph"/>The rest of the <code>testCreateSomething()</code> method should be pretty familiar, particularly as you now know that the mock <code>save()</code> method adds instances to <code>testInstances</code> list. However, there is an important technique missing from the test method. We can determine that the mock <code>newIdentifier()</code> method is called because its return value has a direct impact on the result of the <code>createSomething()</code> method. But what if that weren't the case? How would we know whether it had been called or not? With Mock/StubFor the check would be performed at the end of the <code>use()</code> closure, but that's not available here. Instead, you can call <code>verify()</code> on the control object - in this case <code>otherControl</code>. This will perform the check and throw an assertion error if it hasn't been called when it should have been.<p class="paragraph"/>Lastly, <code>testCountItems()</code> in the example demonstrates another facet of the <code>mockDomain()</code> method:<p class="paragraph"/><div class="code"><pre>def testInstances = &#91; <span class="java&#45;keyword">new</span> Item(code: <span class="java&#45;quote">"NH&#45;4273997"</span>, name: <span class="java&#45;quote">"Laptop"</span>), 
					  <span class="java&#45;keyword">new</span> Item(code: <span class="java&#45;quote">"EC&#45;4395734"</span>, name: <span class="java&#45;quote">"Lamp"</span>), 
					  <span class="java&#45;keyword">new</span> Item(code: <span class="java&#45;quote">"TF&#45;4927324"</span>, name: <span class="java&#45;quote">"Laptop"</span>) &#93; 
mockDomain(Item, testInstances)</pre></div><p class="paragraph"/>It is normally quite fiddly to mock the dynamic finders manually, and you often have to set up different data sets for each invocation. On top of that, if you decide a different finder should be used then you have to update the tests to check for the new method! Thankfully the <code>mockDomain()</code> method provides a lightweight implementation of the dynamic finders backed by a list of domain instances. Simply provide the test data as the second argument of the method and the mock finders will just work.<p class="paragraph"/><h3>GrailsUnitTestCase - the mock methods</h3><p class="paragraph"/>You have already seen a couple of examples in the introduction of the <code>mock..()</code> methods provided by the <code>GrailsUnitTestCase</code> class. Here we will look at all the available methods in some detail, starting with the all-purpose <code>mockFor()</code>. But before we do, there is a very important point to make: using these methods ensures that any changes you make to the given classes do not leak into other tests! This is a common and serious problem when you try to perform the mocking yourself via meta-class programming, but that headache just disappears as long as you use at least one of <code>mock..()</code> methods on each class you want to mock.<p class="paragraph"/><div class="code"><pre>mockFor(class, loose = <span class="java&#45;keyword">false</span>)</pre></div><p class="paragraph"/>General purpose mocking that allows you to set up either strict or loose demands on a class.<p class="paragraph"/>This method is surprisingly intuitive to use. By default it will create a strict mock control object (one for which the order in which methods are called is important) that you can use to specify demands:<p class="paragraph"/><div class="code"><pre>def strictControl = mockFor(MyService)
strictControl.demand.someMethod(0..2) &#123; <span class="java&#45;object">String</span> arg1, <span class="java&#45;object">int</span> arg2 &#45;&#62; ‚Ä¶ &#125;
strictControl.demand.<span class="java&#45;keyword">static</span>.aStaticMethod &#123;&#45;&#62; ‚Ä¶ &#125;</pre></div><p class="paragraph"/>Notice that you can mock static methods as well as instance ones simply by using the "static" property after "demand". You then specify the name of the method that you want to mock with an optional range as its argument. This range determines how many times you expect the method to be called, so if the number of invocations falls outside of that range (either too few or too many) then an assertion error will be thrown. If no range is specified, a default of "1..1" is assumed, i.e. that the method must be called exactly once.<p class="paragraph"/>The last part of a demand is a closure representing the implementation of the mock method. The closure arguments should match the number and types of the mocked method, but otherwise you are free to add whatever you want in the body.<p class="paragraph"/>As we mentioned before, if you want an actual mock instance of the class that you are mocking, then you need to call <code>mockControl.createMock()</code>. In fact, you can call this as many times as you like to create as many mock instances as you need. And once you have executed the test method, you can call <code>mockControl.verify()</code> to check whether the expected methods were actually called or not.<p class="paragraph"/>Lastly, the call:<p class="paragraph"/><div class="code"><pre>def looseControl = mockFor(MyService, <span class="java&#45;keyword">true</span>)</pre></div><p class="paragraph"/>will create a mock control object that has only loose expectations, i.e. the order that methods are invoked does not matter.<p class="paragraph"/><h4>mockDomain(class, testInstances = )</h4><p class="paragraph"/>Takes a class and makes mock implementations of all the domain class methods (both instance- and static-level) accessible on it.<p class="paragraph"/>Mocking domain classes is one of the big wins from using the testing plugin. Manually doing it is fiddly at best, so it's great that mockDomain() takes that burden off your shoulders.<p class="paragraph"/>In effect, <code>mockDomain()</code> provides a lightweight version of domain classes in which the "database" is simply a list of domain instances held in memory. All the mocked methods ( <code>save()</code> , <code>get()</code> , <code>findBy*()</code> , etc.) work against that list, generally behaving as you would expect them to. In addition to that, both the mocked <code>save()</code> and validate() methods will perform real validation (support for the unique constraint included!) and populate an errors object on the corresponding domain instance.<p class="paragraph"/>There isn't much else to say other than that the plugin does not support the mocking of criteria or HQL queries. If you use either of those, simply mock the corresponding methods manually (for example with <code>mockFor()</code> ) or use an integration test with real data.<p class="paragraph"/><h4>mockForConstraintsTests(class, testInstances = )</h4><p class="paragraph"/>Highly specialised mocking for domain classes and command objects that allows you to check whether the constraints are behaving as you expect them to.<p class="paragraph"/>Do you test your domain constraints? If not, why not? If your answer is that they don't need testing, think again. Your constraints contain logic and that logic is highly susceptible to bugs - the kind of bugs that can be tricky to track down (particularly as save() doesn't throw an exception when it fails). If your answer is that it's too hard or fiddly, that is no longer an excuse. Enter the <code>mockForConstraintsTests()</code> method.<p class="paragraph"/>This is like a much reduced version of the <code>mockDomain()</code> method that simply adds a <code>validate()</code> method to a given domain class. All you have to do is mock the class, create an instance with field values, and then call <code>validate()</code>. You can then access the errors property on your domain instance to find out whether the validation failed or not. So if all we are doing is mocking the <code>validate()</code> method, why the optional list of test instances? That is so that we can test unique constraints as you will soon see.<p class="paragraph"/>So, suppose we have a simple domain class like so:<p class="paragraph"/><div class="code"><pre>class Book &#123;
    <span class="java&#45;object">String</span> title
    <span class="java&#45;object">String</span> author<p class="paragraph"/>	<span class="java&#45;keyword">static</span> constraints = &#123; 
		title(blank: <span class="java&#45;keyword">false</span>, unique: <span class="java&#45;keyword">true</span>) 
		author(blank: <span class="java&#45;keyword">false</span>, minSize: 5) 
	&#125; 
&#125;</pre></div><p class="paragraph"/>Don't worry about whether the constraints are sensible or not (they're not!), they are for demonstration only. To test these constraints we can do the following:<p class="paragraph"/><div class="code"><pre>class BookTests <span class="java&#45;keyword">extends</span> GrailsUnitTestCase &#123;
    void testConstraints() &#123;
        def existingBook = <span class="java&#45;keyword">new</span> Book(title: <span class="java&#45;quote">"Misery"</span>, author: <span class="java&#45;quote">"Stephen King"</span>)
        mockForConstraintsTests(Book, &#91; existingBook &#93;)<p class="paragraph"/>		// Validation should fail <span class="java&#45;keyword">if</span> both properties are <span class="java&#45;keyword">null</span>. 
		def book = <span class="java&#45;keyword">new</span> Book() 
		assertFalse book.validate() 
		assertEquals <span class="java&#45;quote">"nullable"</span>, book.errors&#91;<span class="java&#45;quote">"title"</span>&#93; 
		assertEquals <span class="java&#45;quote">"nullable"</span>, book.errors&#91;<span class="java&#45;quote">"author"</span>&#93;<p class="paragraph"/>		// So let's demonstrate the unique and minSize constraints. 
		book = <span class="java&#45;keyword">new</span> Book(title: <span class="java&#45;quote">"Misery"</span>, author: <span class="java&#45;quote">"JK"</span>) 
		assertFalse book.validate() 
		assertEquals <span class="java&#45;quote">"unique"</span>, 	book.errors&#91;<span class="java&#45;quote">"title"</span>&#93; 
		assertEquals <span class="java&#45;quote">"minSize"</span>, book.errors&#91;<span class="java&#45;quote">"author"</span>&#93;<p class="paragraph"/>		// Validation should pass! 
		book = <span class="java&#45;keyword">new</span> Book(title: <span class="java&#45;quote">"The Shining"</span>, author: <span class="java&#45;quote">"Stephen King"</span>) 
		assertTrue book.validate() 
	&#125; 
&#125;</pre></div><p class="paragraph"/>You can probably look at that code and work out what's happening without any further explanation. The one thing we will explain is the way the errors property is used. First, it does return a real Spring <code>Errors</code> instance, so you can access all the properties and methods you would normally expect. Second, this particular <code>Errors</code> object also has map/property access as shown. Simply specify the name of the field you are interested in and the map/property access will return the name of the constraint that was violated. Note that it is the constraint name , not the message code (as you might expect).<p class="paragraph"/>That's it for testing constraints. One final thing we would like to say is that testing the constraints in this way catches a common error: typos in the "constraints" property! It is currently one of the hardest bugs to track down normally, and yet a unit test for your constraints will highlight the problem straight away.<p class="paragraph"/><h4>mockLogging(class, enableDebug = false)</h4><p class="paragraph"/>Adds a mock "log" property to a class. Any messages passed to the mock logger are echoed to the console.<p class="paragraph"/><h4>mockController(class)</h4><p class="paragraph"/>Adds mock versions of the dynamic controller properties and methods to the given class. This is typically used in conjunction with the <code>ControllerUnitTestCase</code> class.<p class="paragraph"/><h4>mockTagLib(class)</h4><p class="paragraph"/>Adds mock versions of the dynamic taglib properties and methods to the given class. This is typically used in conjunction with the <code>TagLibUnitTestCase</code> class.
<h2><a name="9.2 Integration Testing">9.2 Integration Testing</a></h2>통합 테스트는 모든 코드를 테스트할 수 있어야 한다는 점에서 유닛 테스트와 다르다 Grails는 통합 테스트에 HSQLDB라는 메모리 데이터베이스를 사용하고 각 테스트마다 데이터베이스의 모든 데이터를 삭제할 것이다.<p class="paragraph"/><h4>Testing Controllers(컨트롤러 테스트하기)</h4><p class="paragraph"/>컨트롤러를 테스트하려면 먼저 스프링 Mock 라이브러리를 이해해야 한다.<p class="paragraph"/>Grails의 테스트에서는 내부적으로 <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/mock/web/MockHttpServletRequest.html" class="api">MockHttpServletRequest</a>, <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/mock/web/MockHttpServletResponse.html" class="api">MockHttpServletResponse</a>, <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/mock/web/MockHttpSession.html" class="api">MockHttpSession</a>을 사용한다. 다음과 같이 이 것들을 이용해서 테스트할 수 있다:<p class="paragraph"/><div class="code"><pre>class FooController &#123;<p class="paragraph"/>	def text = &#123;
	    render <span class="java&#45;quote">"bar"</span>
	&#125;<p class="paragraph"/>	def someRedirect = &#123;
		redirect(action:<span class="java&#45;quote">"bar"</span>)
	&#125;
&#125;</pre></div><p class="paragraph"/>다음과 같이 이 코드에 대한 테스트를 만든다:<p class="paragraph"/><div class="code"><pre>class FooControllerTests <span class="java&#45;keyword">extends</span> GroovyTestCase &#123;<p class="paragraph"/>  void testText() &#123;
		def fc = <span class="java&#45;keyword">new</span> FooController()
		fc.text()
		assertEquals <span class="java&#45;quote">"bar"</span>, fc.response.contentAsString
	&#125;<p class="paragraph"/>	void testSomeRedirect() &#123;<p class="paragraph"/>		def fc = <span class="java&#45;keyword">new</span> FooController()
		fc.someRedirect()
		assertEquals <span class="java&#45;quote">"/foo/bar"</span>, fc.response.redirectedUrl
	&#125;
&#125;</pre></div><p class="paragraph"/>이 예제에서 응답은 MockHttpServletResponse의 인스턴스이다. 응답에 쓴 결과를 contentAsString으로 결과를 확인하거나 리다이렉트된 URL을 얻어오기 위해 사용한다. Servlet API의 Mock 버전은 실제 버전과 달라서 모든 것을 변경할 수 있고 contextPath같은 요청의 속성도 설정할 수 있다.<p class="paragraph"/>통합 테스트 중에는 액션이 호출될 때 Grails가 인터셉터(<a href="../guide/single.html#6.1.5 Controller Interceptors" class="guide">interceptors</a>)를 자동으로 실행하지 않는다. 인터셉터를 테스트해야 한다면 인터셉터만 별도로 기능 테스트(<a href="../guide/single.html#9.3 Functional Testing" class="guide">functional testing</a>)를 이용해 테스트한다.<p class="paragraph"/><h4>Testing Controllers with Services(서비스와 함께 컨트롤러 테스트하기)</h4><p class="paragraph"/>만약 컨트롤러가 서비스를 참조하고 있다면 테스트에서 서비스를 명시적으로 초기화 시켜야 한다.<p class="paragraph"/>주어진 컨트롤러가 다음과 같으면:<p class="paragraph"/><div class="code"><pre>class FilmStarsController &#123;
    def popularityService<p class="paragraph"/>    def update = &#123;
        // <span class="java&#45;keyword">do</span> something with popularityService
    &#125;
&#125;</pre></div><p class="paragraph"/>테스트를 다음과 같이 만들 수 있다:<p class="paragraph"/><div class="code"><pre>class FilmStarsTests <span class="java&#45;keyword">extends</span> GroovyTestCase &#123;
    def popularityService<p class="paragraph"/>    <span class="java&#45;keyword">public</span> void testInjectedServiceInController () &#123;
        def fsc = <span class="java&#45;keyword">new</span> FilmStarsController()
        fsc.popularityService = popularityService
        fsc.update()
    &#125;
&#125;</pre></div><p class="paragraph"/><h4>Testing Controller Command Objects(컨트롤러의 커맨드 객체 테스트하기)</h4><p class="paragraph"/>커맨드 객체로 요청에 파라미터를 제공하는 방법이 있다. 커맨드 객체는 파라미터 없이 액션이 호출되면 자동으로 실행된다:<p class="paragraph"/>다음과 같이 커맨드 객체를 사용하는 객체가 있을 때:<p class="paragraph"/><div class="code"><pre>class AuthenticationController &#123;
    def signup = &#123; SignupForm form &#45;&#62;
        &#8230;
    &#125;
&#125;</pre></div><p class="paragraph"/>다음과 같이 테스트를 할 수 있다:<p class="paragraph"/><div class="code"><pre>def controller = <span class="java&#45;keyword">new</span> AuthenticationController()
controller.params.login = <span class="java&#45;quote">"marcpalmer"</span>
controller.params.password = <span class="java&#45;quote">"secret"</span>
controller.params.passwordConfirm = <span class="java&#45;quote">"secret"</span>
controller.signup()</pre></div><p class="paragraph"/>Grails는 마법처럼 자동으로 Mock 요청 파라미터들을 커맨드 객체에 할당시켜서 siginup 액션를 실행시킨다. 컨트롤러를 테스트 하는 동안 그레일즈가 제공하는 Mock 요청으로 params가 바뀔 수도 있다.<p class="paragraph"/><h4>Testing Controllers and the render Method(render 메소드를 사용하는 컨트롤러 테스트하기)</h4><p class="paragraph"/><a href="../ref/Controllers/render.html" class="controllers">render</a> 메소드를 사용하면 모든 액션에서 원하는 뷰를 렌더링할 수 있다. 예를 들어 다음과 같은 예제가 있을 때:<p class="paragraph"/><div class="code"><pre>def save = &#123;
	def book = Book(params)
	<span class="java&#45;keyword">if</span>(book.save()) &#123;
		// handle
	&#125;
	<span class="java&#45;keyword">else</span> &#123;
		render(view:<span class="java&#45;quote">"create"</span>, model:&#91;book:book&#93;)
	&#125;
&#125;</pre></div><p class="paragraph"/>액션 모델의 결과는 반환되지 않지만 대신에 컨트롤러의 modelAndView 속성에 저장된다. modelAndView 속성은 Spring MVC's <a href="http://static.springframework.org/spring/docs/1.2.x/api/org/springframework/web/servlet/ModelAndView.html" target="blank">ModelAndView</a> 클래스의 인스턴스이고 이 속성을 사용하여 액션의 결과를 테스트할 수 있다:<p class="paragraph"/><div class="code"><pre>def bookController = <span class="java&#45;keyword">new</span> BookController()
bookController.save()
def model = bookController.modelAndView.model.book</pre></div><p class="paragraph"/><h4>Simulating Request Data(요청 데이터 시뮬레이션)</h4><p class="paragraph"/>액션을 테스트하려면 REST 웹 서비스처럼 어떤 요청 데이터가 필요하다. 이를 위해 스프링의 <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/mock/web/MockHttpServletRequest.html" class="api">MockHttpServletRequest</a> 객체를 사용할 수 있다. 예를 들어 다음의 액션은 들어오는 요청을 바인딩한다:<p class="paragraph"/><div class="code"><pre>def create = &#123;
	&#91;book: <span class="java&#45;keyword">new</span> Book(params&#91;'book'&#93;) &#93;	
&#125;</pre></div><p class="paragraph"/>다음과 같이 XML로 book 파라미터를 시뮬레이션할 수 있다:<p class="paragraph"/><div class="code"><pre>void testCreateWithXML() &#123;
	def controller = <span class="java&#45;keyword">new</span> BookController()
	controller.request.contentType = 'text/xml'
	controller.request.contents = '''&#60;?xml version=<span class="java&#45;quote">"1.0"</span> encoding=<span class="java&#45;quote">"ISO&#45;8859&#45;1"</span>?&#62;
	&#60;book&#62;
		&#60;title&#62;The Stand&#60;/title&#62;
		&#8230;
	&#60;/book&#62;	
	'''.getBytes() // note we need the bytes<p class="paragraph"/>	def model = controller.create()
	assert model.book
	assertEquals <span class="java&#45;quote">"The Stand"</span>, model.book.title
&#125;</pre></div><p class="paragraph"/>JSON 요청에도 동일하게 적용할 수 있다:<p class="paragraph"/><div class="code"><pre>void testCreateWithJSON() &#123;
	def controller = <span class="java&#45;keyword">new</span> BookController()	
 	controller.request.contentType = <span class="java&#45;quote">"text/json"</span>
 	controller.request.content = '&#123;<span class="java&#45;quote">"id"</span>:1,<span class="java&#45;quote">"class"</span>:<span class="java&#45;quote">"Book"</span>,<span class="java&#45;quote">"title"</span>:<span class="java&#45;quote">"The Stand"</span>&#125;'.getBytes()<p class="paragraph"/>	def model = controller.create()
	assert model.book
	assertEquals <span class="java&#45;quote">"The Stand"</span>, model.book.title<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/><blockquote class="note">
JSON을 사용할 때에는 class 속성에 바인딩할 객체의 형식을 명시해야 한다는 것을 잊으면 안된다. XML에서는 &#60;book&#62;노드의 이름에서 유추하지만 JSON에서는 JSON 패킷에 이 속성을 명시해야 한다.
</blockquote><p class="paragraph"/>REST 웹 서비스에 대한 정보는 <a href="../guide/single.html#13.1 REST" class="guide">REST</a> 절을 보라.<p class="paragraph"/><h4>Testing Web Flows(웹 플로우 테스트하기)</h4><p class="paragraph"/>웹 플로우(<a href="../guide/single.html#6.5 Web Flow" class="guide">Web Flows</a>)를 테스팅하는 것은 grails.test.WebFlowTestCase라는 특별한 테스트 도구harness가 필요하다. 이 클래스는 스프링 웹 플로우에 포함된 <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/webflow/test/execution/AbstractFlowExecutionTests.html" class="api">AbstractFlowExecutionTests</a> 서브클래스이다.<p class="paragraph"/><blockquote class="note">
WebFlowTestCase의 서브클래스는 통합 테스트를 의미한다.
</blockquote><p class="paragraph"/>일반적으로 다음과 같은 플로우가 있을 때:<p class="paragraph"/><div class="code"><pre>class ExampleController &#123;
	def exampleFlow = &#123;
		start &#123;
			on(<span class="java&#45;quote">"go"</span>) &#123;
				flow.hello = <span class="java&#45;quote">"world"</span>
			&#125;.to <span class="java&#45;quote">"next"</span>
		&#125;
		next &#123;
			on(<span class="java&#45;quote">"back"</span>).to <span class="java&#45;quote">"start"</span>
			on(<span class="java&#45;quote">"go"</span>).to <span class="java&#45;quote">"end"</span>
		&#125;
		end()
	&#125;	
&#125;</pre></div><p class="paragraph"/>어떤 플로우를 사용할 것인지 테스트 도구(harness)에 알려줘야 한다. 추상 메소드를 getFlow를 오버라이딩해서 테스트 도구에 알릴 수 있다:<p class="paragraph"/><div class="code"><pre>class ExampleFlowTests <span class="java&#45;keyword">extends</span> grails.test.WebFlowTestCase &#123;
	def getFlow() &#123; <span class="java&#45;keyword">new</span> ExampleController().exampleFlow &#125;
	&#8230;
&#125;</pre></div><p class="paragraph"/>만약 flow id를 명시해야 한다면 getFlowId 메소드를 오버라이딩해서 명시할 수 있다. 그렇지않으면 기본 값이 사용된다:<p class="paragraph"/><div class="code"><pre>class ExampleFlowTests <span class="java&#45;keyword">extends</span> grails.test.WebFlowTestCase &#123;
	<span class="java&#45;object">String</span> getFlowId() &#123; <span class="java&#45;quote">"example"</span> &#125;
	&#8230;
&#125;</pre></div><p class="paragraph"/>이 것을 다 끝냈으면 startFlow 메소드로 flow를 시작할 수 있다다. 이 startFlow 메소드는 ViewSelection 객체를 반환한다:<p class="paragraph"/><div class="code"><pre>void testExampleFlow() &#123;
	def viewSelection = startFlow()<p class="paragraph"/>	assertEquals <span class="java&#45;quote">"start"</span>, viewSelection.viewName
	&#8230;
&#125;</pre></div><p class="paragraph"/>이 예제는 viewSelection 객체의 viewName 속성를 이용하여 현재 올바른 상태에 있는지 검사할 수 있다는 것을 보여준다. 그리고 siginalEvent 메소드를 사용하여 event를 발생시킬 수 있다:<p class="paragraph"/><div class="code"><pre>void testExampleFlow() &#123;
	&#8230;
	viewSelection = signalEvent(<span class="java&#45;quote">"go"</span>)
	assertEquals <span class="java&#45;quote">"next"</span>, viewSelection.viewName
	assertEquals <span class="java&#45;quote">"world"</span>, viewSelection.model.hello
&#125;</pre></div><p class="paragraph"/>여기서 “go” 이벤트를 실행시켜야 한다는 것을 플로우에 알렸다. 그래서 “next” 상태로 전이될 수 있다. 이 예제의 전이 액션은 flow 스콥의 hello 변수에 값을 채운다. 그리고 viewSelection의 model속성을 이용하여 변수의 값이 제대로 적용됐는지 검사할 수 있다.<p class="paragraph"/><h4>Testing Tag Libraries(태그 라이브러리 테스트하기)</h4><p class="paragraph"/>태그가 메소드 처럼 실행될 때 결과를 실질적으로 문자열로 반환하기 때문에 태그 라이브러리를 테스트하는 것은 꽤 쉽다. 만약 다음과 같은 태그 라이브러리가 있다면:<p class="paragraph"/><div class="code"><pre>class FooTagLib &#123;
   def bar =  &#123; attrs, body &#45;&#62;
   	   out &#60;&#60; <span class="java&#45;quote">"&#60;p&#62;Hello World!&#60;/p&#62;"</span>
   &#125;<p class="paragraph"/>   def bodyTag =  &#123; attrs, body &#45;&#62;
      out &#60;&#60; <span class="java&#45;quote">"&#60;$&#123;attrs.name&#125;&#62;"</span>
           out &#60;&#60; body()
      out &#60;&#60; <span class="java&#45;quote">"&#60;/$&#123;attrs.name&#125;&#62;"</span>   	
   &#125;
&#125;</pre></div><p class="paragraph"/>테스트는 다음과 같이 작성한다:<p class="paragraph"/><div class="code"><pre>class FooTagLibTests <span class="java&#45;keyword">extends</span> GroovyTestCase &#123;<p class="paragraph"/>  void testBarTag() &#123;
	   assertEquals <span class="java&#45;quote">"&#60;p&#62;Hello World!&#60;/p&#62;"</span>, <span class="java&#45;keyword">new</span> FooTagLib().bar(<span class="java&#45;keyword">null</span>,<span class="java&#45;keyword">null</span>)
   &#125;<p class="paragraph"/>   void testBodyTag() &#123;
	   assertEquals <span class="java&#45;quote">"&#60;p&#62;Hello World!&#60;/p&#62;"</span>, <span class="java&#45;keyword">new</span> FooTagLib().bodyTag(name:<span class="java&#45;quote">"p"</span>) &#123;
	       <span class="java&#45;quote">"Hello World!"</span> 
       &#125;
    &#125;
&#125;</pre></div><p class="paragraph"/>두 번째 예제인 testBodyTag를 잘 살펴보자. 태그의 바디를 반환하는 블럭을 넘기는데 이 것으로 바디의 내용을 쉽게 문자열로 표현할 수 있다.<p class="paragraph"/><h4>Testing Tag Libraries with GroovyPagesTestCase(GroovyPagesTestCase로 태그 라이브러리 테스트하기)</h4><p class="paragraph"/>위의 예제를 grails.test.GroovyPagesTestCase 클래스를 사용하여 더 쉽게 테스트할 수 있다.<p class="paragraph"/>GroovyPagesTestCase 클래스는 GroovyTestCase 클래스의 서브클래스이고 GSP 렌더링의 출력을 테스팅할 수 있는 메소드들이 추가되어 있다.<p class="paragraph"/><blockquote class="note">
GroovyPagesTestCase는 오직 통합 테스트에서만 사용할 수 있다.
</blockquote><p class="paragraph"/>다음과 같이 날짜를 표현하는(formatting) 태그 라이브러리가 있다고 하면:<p class="paragraph"/><div class="code"><pre>class FormatTagLib &#123;
	def dateFormat = &#123; attrs, body &#45;&#62; 
		out &#60;&#60; <span class="java&#45;keyword">new</span> java.text.SimpleDateFormat(attrs.format) &#60;&#60; attrs.date
	&#125;
&#125;</pre></div><p class="paragraph"/>이 것은 다음과 같이 쉽게 태스트할 수 있다:<p class="paragraph"/><div class="code"><pre>class FormatTagLibTests <span class="java&#45;keyword">extends</span> GroovyPagesTestCase &#123;
	void testDateFormat() &#123;
		def template = '&#60;g:dateFormat format=<span class="java&#45;quote">"dd&#45;MM&#45;yyyy"</span> date=<span class="java&#45;quote">"$&#123;myDate&#125;"</span> /&#62;'<p class="paragraph"/>		def testDate = &#8230; // create the date
		assertOutputEquals( '01&#45;01&#45;2008', template, &#91;myDate:testDate&#93; )
	&#125;
&#125;</pre></div><p class="paragraph"/>또 GroovyPagesTestCase 클래스의 applyTemplate 메소드를 사용하여 GSP의 결과를 얻을 수 있다:<p class="paragraph"/><div class="code"><pre>class FormatTagLibTests <span class="java&#45;keyword">extends</span> GroovyPagesTestCase &#123;
	void testDateFormat() &#123;
		def template = '&#60;g:dateFormat format=<span class="java&#45;quote">"dd&#45;MM&#45;yyyy"</span> date=<span class="java&#45;quote">"$&#123;myDate&#125;"</span> /&#62;'<p class="paragraph"/>		def testDate = &#8230; // create the date
		def result = applyTemplate( template, &#91;myDate:testDate&#93; )<p class="paragraph"/>		assertEquals '01&#45;01&#45;2008', result
	&#125;
&#125;</pre></div><p class="paragraph"/><h4>Testing Domain Classes(도메인 클래스 테스트하기)</h4><p class="paragraph"/>보통 도메인 클래스를 테스트하는 것은 <a href="../guide/single.html#5. Object Relational Mapping (GORM)" class="guide">GORM API</a>의 문제이지만 먼저 알아야 하는 것들이 있다. 만약 쿼리를 테스트하고 있다면 데이터베이스에 저장돼 올바른 상태가 보장되도록 종종 “플러쉬(flush)“시켜야만 한다. 예를 들어 다음과 같은 예제가 있다면:<p class="paragraph"/>
<div class="code"><pre>void testQuery() &#123;
	def books = &#91; <span class="java&#45;keyword">new</span> Book(title:<span class="java&#45;quote">"The Stand"</span>), <span class="java&#45;keyword">new</span> Book(title:<span class="java&#45;quote">"The Shining"</span>)&#93;
	books&#42;.save()<p class="paragraph"/>	assertEquals 2, Book.list().size()
&#125;</pre></div><p class="paragraph"/>이 테스트는 <a href="../ref/Domain Classes/save.html" class="domainClasses">save</a> 메소드가 호출되면 바로 Book 인스턴스는 저장되지 않으므로 실패할 것이다. save를 호출하는 것은 단지 하이버네이트가 언젠가 인스턴스를 데이터베이스에 저장해야 한다는 것을 알리는 것뿐이다. 만약 즉시 저장되게 하고 싶다면 “플러쉬”시켜야 한다.<p class="paragraph"/><div class="code"><pre>void testQuery() &#123;
	def books = &#91; <span class="java&#45;keyword">new</span> Book(title:<span class="java&#45;quote">"The Stand"</span>), <span class="java&#45;keyword">new</span> Book(title:<span class="java&#45;quote">"The Shining"</span>)&#93;
	books&#42;.save(flush:<span class="java&#45;keyword">true</span>)<p class="paragraph"/>	assertEquals 2, Book.list().size()
&#125;</pre></div><p class="paragraph"/>이 예제는 flush 인자의 값을 true로 넘기기 때문에 즉시 데이터베이스에 저장된다. 그래서 이제 데이터베이스에 질의해도 된다.
<h2><a name="9.3 Functional Testing">9.3 Functional Testing</a></h2>기능 테스트는 어플리케이션을 실행시키는 테스트이고 보통 자동화하기 어렵다. Grails는 기본적으로 기능 테스트를 지원하지 않는다. 하지만 <a href="http://webtest.canoo.com/" target="blank">Canoo 웹 테스트 플러그인</a> 이 있다.<p class="paragraph"/>웹 테스트를 설치하기 위해서 다음과 같은 명령을 실행한다:<p class="paragraph"/><div class="code"><pre>grails install&#45;plugin webtest</pre></div><p class="paragraph"/>웹 테스트와 Grails를 함께 사용하는 방법은 <a href="http://grails.org/Functional+Testing" target="blank">위키</a>를 참조해야 한다.
<h1><a name="10. Internationalization">10. Internationalization</a></h1>Grails의 국제화는 Spring MVC의 국제ghk 지원에 껍데기를 씌운 것이다. 모든 뷰에서 사용자의 Locale에 따라 적절히 텍스트가 표현되도록 할 수 있다. Java의 <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Locale.html" class="api">Locale</a> 클래스의 문서를 인용하자면:<p class="paragraph"/><blockquote class="quote">
Locale은 지정학적인, 정치적인, 문화적인 어떤 것을 나태낸다. 이를 위해 Locale을 필요로하는 행위를 Locale-sensitive라고 부른다. 사용자에 따라 정보를 조작하기위해 Locale을 사용한다. 예를 들어 숫자를 표시하는 일은 Locale-sensitive라 할 수 있다. 숫자는 사용자가 속한 지역, 문화, 관례에 따르는 형식으로 표현돼야 한다.
</blockquote><p class="paragraph"/>하나의 Locale은 <a href="http://www.loc.gov/standards/iso639-2/englangn.html" target="blank">언어코드</a>와 <a href="http://www.iso.ch/iso/en/prods-services/iso3166ma/02iso-3166-code-lists/list-en1.html" target="blank">국가코드</a>로 이루어진다. 예를들어 "en_US"는 미국 영어를 나타내고, "en_GB"는 영국 영어를 나타내는 코드이다.
<h2><a name="10.1 Understanding Message Bundles">10.1 Understanding Message Bundles</a></h2>자 이제 Locale에 대한 개념이 잡혔다면 Grails에서 Locale를 이용하기 위해서 메시지 번들을 만든다. 이 메시지 번들은 사용자에게 보여주기 위한 여러가지 다른 언어들을 담고 있다. 메시지 번들은 Grails에서 “grails-app/i18n” 디렉토리에 위치하며 간단한 Java 프로퍼티파일이다.<p class="paragraph"/>각 번들의 이름은 관례적으로 “messages”로 시작하고 Locale로 끝난다. Grails는 grails-app/i18n 디렉토리에 다양한 언어들을 위해 만들어진 메시지 번들을 가지고 있다.<p class="paragraph"/><div class="code"><pre>messages.properties
messages_de.properties
messages_es.properties
etc.</pre></div><p class="paragraph"/>기본적으로 Grails는 사용자가 자신의 Locale을 지정하지 않으면 message.properties파일에서 메시지를 얻어올 것이다. 필요한 Locale 이름으로 끝나는 새로운 properties 파일을 만드는 것 만으로 간단히 새로운 메시지 번들을 만들 수 있다. 예를 들어 영국 영어를 위해서는 messages_en_GB.properties 파일을 생성하면 된다.
<h2><a name="10.2 Changing Locales">10.2 Changing Locales</a></h2>기본적으로 사용자의 Locale은 요청받은 Accept-Language 헤더에 따른다. 하지만 Grails는 사용자가 Locale을 변경할 수 있는 기능을 제공한다. 간단하게 요청 인자로 “lang”을 사용하기만 하면 된다.<p class="paragraph"/><div class="code"><pre>/book/list?lang=es</pre></div><p class="paragraph"/>Grails는 알아서 사용자의 Locale을 변경시키고, 이를 쿠키에 저장하므로 이어지는 요청은 새로운 Header를 가질것이다 (역주, 즉 쿠키로 반영하기 위한 헤더 변경)
<h2><a name="10.3 Reading Messages">10.3 Reading Messages</a></h2><h4>Reading Messages in the View(뷰에서 메시지 읽어오기)</h4><p class="paragraph"/>메시지가 필요한곳은 대부분 뷰 안에서이다. 뷰에서 메시지를 읽어오기 위해서는 간단히 <a href="../ref/Tags/message.html" class="tags">message</a> 태그를 사용한다.<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:message code=<span class="xml&#45;quote">"my.localized.content"</span> /&#62;</span></pre></div><p class="paragraph"/>적절한 Locale 접미사를 가진 message.properties 파일에 아래와 같이 key를 가지고 있으면 Grails는 해당 메시지를 찾는다.<p class="paragraph"/><div class="code"><pre>my.localized.content=Hola, Me llamo John. Hoy es domingo.</pre></div><p class="paragraph"/>종종 메시지에 인자를 전달해야할 필요가 있음을 기억하라. 이것은 메시지태그를 통해 전달할 수 있다.<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:message code=<span class="xml&#45;quote">"my.localized.content"</span> args=<span class="xml&#45;quote">"$&#123; &#91;'Juan', 'lunes'&#93; &#125;"</span> /&#62;</span></pre></div><p class="paragraph"/>그리고 메시지에서 위치지정 파라미터를 사용한다:<p class="paragraph"/><div class="code"><pre>my.localized.content=Hola, Me llamo &#123;0&#125;. Hoy es &#123;1&#125;.</pre></div><p class="paragraph"/><h4>Reading Messages in Controllers and Tag Libraries(컨트롤러나 태그라이브러리에서 메시지 읽어오기)</h4><p class="paragraph"/>컨트롤러에서도 태그를 메소드처럼 호출할 수 있기 때문에 컨트롤러에서도 쉽게 메시지를 읽을 수 있다:<p class="paragraph"/><div class="code"><pre>def show = &#123;
	def msg = message(code:<span class="java&#45;quote">"my.localized.content"</span>, args:&#91;'Juan', 'lunes'&#93;)
&#125;</pre></div><p class="paragraph"/>같은 방법으로 태그 라이브러리에서도 사용할 수 있다. 하지만 <a href="../guide/single.html#6.3 Tag Libraries" class="guide">태그 라이브러리</a>의 <a href="../guide/single.html#6.3.4 Tag Namespaces" class="guide">네임스페이스</a>가 다른 경우 “g.”를 앞에 붙여줘야 한다:<p class="paragraph"/><div class="code"><pre>def myTag = &#123; attrs, body &#45;&#62;
	def msg = g.message(code:<span class="java&#45;quote">"my.localized.content"</span>, args:&#91;'Juan', 'lunes'&#93;)
&#125;</pre></div><h1><a name="11. Security">11. Security</a></h1>Grails는 보안면에 있어서 자바 서블릿과 동일한 수준이며, 더하지도 덜하지도 않다. 하지만 서블릿(Grails를 비롯)은 보안측면에 매우 안전하다. 일반적인 버퍼오버런과 비정상 URL공격에 있어서 광범위하게 안전하며 그 이유는 코드의 토대가 되는 JVM의 특성때문이다.<p class="paragraph"/>웹에서의 보안문제는 일반적으로 개발자의 순진함이나 실수로부터 발생하며 Grails에는 일반적인 실수를 방지하거나 보안에 안전한 프로그램을 작성하기 쉽도록 돕는 기능이 있다.<p class="paragraph"/><h4>What Grails Automatically Does(Grails가 자동으로 하는 것)</h4><p class="paragraph"/>Grails는 기본적으로 안전에 대한 몇 가지 매커니즘을 내장하고 있다.
<ol>
<li>모든 표준적인 데이터베이스 접근은 <a href="../guide/single.html#5. Object Relational Mapping (GORM)" class="guide">GORM</a> 도메인 객체를 통해 이루어지며 이는 자동적으로 SQL 인젝션 공격으로부터 SQL을 보호한다.</li>
<li>기본적인 <a href="../guide/single.html#16. Scaffolding" class="guide">scaffolding</a>은 데이터를 화면에 표시할 때 모든 데이터 필드를 HTML로부터 보호하는 템플릿이다.</li>
<li>Grails는 태그(<a href="../ref/Tags/link.html" class="tags">link</a>, <a href="../ref/Tags/form.html" class="tags">form</a>, <a href="../ref/Tags/createLink.html" class="tags">createLink</a>, <a href="../ref/Tags/createLinkTo.html" class="tags">createLinkTo</a>, 기타)를 생성하는 링크는 인젝션 인젝션으로부터 지켜주는 적절한 보호 메커니즘을 사용한다.</li>
<li>Grails는 인젝션 공격을 막기 위해 여러분이 HTML, JavaScript, URL들로 데이터를 표현할 때 쉽게 데이터를 보호하는 코덱(<a href="../guide/single.html#11.2 Encoding and Decoding Strings" class="guide">codecs</a>)을 제공한다.</li>
</ol><p class="paragraph"/><h2><a name="11.1 Securing Against Attacks">11.1 Securing Against Attacks</a></h2><h4>SQL injection(SQL 인젝션)</h4><p class="paragraph"/>GORM 도메인 클래스에 놓여있는 기술인 하이버네이트는 데이터베이스에 자료를 입력할때 자동으로 데이터를 분리하여 처리한다. 그렇기 때문에 이 것는 그다지 문제거리가 되지 않는다. 하지만 확인하지 않은 요청 파라미터를 사용하여 잘못된 HQL 코드를 만들게 될 가능성이 있다. 예를 들어 아래와 같이 동작하는 것은 HQL 인젝션에 대해 취약하다:<p class="paragraph"/><div class="code"><pre>def vulnerable = &#123;
	def books = Book.find(<span class="java&#45;quote">"from Book as b where b.title ='"</span> + params.title + <span class="java&#45;quote">"'"</span>)
&#125;</pre></div><p class="paragraph"/>이런 식으로 코드를 짜면 안된다. 파라미터로 전달하려면 이름을 통해서나 위치지정 파라미터를 통해서 전달해야 한다:<p class="paragraph"/><div class="code"><pre>def safe = &#123;
	def books = Book.find(<span class="java&#45;quote">"from Book as b where b.title =?"</span>, &#91;params.title&#93;)
&#125;</pre></div><p class="paragraph"/>
<h4>Phishing(피싱)</h4><p class="paragraph"/>공개적인 관계들은 고객과의 커뮤니케이션에서 서비스 브랜드를 가로채는 문제를 발생시킨다. 고객들은 받은 메일의 진의를 가려낼 줄 알아야 한다.<p class="paragraph"/><h4>XSS - cross-site scripting injection(크로스 사이트 스크립팅 인젝션)</h4><p class="paragraph"/>여러분의 어플리케이션은 외부 뿐만 아내라 프로그램 내부적에서 발생한 들어오는 요청에 대해서도 최대한 확인하는 것은 매우 중요하다. 티켓팅과 페이지 플로우 시스템은 이에 대한 도움을 주며 Grails는 기본적으로 이런 보안기능을 가진 <a href="http://opensource.atlassian.com/confluence/spring/display/WEBFLOW" target="blank">스프링 웹 플로우</a> 를 지원한다.<p class="paragraph"/>It is important that your application verifies as much as possible that incoming requests were originated from your application and not from another site. Ticketing and page flow systems can help this and Grails' support for <a href="http://opensource.atlassian.com/confluence/spring/display/WEBFLOW" target="blank">Spring Web Flow</a> includes security like this by default.<p class="paragraph"/>뷰에 그려지는 모든 데이터의 값들이 옳게 분리됐는지 확인하는 것 또한 매우 중요하다. 예를 들어 HTML이나 XHTML로 데이터를 그려낼 때 다른이들에게 보여질 데이터나 태그에 악의적인 JavaScript나 HTML을 인젝션 하지 못하도록 확실하게 보장해야 하고 이를 위해 모든 객체들에 대해 <a href="../guide/single.html#11.2 Encoding and Decoding Strings" class="guide">encodeAsHTML</a>을 호출해야 한다. Grails는 이런 목적에서 다양한 동적 인코딩 메소드(<a href="../guide/single.html#11.2 Encoding and Decoding Strings" class="guide">Dynamic Encoding Methods</a>)를 제공한다. 그리고 여러분의 결과물이 사용하는 분리 포맷(escaping format)이 지원되지 않을 경우에는, 그것을 지원하기 위한 사용자만의 코덱을 쉽게 작성 할 수 있다.<p class="paragraph"/>사용자에게 전달 될 다음 리다이렉트 주소 정보를 판단하는데 있어서 요청된 파라미터나 데이터 필드의 사용을 하지 말아야 한다. 만약 예를 들어 성공적으로 로그인 한 사용자의 다음 리다이렉팅 페이지의 URL을 successURL 파라미터로 사용한다면, 공격하는 사람은 공격자의 사이트에서 로그인 과정을 흉내낼 것이고 사용자가 로그인하면 그들의 사이트로 리다이렉트 시킬 것이다. 이것은 잠재적으로 자바스크립트 코드가 사이트에서 로그인 된 계정에 대해 잘못된 방법으로 정보를 얻을 수 있기 때문에 가능하다.<p class="paragraph"/><h4>HTML/URL injection(HTML/URL 인젝션)</h4><p class="paragraph"/>페이지에서 링크를 생성하는 곳에 좋지 않은 데이터가 공급되고 그 링크를 클릭하면 원하지 않는 결과를 나타내거나 원하지 않는 곳으로 사이트를 이동시키거나 요청 파라미터를 변경시킬 것이다.<p class="paragraph"/>HTML/URL 인젝션은 Grails가 제공하는 코덱(<a href="../guide/single.html#11.2 Encoding and Decoding Strings" class="guide">codecs</a>)으로 쉽게 방지할 수 있다. 그리고 Grails가 지원하는 태그라이브러리를 이용해 적절한 곳에 <a href="../guide/single.html#11.2 Encoding and Decoding Strings" class="guide">encodeAsURL</a> 을 사용한다. URL을 생성하는데 있어 자신만의 태그를 만들고자 한다면 이 점을 염두해야 한다.<p class="paragraph"/><h4>Denial of service(서비스 거부)</h4><p class="paragraph"/>이것은 로드밸런서나 다른 어플라이언스에 유용할 것 같지만 공격자가 만들어낸 링크에 의한 쿼리를 처리하는 것과 관련된 문제에도 관련된다. 예를 들어 공격자가 결과 값을 최대로 설정한다면 쿼리는 서버의 메모리 한도를 초과하게 되거나 시스템이 느려지게 된다. 이것을 해결하기 위한 벙법은 요청 파라미터를 동적 파인더나 다른 GORM 쿼리 메소드에 넘겨주기 전에 언제나 깨끗하게 처리를 하는 것이다:<p class="paragraph"/><div class="code"><pre>def safeMax = <span class="java&#45;object">Math</span>.max(params.max?.toInteger(), 100) // never let more than 100 results be returned
<span class="java&#45;keyword">return</span> Book.list(max:safeMax)</pre></div><p class="paragraph"/><h4>Guessable IDs(예측할 수 있는 ID)</h4><p class="paragraph"/>많은 어플리케이션들이 GORM이나 다른 곳들에서 객체정보를 받아오기 위해 URL의 뒷부분을 “id” 로서 사용한다. 특별히 GORM의 경우 보통 순서대로 나열된 정수를 사용하기에 이런 점은 쉽게 예측이 가능하다.<p class="paragraph"/>그러나 요청하는 사용자가 해당 요청한 객체를 볼 수 있는지 사용자에게 응답하기 전에 확인해야 한다.<p class="paragraph"/>이렇게 하지 않으면 “letmein”으로 기본 패스워드를 가지는 것과 같은, “security through obscurity” 보안 문제가 생겨 시스템에 구멍이 날 수 밖에 없다.<p class="paragraph"/>모든 보호되지 않은 URL은 한 가지 방법 이상으로 공개적으로 접근될 수 있다는 것을 염두해두어야 한다.<h2><a name="11.2 Encoding and Decoding Strings">11.2 Encoding and Decoding Strings</a></h2>Grails는 동적 인코딩/디코딩 메소드의 개념을 지원한다. 표준 코덱들은 Grails에 번들로 포함되어 있다. Grails는 또한 개발자에게 그들이 만든 코덱을 실행시에 인식하기위한 단순한 메카니즘을 지원한다.<p class="paragraph"/><h4>Codec Classes(코덱 클래스)</h4><p class="paragraph"/>Grails의 코덱 클래스는 encode 클로져를 포함하거나 decode클로져를 포함하거나 둘다 포함할 것이다. Grails 어플리케이션이 시작되면 Grails 프레임워크는 grails-app/utils/ 디렉토리로부터 동적으로 코덱을 불러들이다.<p class="paragraph"/>Grails 프레임워크는 grails-app/utils/ 디렉토리에서 Codec으로 이름이 끝나는 클래스들에 대해서 살펴볼 것이다. 예를 들어 Grails가 포함하는 표준 코덱중의 하나는 HTMLCodec이다.<p class="paragraph"/>코덱이 코드 블럭이 정의된 encode 프로퍼티를 가지면 Grails는 동적으로 encode 메소드를 생성하고, 그 메소드를 encode 클로져에 정의된 코덱을 나타내는 이름으로 String 클래스에 더할 것이다. 예를 들어 HTMLCodec 클래스는 encode 블럭을 정의하였기 때문에 Grails는 String 클래스에 encodeAsHTML 이란 이름으로 그 클로져를 붙일 것이다.<p class="paragraph"/>HTMLCodec과 URLCodec 클래스는 또한 decode블럭을 정의해 놓았다. 따라서 Grails는 이 두 코덱에 대해서 decodeHTML과 decodeURL이란 이름으로 메소드를 추가할 것이다. 동적 코덱 메소드는 Grails 어플리케이션 어디서나 실행될 수 있다. 예를 들어 report에 description이라는 속성이 다고 가정해보자. 이 속성은 HTML 문서에는 표현되지 말아야 하는 특수문자를 포함하고 있다. GSP에서 이를 해결하는 방법은 한 가지이다. description 속성을 동적 인코드 메소드를 사용하여 아래와 같이 인코딩하는 것이 그 방법이다:<p class="paragraph"/><div class="code"><pre>$&#123;report.description.encodeAsHTML()&#125;</pre></div><p class="paragraph"/>디코딩은 value.decodeHTML() 문법을 이용하여 실행된다.<p class="paragraph"/><h4>Standard Codecs(표준 코덱)</h4><p class="paragraph"/><strong class="bold">HTMLCodec</strong><p class="paragraph"/>이 코덱은 HTML escaping과 unescaping을 수행한다. 따라서 이를 이용하면 값은 HTML태그를 가지지 않고 HTML로 표현될 때 문서의 HTML구조를 변형시키지 않고 값을 문서에 그려낼 수 있다. 예를 들어, 주어진 값이 “Don't you know that 2 &#62; 1?” 라면 HTML문서 속에 안전하게 값을 그려낼 수 없다. 값 속의 &#62; 문자는 HTML의 닫는 태그같아 보이기 때문에 이 값을 만약에 tag의 속성으로 사용한다면 잘못된 결과를 나타낼 것이다. 특히 input tag의 속성으로 사용하게 되면 잘못된 결과를 나타낼 수 있다.<p class="paragraph"/>사용 예제:<p class="paragraph"/><div class="code"><pre>&#60;input name=<span class="java&#45;quote">"comment.message"</span> value=<span class="java&#45;quote">"$&#123;comment.message.encodeAsHTML()&#125;"</span>/&#62;</pre></div><p class="paragraph"/>
<blockquote class="note">
HTML 인코딩은 apostrophe/single quote를 재인코딩 하지 않는다. 따라서 페이지의 속성 값에는 어퍼스트로피 기호로 값을 지저분하게 하지 않기 위해서는 쌍따옴표를 사용해야 한다.
</blockquote><p class="paragraph"/><strong class="bold">URLCodec</strong><p class="paragraph"/>URL 인코딩은 링크, 폼 액션 혹은 필요할 때 언제나 URL을 생성하는 데 필요하다. URL 인코딩은 URL 사용에 있어서 잘못된 문자를 쓰는것을 막아준다. 예를 들어 “Apple &#38; Blackberry”가 URL에 사용하면 URL이 제대로 동작하지 않는다. GET 요청에서 앰퍼센드(&#38;)는 파라미터를 자르는데 사용되기 때문이다.<p class="paragraph"/>사용 예제:<p class="paragraph"/><div class="code"><pre>&#60;a href=<span class="java&#45;quote">"/mycontroller/find?searchKey=$&#123;lastSearch.encodeAsURL()&#125;"</span>&#62;Repeat last search&#60;/a&#62;</pre></div><p class="paragraph"/><strong class="bold">Base64Codec</strong><p class="paragraph"/>Base64 인코딩/디코딩 기능을 수행한다. 예를 들어 다음과 같이 사용한다:<p class="paragraph"/><div class="code"><pre>Your registration code is: $&#123;user.registrationCode.encodeAsBase64()&#125;</pre></div><p class="paragraph"/><strong class="bold">JavaScriptCodec</strong><p class="paragraph"/>JavaScriptCodec은 문자열을 올바른 JavaScript 문자열로 사용할 수 있도록 보장한다:<p class="paragraph"/><div class="code"><pre>Element.update('$&#123;elementId&#125;', '$&#123;render(template: <span class="java&#45;quote">"/common/message"</span>).encodeAsJavaScript()&#125;')</pre></div><p class="paragraph"/>
<h4>Custom Codecs(사용자 정의 코덱)</h4><p class="paragraph"/>어플리케이션은 자신만의 코덱을 정의할 수 있고 Grails는 표준 코덱들과 함께 사용자가 정의한 코덱을 읽어들인다. 사용자 정의 코덱은 grails-app/utils/ 디렉토리에 정의돼야 하며 클래스 이름은 Codec로 끝나야 한다. 코덱은 정적 encode 블럭, 정적 decode 블럭, 혹은 둘 다 가질 수 있다. 블럭은 하나의 인자를 넘겨야 하는데 이 인자는 동적 메소드가 실행된 객체가 된다.<p class="paragraph"/><div class="code"><pre>class PigLatinCodec &#123;
  <span class="java&#45;keyword">static</span> encode = &#123; str &#45;&#62;
    // convert the string to piglatin and <span class="java&#45;keyword">return</span> the result
  &#125;
&#125;</pre></div><p class="paragraph"/>
위의 코덱을 통해 어플리케이션에서는 아래와 같은 일을 할 수 있다:<p class="paragraph"/><div class="code"><pre>$&#123;lastName.encodeAsPigLatin()&#125;</pre></div><p class="paragraph"/><h2><a name="11.3 Authentication">11.3 Authentication</a></h2>기본적으로 현재 인증에 관한 기본 메커니즘이 없다고 하더라도 여러가지 다양한 방법으로 인증을 구현할 수 있다. 하지만 <a href="../guide/single.html#6.1.5 Controller Interceptors" class="guide">interceptors</a>나 <a href="../guide/single.html#6.6 Filters" class="guide">filters</a>를 이용하면 인증 메커니즘을 쉽게 구현할 수 있다.<p class="paragraph"/>필터는 인증이 모든 컨트롤러나 URI 스페이스에 적용될 수 있다. 예를 들어 grails-app/conf/SecurityFilters.groovy 클래스를 아래와 같은 내용으로 생성할 수 있다:<p class="paragraph"/><div class="code"><pre>class SecurityFilters &#123;
   def filters = &#123;
       loginCheck(controller:'&#42;', action:'&#42;') &#123;
           before = &#123;
              <span class="java&#45;keyword">if</span>(!session.user &#38;&#38; actionName != <span class="java&#45;quote">"login"</span>) &#123;
                  redirect(controller:<span class="java&#45;quote">"user"</span>,action:<span class="java&#45;quote">"login"</span>)
                  <span class="java&#45;keyword">return</span> <span class="java&#45;keyword">false</span>					
	           &#125;
           &#125;<p class="paragraph"/>       &#125;
   &#125;
&#125;</pre></div><p class="paragraph"/>loginCheck 필터는 어떤 액션이 실행되기 전에 가로챌 것이다. 그리고 session에 user가 없거나 login 액션을 실행한것이 아니라면 login 액션으로 리다이렉트 한다.<p class="paragraph"/>login 액션은 다음과 같이 간단하게 작성할 수 있다:<p class="paragraph"/><div class="code"><pre>def login = &#123;
	<span class="java&#45;keyword">if</span>(request.get) render(view:<span class="java&#45;quote">"login"</span>)
	<span class="java&#45;keyword">else</span> &#123;
		def u = User.findByLogin(params.login)
		<span class="java&#45;keyword">if</span>(u) &#123;
			<span class="java&#45;keyword">if</span>(u.password == params.password) &#123;
				session.user = u
				redirect(action:<span class="java&#45;quote">"home"</span>)
			&#125;
			<span class="java&#45;keyword">else</span> &#123;
				render(view:<span class="java&#45;quote">"login"</span>, model:&#91;message:<span class="java&#45;quote">"Password incorrect"</span>&#93;)							
			&#125;
		&#125;
		<span class="java&#45;keyword">else</span> &#123;
			render(view:<span class="java&#45;quote">"login"</span>, model:&#91;message:<span class="java&#45;quote">"User not found"</span>&#93;)			
		&#125;
	&#125;
&#125;</pre></div><h2><a name="11.4 Security Plug-ins">11.4 Security Plug-ins</a></h2>
간단한 인증 과정을 넘어서 권한부여(Authorization)나 role과 같은 기능을 필요로 할 수 있다. 그런 경우, 다음과 같은 보안 플러그인을 사용하는것에 대해 고려해볼 수 있다.<p class="paragraph"/><h2><a name="11.4.1 Acegi">11.4.1 Acegi</a></h2>
Acegi 플러그인은 <a href="http://www.acegisecurity.org/" target="blank">Spring Acegi</a> 프로젝트에서 만들어졌고 모든 종류의 인증이나 권한부여 스키마를 구축하는데 있어 유연하고 확장성있는 프렘임워크을 제공한다.<p class="paragraph"/>Acegi 플러러그인은 URI와 롤(Role)과의 매핑을 지정해야 하며 기본 도메인 모델을 사용자, 권한 설정들, 요청 매핑에 대해서 모델링 하는것을 제공한다. <a href="http://grails.org/AcegiSecurity+Plugin" target="blank">위키의 문서</a> 를 참고하면 더 자세한 정보를 얻을 수 있다.<p class="paragraph"/><h2><a name="11.4.2 JSecurity">11.4.2 JSecurity</a></h2><a href="http://www.jsecurity.org/" target="blank">JSecurity</a> 는 자바 POJO 지향의 보안 프레임워크이다. JSecurity는 다시 렐름, 사용자, 역할, 권한을 모델링 하는 기본 도메인 모델을 제공한다. JSecurity를 통해 보안을 적용시킬 controller들에 대해서 JSecAuthBase 클래스를 기반으로 controller를 확장하고 역할을 설정하기 위해 accessControl 코드을 제공해야 한다. 아래는 한 예제이다:<p class="paragraph"/><div class="code"><pre>class ExampleController <span class="java&#45;keyword">extends</span> JsecAuthBase &#123;
    <span class="java&#45;keyword">static</span> accessControl = &#123;
        // All actions require the 'Observer' role.
        role(name: 'Observer')<p class="paragraph"/>        // The 'edit' action requires the 'Administrator' role.
        role(name: 'Administrator', action: 'edit')<p class="paragraph"/>        // Alternatively, several actions can be specified.
        role(name: 'Administrator', only: &#91; 'create', 'edit', 'save', 'update' &#93;)
    &#125;<p class="paragraph"/>    &#8230;
&#125;</pre></div><p class="paragraph"/>JSecurity 플러그인에 관련된 더 많은 정보을 알고 싶다면 <a href="http://grails.org/JSecurity+Plugin+-+Quick+Start" target="blank">JSecurity Quick Start</a>를 참고하라.
<h1><a name="12. Plug-ins">12. Plug-ins</a></h1>플러그인을 통해 Grails의 많은 부분들을 확장할 수 있다. 명령 입력 인터페이스로부터 런타임 환경구성 엔진까지 무엇이든 확장할 수 있도록 이끌어준다. 이어지는 절에서 어떻게 확장하는지에 대해 자세하게 다루고 있다.<p class="paragraph"/><h2><a name="12.1 Creating and Installing Plug-ins">12.1 Creating and Installing Plug-ins</a></h2><h4>Creating Plug-ins(플러그인 생성)</h4><p class="paragraph"/>Grails 플러그인 생성을 하기위해 다음과 같은 명령어를 실행한다.<p class="paragraph"/>
<div class="code"><pre>grails create&#45;plugin &#91;PLUGIN NAME&#93;</pre></div><p class="paragraph"/>이 명령은 위에서 입력한 플러그인 이름에 대한 플러그인 프로젝트를 생성한다. 예를 들어 grails create-plugin example 명령을 실행한다고 하면, Grails는 example이라는 이름의 플러그인 프로젝트를 생성 할 것이다.<p class="paragraph"/>이러한 Grails의 플러그인 디렉토리 구조는 정확히 Grails 프로젝트의 디렉토리 구조와 같다. 단지 플러그인 디렉토리의 최상위에서 “plug-in descriptor”라는 플러그인 Groovy 파일이 있다는 점이 다르다.<p class="paragraph"/>일반적인 Grails 프로젝트가 된다는 것은 다음과 같이 실행하여 바로 테스팅을 할 수 있는 면에서 이득이 많다:<p class="paragraph"/><div class="code"><pre>grails run&#45;app</pre></div><p class="paragraph"/><blockquote class="note">
 기본적으로 플러그인을 생성할때, 곧 바로 컨트롤러가 작동하지 않기에 <a href="../guide/single.html#6.4 URL Mappings" class="guide">URL매핑</a>을 가지지 않는다. 플러그인에 컨트롤러를 추가하려면 우선 grails-app/conf/MyUrlMappings.groovy 클래스를 생성하고 ”/$controller/$action?/$id?”()를 플러그인에 기본 매핑을 추가한다.
</blockquote><p class="paragraph"/>플러그인 디스크립터는 GrailsPlugin으로 끝나는 관례을 따르며 플러그인 프로젝트의 최상위 디렉토리에서 찾을 수 있다. 예를 들어:<p class="paragraph"/><div class="code"><pre>class ExampleGrailsPlugin &#123;
   def version = 0.1<p class="paragraph"/>   &#8230;
&#125;</pre></div><p class="paragraph"/>모든 플러그인은 최상위 디렉토리에 이와 같은 클래스를 가지고 있어야 한다. 플러그인 클래스는 플러그인의 버전을 정의하고 옵션으로 플러그인 확장 지점에다가 여러가지 훅Hook을 정의한다 (짧게 다룸).<p class="paragraph"/>또한 여러가지 특별한 프로퍼티를 사용해서 플러그인에 대한 부가적인 정보를 제공할 수 있다:
<ul class="star">
<li>title - 플러그인에 관한 한문장의 간단한 설명</li>
<li>author - 플러그인 제작자의 이름</li>
<li>authorEmail - 플러그인 제작자의 이메일</li>
<li>description - 플러그인의 특징에 관한 자세한 여러줄에 걸친 설명</li>
<li>documentation - 플러그인에 관련된 문서를 찾아 볼 수 있는 URL</li>
</ul><p class="paragraph"/>다음의 코드는 "Quartz Grails"":http://grails.org/Quartz+plugin 플러그인에서 사용된 예제이다:<p class="paragraph"/><div class="code"><pre>class QuartzGrailsPlugin &#123;
    def version = <span class="java&#45;quote">"0.1"</span>
    def author = <span class="java&#45;quote">"Sergey Nebolsin"</span>
    def authorEmail = <span class="java&#45;quote">"nebolsin@gmail.com"</span>
    def title = <span class="java&#45;quote">"This plugin adds Quartz job scheduling features to Grails application."</span>
    def description = '''
Quartz plugin allows your Grails application to schedule jobs to be
executed using a specified interval or cron expression. The underlying
system uses the Quartz Enterprise Job Scheduler configured via Spring,
but is made simpler by the coding by convention paradigm.
'''
    def documentation = <span class="java&#45;quote">"http://grails.org/Quartz+plugin"</span><p class="paragraph"/>   &#8230;
&#125;</pre></div><p class="paragraph"/><h4>Installing &#38; Distributing Plugins(플러그인의 설치와 배포)</h4><p class="paragraph"/>플러그인을 배포하려면 플러그인의 최상위 디렉토리로 이동해서 아래의 명령을 입력해야 한다.<p class="paragraph"/><div class="code"><pre>grails <span class="java&#45;keyword">package</span>&#45;plugin</pre></div><p class="paragraph"/>이 명령을 통해 하나의 플러그인에 대한 zip파일을 생성한다. 그 파일이름은 grails-로 시작하며 플러그인 이름과 버전을 가진다. 예를 들어 위에서 살펴본 예제 플러그인은 grails-example-0.1.zip로 생성 될 것이다. 또한 package-plugin 명령은 plugin.xml파일을 생성하는데 이 파일은 플러그인에 대한 바이너리 정보가 들어있다.<p class="paragraph"/>한번 플러그인의 배포파일을 생성하면 Grails 프로젝트에서 다음과 같이 입력해서 Grails 프로젝트에서 사용 할 수 있다:<p class="paragraph"/><div class="code"><pre>grails install&#45;plugin /path/to/plugin/grails&#45;example&#45;0.1.zip</pre></div><p class="paragraph"/>플러그인 파일이 원격의 HTTP 서버에 있더라도 다음과 같이 입력할 수 있다:<p class="paragraph"/><div class="code"><pre>grails install&#45;plugin http://myserver.com/plugins/grails&#45;example&#45;0.1.zip</pre></div><p class="paragraph"/><h4>Notes on excluded Artefacts(언급되지 않은 아티펙트 파일에 관한 노트)</h4><p class="paragraph"/><a href="../ref/Command Line/create-plugin.html" class="commandLine">create-plugin</a> 명령이 플러그인이 Grails 어플리케이션으로 동작하기 위한 파일들을 생성한다고 해서 그 생성된 모든 파일이 플러그인으로 묶이는데 전부 포함되지는 않는다. 다음은 생성은 되지만 <a href="../ref/Command Line/package-plugin.html" class="commandLine">package-plugin</a> 명령을 실행시에 포함되지 않는 것들이다.
<ul class="star">
<li><code>grails-app/conf/DataSource.groovy</code></li>
<li><code>grails-app/conf/UrlMappings.groovy</code></li>
<li><code>grails-app/conf/DataSource.groovy</code></li>
<li><code>build.xml</code></li>
<li>Everything within <code>/web-app/WEB-INF</code></li>
</ul><p class="paragraph"/>WEB-INF 디렉토리 속에 생성된 파일들이 필요하다면, _Install.groovy 스크립트(뒤에서 다시 다룸)를 사용하는 것을 추천한다. 게다가 UrlMappings.groovy 파일이 포함에서 제외되더라도 FooUrlMappings.groovy 처럼 다른이름으로 UrlMappings을 지정하면 포함된다.<p class="paragraph"/><h4>Distributing Plugins in Grails Plugins Repository(Grails 플러그인 저장소를 통해 플러그인 배포하기)</h4><p class="paragraph"/>Grails 플러그인을 배포시에 Grails 플러그인 저장소를 이용하여 배포하는 방법을 추천한다. 이것을 이용하면 <a href="../ref/Command Line/list-plugins.html" class="commandLine">list-plugins</a> 명령에서 새로 생성한 플러그인이 볼 수 있다:<p class="paragraph"/><div class="code"><pre>grails list&#45;plugins</pre></div><p class="paragraph"/>이 <a href="../ref/Command Line/plugin-info.html" class="commandLine">plugin-info</a> 명령은 Grails 플러그인 저장소에 있는 모든 플러그인을 보여준다:<p class="paragraph"/><div class="code"><pre>grails plugin&#45;info &#91;plugin&#45;name&#93;</pre></div><p class="paragraph"/>이것은 해당 Plugin에 대한 자세한 내용을 보여주며 그 내용은 Plugin Descriptor속에 저장된 정보이다.<p class="paragraph"/><blockquote class="note">
만약 플러그인을 생성하고 중앙 저장소에서 포함되길 원하는 경우에는 <a href="http://www.g2one.com의" target="blank">G2One team</a> 구성원에게 연락을 바란다. 그러면 그들이 접근 권한을 줄 것이다.<p class="paragraph"/></blockquote><p class="paragraph"/>Grails 플러그인 저장소에 플러그인을 릴리스하기 위한 접근 권한을 가지고 있다면, 간단히 <a href="../ref/Command Line/release-plugin.html" class="commandLine">release-plugin</a> 명령을 실행할 수 있다.<p class="paragraph"/><div class="code"><pre>grails release&#45;plugin</pre></div><p class="paragraph"/>이 명령은 자동으로 코드의 변화를 SVN에 전송하고 <a href="../ref/Command Line/list-plugins.html" class="commandLine">list-plugins</a> 명령을 통해 변경된 부분을 이용할 수 있게끔 해준다.<p class="paragraph"/><h2><a name="12.2 Understanding a Plug-ins Structure">12.2 Understanding a Plug-ins Structure</a></h2>위에서 언급한대로 플러그인은 플러그인 디스크립터를 포함하는 일반적인 Grails 어플리케이션이다. 하지만 플러그인이 설치되면 그 구조는 약간 달라지게 된다. 예를 들어 다음과 같은 플러그인 구조를 살펴보자.<p class="paragraph"/><div class="code"><pre>+ grails&#45;app
     + controllers
     + domain
     + taglib
     etc.
 + lib
 + src
     + java
     + groovy
 + web&#45;app
     + js
     + css</pre></div><p class="paragraph"/>기본적으로 플러그인이 프로젝트에 설치가되면 grails-app디렉토리의 내용들은 plugins/example-1.0/grails-app 디렉토리로 이동된다. 메인 소스의 디렉토리로 복사가 되는것이 아니다. 플러그인은 프로젝트의 주요 소스 트리를 절대 건드리지 않는다.<p class="paragraph"/>하지만 web-app디렉토리 안의 내용 같은 static 리소스는 프로젝트의 web-app디렉토리 안의 특정 디렉토리로 복사될것이다. 예를 들어 web-app/plugins/example-1.0/js 처럼 말이다.<p class="paragraph"/>그러므로 플러그인이 제대로된 위치에서 static 리소스를 불러오도록 하는것은 플러그인의 책임이다. 예를 들어 GSP에서 자바스크립트 소스를 불러오려면 다음과 같이 사용할 수 있다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:createLinkTo dir=<span class="xml&#45;quote">"/plugins/example/js"</span> file=<span class="xml&#45;quote">"mycode.js"</span> /&#62;</span></pre></div><p class="paragraph"/>하지만 이것은 개발하는 과정에서 플러그인이 설치되었을때와 플러그인 자체를 실행할때 다른 주소를 가지는 문제를 일으킬 수 있다.<p class="paragraph"/>이 문제를 쉽게처리하기 위해서 pluginContextPath라는 특별한 변수를 사용하는데, 이것은 플러그인이 자체로 동작하거나 어플리케이션에서 실행되거나에 따라 경로를 자동으로 변경해준다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:createLinkTo dir=<span class="xml&#45;quote">"$&#123;pluginContextPath&#125;/js"</span> file=<span class="xml&#45;quote">"mycode.js"</span> /&#62;</span></pre></div><p class="paragraph"/>실행시에 pluginContextPath 변수는 플러그인만 실행된 것인지 또는 어플리케이션에 설치되었는지에 따라 / 또는 /plugins/example의 값을 갖게 될 것이다.<p class="paragraph"/>플러그인이 lib나 src/java나 src/groovy 디렉토리에서 제공하는 자바와 Groovy 코드는 컴파일되어 메인프로젝트의 web-app/WEB-INF/classes 디렉토리에 위치하여 실행시에 사용가능하게 될 것이다.
<h2><a name="12.3 Providing Basic Artefacts">12.3 Providing Basic Artefacts</a></h2><h4>Adding a new Script(새로운 스크립트를 추가)</h4><p class="paragraph"/>플러그인의 스크립트 디렉토리에서 적절한 Gant 스크립트를 제공함으로써 간단히 새로운 스크립트를 추가할 수 있다.<p class="paragraph"/>
<div class="code"><pre>+ MyPlugin.groovy
   + scripts     &#60;&#45;&#45; 여기에 스크립트를 추가함
   + grails&#45;app
        + controllers
        + services
        + etc.
    + lib</pre></div><p class="paragraph"/><h4>Adding a new Controller, Tag Library or Service(새로운 컨트롤러, 태그라이브러리, 서비스 추가하기)</h4><p class="paragraph"/>플러그인은 grails-app 트리안에 적절한 파일을 생성함으로써 새로운 컨트롤러, 태그라이브러리, 서비스를 추가할 수 있다. 플러그인이 설치되면 플러그인이 설치된 디렉토리에서 로드가 되고 메인 프로그램의 트리로 복사되지는 않는다.<p class="paragraph"/>
it will be loaded from where it is installed and not copied into the main application tree.<p class="paragraph"/><div class="code"><pre>+ ExamplePlugin.groovy
   + scripts
   + grails&#45;app
        + controllers  &#60;&#45;&#45; 여기에 컨트롤러가 추가
        + services &#60;&#45;&#45; 여기에 서비스가 추가
        + etc.  &#60;&#45;&#45; 여기에 다른것들이 추가
    + lib</pre></div><p class="paragraph"/><h2><a name="12.4 Evaluating Conventions">12.4 Evaluating Conventions</a></h2>관례에 의한 런타임 설정 지원에 대해 살펴보기 전에 먼저 플러그인의 관례들이 어떻게 평가되는지 이해해야 한다. 모든 플러그인은 묵시적으로 어플리케이션 변수를 가지는 <a href="../api/org/codehaus/groovy/grails/commons/GrailsApplication.html" class="api">GrailsApplication</a> 인터페이스의 인스턴스이다.<p class="paragraph"/>
GrailsAppication 인터페이스는 프로젝트 안에서 관례을 평가해보는 메소드들을 제공하고, <a href="../api/org/codehaus/groovy/grails/commons/GrailsClass.html" class="api">GrailsClass</a> 인터페이스를 사용하여 GrailsApplication 안의 모든 클래스에 대한 참조를 내부적으로 저장한다.<p class="paragraph"/>GrailsClass는 태그라이브러리나 컨트롤러같은 물리적인 Grails 리소스를 나타낸다. 예를 들어 모든 GrailsClass 인스턴스를 얻기 위해서 다음과 같은 명령을 사용할 수 있다:<p class="paragraph"/><div class="code"><pre>application.allClasses.each &#123; println it.name &#125;</pre></div><p class="paragraph"/>GrailApplication 인스턴스는 관심있는 것들에 대한 타입들에 대해 모아서 갖고 있는 약간의 “매직” 프로퍼티가 있다. 예를 들어 컨트롤러에 관한 것만 얻고 싶다면 다음과 같이 접근할 수 있다:<p class="paragraph"/><div class="code"><pre>application.controllerClasses.each &#123; println it.name &#125;</pre></div><p class="paragraph"/>동적 메소드 관례는 다음과 같다.
<ul class="star">
<li>*Classes - 부분적으로 이름을 가지는 모든 클래스에 대해 얻어온다. 예를 들어 application.controllerClasses.</li>
<li>get*Class - 하나의 이름을 가지는 클래스를 얻어온다. 예를 들어 application.getControllerClass(“ExampleController”)</li>
<li>is*Class - 주어진 클래스가 해당 타입이 맞을 경우에 참을 리턴한다. 예를 들어 application.isControllerClass(ExampleController.class)</li>
<li>add*Class - 해당 타입에 대하여 클래스를 추가하고 그 클래스의 인스턴스를 리턴한다. - 예를 들어 application.addControllerClass(ExampleController.class)</li>
</ul><p class="paragraph"/>GrailsClass 인터페이스는 메소드를 평가하고 동작시키기 위한 자체적인 여러 유용한 메소드를 제공하며, 그것들은 다음과 같다:
<ul class="star">
<li>getPropertyValue - 클래스의 주어진 프로퍼티의 초기 값을 얻어온다.</li>
<li>hasProperty - 프로퍼티를 가진다면 참을 리턴한다.</li>
<li>newInstance - 이 클래스의 한 인스턴스를 생성한다.</li>
<li>getName - 가능하다면 트레일링 관습을 제외한 어플리케이션에서의 클래스의 논리적인 이름을 리턴한다.</li>
<li>getShortName - 패키지 접두어를 제외한 클래스의 짧은 이름을 리턴한다.</li>
<li>getFullName - 패키지 이름과 관습 트레일링을 포함한 어플리케이션에서의 클래스의 완전한 이름을 리턴한다.</li>
<li>getPropertyName - 프로퍼티 이름으로 클래스의 이름을 리턴한다.</li>
<li>getLogicalPropertyName - 가능하다면 트레일링 관습을 뺀 논리적인 클래스에서의 프로퍼티의 이름을 리턴한다.</li>
<li>getNaturalName - 프로퍼티의 이름을 자연스러운 단어로 리턴한다.(예. 'lastName' 는 'Last Name' 가 된다)</li>
<li>getPackageName - 패키지의 이름을 리턴한다.</li>
</ul><p class="paragraph"/>For a full reference refer to the <a href="../api/org/codehaus/groovy/grails/commons/GrailsClass.html" class="api">javadoc API</a>.<h2><a name="12.5 Hooking into Build Events">12.5 Hooking into Build Events</a></h2><h4>Post-Install Configuration and Participating in Upgrades(설치후 설정과 업그레이드에 관여하기)</h4><p class="paragraph"/>Grails 플러그인은 설치후 설정(Post-install Configuration)을 할 수 있으며 어플리케이션 업그레이드 프로세스(<a href="../ref/Command Line/upgrade.html" class="commandLine">upgrade</a> 명령)에 관여할 수 있다. 이것은 특별한 이름을 가진 두개의 스크립트를 통해 실행된다. 두 스크립트는 Script디렉토리에 위치하며 그 이름은 _Install.groovy 과_Upgrade.groovy이다.<p class="paragraph"/>_Install.groovy 파일은 플러그인이 설치 된 후에 실행이 된다. _Upgrade.groovy 파일은 <a href="../ref/Command Line/upgrade.html" class="commandLine">upgrade</a> 명령을 통해 사용자가 어플리케이션을 업그레이드 할 때 마다 실행이 된다.<p class="paragraph"/>이 스크립트들은 <a href="../guide/single.html#4. The Command Line" class="guide">Gant</a> 스크립트이기 때문에 Gant의 모든 파워풀한 기능을 사용할 수 있다. Gant의 표준 변수에 추가된 것으로는 pluginBasedir변수이며, 플러그인이 설치되는 기본 디렉토리를 가리키고 있다.<p class="paragraph"/>아래의 한 예제를 보면 _Install.groovy스크립트는 grails-app디렉토리 아래에 새로운 디렉토리를 생성하고 설정 템플릿을 설치한다:<p class="paragraph"/><div class="code"><pre>Ant.mkdir(dir:<span class="java&#45;quote">"$&#123;basedir&#125;/grails&#45;app/jobs"</span>)
Ant.copy(file:<span class="java&#45;quote">"$&#123;pluginBasedir&#125;/src/samples/SamplePluginConfiguration.groovy"</span>,
         todir:<span class="java&#45;quote">"$&#123;basedir&#125;/grails&#45;app/conf"</span>)<p class="paragraph"/>// To access Grails home you can use following code:
// Ant.property(environment:<span class="java&#45;quote">"env"</span>)
// grailsHome = Ant.antProject.properties.<span class="java&#45;quote">"env.GRAILS_HOME"</span></pre></div><p class="paragraph"/>
<h4>Scripting events(스트립팅 이벤트)</h4><p class="paragraph"/>플러그인을 통해 명령줄 스크립팅 이벤트를 가로채는것이 가능하다. 이 이벤트들은 Grails 명령이나 플러그인 스크립트의 실행중에 트리거된다.<p class="paragraph"/>예를 들어, 상태 업데이트 출력(예, “Tests passed”, “Server running”)을 가로챌 수도 있고, file들의 생성되는 시점에도 가로챌 수 있다.<p class="paragraph"/>플러그인이 필요한 이벤트를 듣기 위해서, 플러그인은 단지 Events.groovy 스크립트를 제공하면 된다. 더 많은 정보를 살펴보려면 이벤트의 가로채기(<a href="../guide/single.html#4.3 Hooking into Events" class="guide">Hooking into Events</a>)에 관한 문서를 살펴보라.
<h2><a name="12.6 Hooking into Runtime Configuration">12.6 Hooking into Runtime Configuration</a></h2>Grails는 시스템의 여러 다양한 부분에 영향을 주거나 관례에 의해 런타임 구성을 수행하는데 관한 몇 가지 가로채는 방법을 제공한다.<p class="paragraph"/><h4>Hooking into the Grails Spring configuration(Grails Spring 설정에서 가로채기)</h4><p class="paragraph"/>먼저 코드로 할당되는 doWithSpring 프로퍼티를 제공함으로써 Grails 런타임 구성에서 가로챌 수 있다. 예를 들어 아래의 코드는 국제화(<a href="../guide/single.html#10. Internationalization" class="guide">i18n</a>)를 지원하기 위한 코어 Grails 플러그인 중에서 가져온 코드이다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> org.springframework.web.servlet.i18n.CookieLocaleResolver;
<span class="java&#45;keyword">import</span> org.springframework.web.servlet.i18n.LocaleChangeInterceptor;
<span class="java&#45;keyword">import</span> org.springframework.context.support.ReloadableResourceBundleMessageSource;<p class="paragraph"/>class I18nGrailsPlugin &#123;<p class="paragraph"/>	def version = 0.1<p class="paragraph"/>	def doWithSpring = &#123;
		messageSource(ReloadableResourceBundleMessageSource) &#123;
			basename = <span class="java&#45;quote">"WEB&#45;INF/grails&#45;app/i18n/messages"</span>
		&#125;
		localeChangeInterceptor(LocaleChangeInterceptor) &#123;
			paramName = <span class="java&#45;quote">"lang"</span>
		&#125;
		localeResolver(CookieLocaleResolver)
	&#125;
&#125;</pre></div><p class="paragraph"/>이 플러그인은 Grails messageSource Bean과 로케일 풀이(Resolution)와 로케일간 이동을 관리하는 여러 다른 Bean을 만든다. 이렇게 하기 위해 <a href="../guide/single.html#14. Grails and Spring" class="guide">Spring Bean Builder</a> 문법을 이용한다.<p class="paragraph"/><h4>Participating in web.xml Generation(Web.xml 파일 생성에 참여하기)</h4><p class="paragraph"/>Grails는 실행 시에 WEB-INF/web.xml 파일을 생성한다. 플러그인이 이 파일을 직접 변경할수는 없지만 이 파일을 생성하는데 참야할 수는 있다. 본질적으로 플러그인은 doWithWebDescriptor 프로퍼티를 제공하며 xmlSlurper GPathResult로서 web.xml파일이 전달되는 코드가 할당되어 있다.<p class="paragraph"/>ControllersPlugin의 코드인 아래의 예제를 생각해보자:<p class="paragraph"/><div class="code"><pre>def doWithWebDescriptor = &#123; webXml &#45;&#62;
	def mappingElement = webXml.'servlet&#45;mapping'
	mappingElement + &#123;
		'servlet&#45;mapping' &#123;
			'servlet&#45;name'(<span class="java&#45;quote">"grails"</span>)
			'url&#45;pattern'(<span class="java&#45;quote">"&#42;.dispatch"</span>)
		&#125;
	&#125;
&#125;</pre></div><p class="paragraph"/>플러그인은 마지막 &#60;servlnet-mapping&#62; 엘레먼트에 대한 참조를 가지고 클로져와 코드를 사용하여 프로그램적으로 XML을 수정할 수 있는 XmlSlurper의 기능을 사용하여 Grails의 서블릿을 그 끝에다가 추가한다.<p class="paragraph"/>
<h4>Doing Post Initialisation Configuration(초기화후 설정)</h4><p class="paragraph"/>때때로 Spring <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/context/ApplicationContext.html" class="api">ApplicationContext</a>가 만들어지고 어떠한 런타임 설정을 할 수 있는것은 유용하다. 이런 상황에서 doWithApplicationContext Closure 프로퍼티를 정의할 수 있다.<p class="paragraph"/><div class="code"><pre>class SimplePlugin &#123;
     def name=<span class="java&#45;quote">"simple"</span>
     def version = 1.1<p class="paragraph"/>	 def doWithApplicationContext = &#123; appCtx &#45;&#62;
          SessionFactory sf = appCtx.getBean(<span class="java&#45;quote">"sessionFactory"</span>)
          // <span class="java&#45;keyword">do</span> something here with session factory
	 &#125;
&#125;</pre></div><p class="paragraph"/><h2><a name="12.7 Adding Dynamic Methods at Runtime">12.7 Adding Dynamic Methods at Runtime</a></h2><h4>The Basics(기본)</h4><p class="paragraph"/>Grails 플러그인은 실행시에 Grails의 클래스나 다른 클래스에 대해서 동적메소드를 등록할 수 있도록 한다. 새로운 메소드는 플러그인의 doWithDynamicMethods Closure 안에서 추가될 수 있다.<p class="paragraph"/>Grails가 관리하는 컨트롤러, 태그라이브러리 등등과 같은 클래스에 메소드나 생성자 기타 등등을 <a href="http://groovy.codehaus.org/ExpandoMetaClass" target="blank">ExpandoMetaClass</a> 메커니즘을 통해 각 컨트롤러의 메타클래스(<a href="api:http://groovy.codehaus.org/api/groovy/lang/MetaObjectProtocol.html" target="blank">MetaClass</a>)에 접근하여 추가할 수 있다.<p class="paragraph"/><div class="code"><pre>class ExamplePlugin &#123;
  def doWithDynamicMethods = &#123; applicationContext &#45;&#62;
        application.controllerClasses.each &#123; controllerClass &#45;&#62;
             controllerClass.metaClass.myNewMethod = &#123;&#45;&#62; println <span class="java&#45;quote">"hello world"</span> &#125;
        &#125;
  &#125;
&#125;</pre></div><p class="paragraph"/>이 예제는 묵시적인 Application 객체를 이용하여 모든 컨트롤러 클래스의 메타클래스 인스턴스들에 대한 참조를 얻고 새로운 메소드인 'myNweMethod'를 각 컨트롤러에 추가하는 것이다. 아니면 새로운 메소드를 추가하고자 하는 클래스에 대해 접근하는 방법을 알고 있다면 간단하게 metaClass 프로퍼티를 통해 메타클래스를 참조하여 새로운 메소드를 추가할 수 있다:<p class="paragraph"/><div class="code"><pre>class ExamplePlugin &#123;<p class="paragraph"/>  def doWithDynamicMethods = &#123; applicationContext &#45;&#62;
      <span class="java&#45;object">String</span>.metaClass.swapCase = &#123;&#45;&#62;
           def sb = <span class="java&#45;keyword">new</span> <span class="java&#45;object">StringBuffer</span>()
           delegate.each &#123;
               sb &#60;&#60; (<span class="java&#45;object">Character</span>.isUpperCase(it as <span class="java&#45;object">char</span>) ? 
                      <span class="java&#45;object">Character</span>.toLowerCase(it as <span class="java&#45;object">char</span>) : 
                      <span class="java&#45;object">Character</span>.toUpperCase(it as <span class="java&#45;object">char</span>))
           &#125;
           sb.toString()
      &#125;<p class="paragraph"/>      assert <span class="java&#45;quote">"UpAndDown"</span> == <span class="java&#45;quote">"uPaNDdOWN"</span>.swapCase()       
  &#125;
&#125;</pre></div><p class="paragraph"/>이 예제에서 java.lang.String에 swapCase라는 메소드를 metaClass 프로퍼티를 통해 추가하였다.<p class="paragraph"/><h4>Interacting with the ApplicationContext(ApplicationContext와 주고받기)</h4><p class="paragraph"/>doWithDynamicMethod 클로져는 Spring ApplicationContext 인스턴스를 넘겨 받는다. 이 것은 클로져 내에서 다른 객체를 사용 할 수 있게 해주기 때문에 유용하다. 예를 들어, Hibernate을 함께 사용하는 어떤 메소드를 구현하는 곳에 SessionFactory 인스턴스를 HibernateTemplate과 함께 결합하여 사용할수 있다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> org.springframework.orm.hibernate3.HibernateTemplate<p class="paragraph"/>class ExampleHibernatePlugin &#123;<p class="paragraph"/>   def doWithDynamicMethods = &#123; applicationContext &#45;&#62;<p class="paragraph"/>       application.domainClasses.each &#123; domainClass &#45;&#62;<p class="paragraph"/>           domainClass.metaClass.<span class="java&#45;keyword">static</span>.load = &#123; <span class="java&#45;object">Long</span> id&#45;&#62; 
                def sf = applicationContext.sessionFactory
                def template = <span class="java&#45;keyword">new</span> HibernateTemplate(sf)
				template.load(delegate, id)
           &#125;
       &#125;
   &#125;
&#125;</pre></div><p class="paragraph"/>또한 Spring 컨테이너의 autowiring과 의존성 주입(dependency injection) 기능 덕분에 실행시에 객체에서 의존성을 연결해주기 위해 Application Context를 사용하는 더 강력한 동적 생성자를 구현할 수 있다.<p class="paragraph"/><div class="code"><pre>class MyConstructorPlugin &#123;<p class="paragraph"/>    def doWithDynamicMethods = &#123; applicationContext &#45;&#62;
         application.domainClasses.each &#123; domainClass &#45;&#62;
              domainClass.metaClass.constructor = &#123;&#45;&#62;
                  <span class="java&#45;keyword">return</span> applicationContext.getBean(domainClass.name)
              &#125;
         &#125;<p class="paragraph"/>    &#125;
&#125;</pre></div><p class="paragraph"/>사실 기본 생성자 대신 프로토타입 된 Spring Bean을 살펴보는 어떤 한 생성자로 교체하는 것이다.<p class="paragraph"/><h2><a name="12.8 Participating in Auto Reload Events">12.8 Participating in Auto Reload Events</a></h2><h4>Monitoring Resources for Changes(리소스 변화를 지켜보기)</h4><p class="paragraph"/>종종 리소스의 변화를 살펴보고 그 변화가 일어났을때 다시 불러들이는 것은 그럴만한 가치가 있다. 이것은 실행시에 Grails가 Application의 상태의 진보적인 재로딩 어떻게 구현하는가 이다. 예를 들어 Grails에서 사용하는 ServicePlugin로 부터의 아래의 간략화 한 코드를 살펴보자:<p class="paragraph"/><div class="code"><pre>class ServicesGrailsPlugin &#123;
    &#8230;
    def watchedResources = <span class="java&#45;quote">"file:./grails&#45;app/services/&#42;Service.groovy"</span><p class="paragraph"/>    &#8230;
  def onChange = &#123; event &#45;&#62;
    <span class="java&#45;keyword">if</span>(event.source) &#123;
      def serviceClass = application.addServiceClass(event.source)
      def serviceName = <span class="java&#45;quote">"$&#123;serviceClass.propertyName&#125;"</span>
      def beans = beans &#123;
           <span class="java&#45;quote">"$serviceName"</span>(serviceClass.getClazz()) &#123; bean &#45;&#62;
               bean.autowire =  <span class="java&#45;keyword">true</span>
      &#125;
            &#125;
      <span class="java&#45;keyword">if</span>(event.ctx) &#123;
        event.ctx.registerBeanDefinition(serviceName,
                                       beans.getBeanDefinition(serviceName))
      &#125;
    &#125;
  &#125;
&#125;</pre></div><p class="paragraph"/>먼저 String이나 String 배열로 watchedResources 들을 정의한다. watchedResources 는 살펴볼 리소스에 대한 패턴이나 참조를 담고 있다. 살펴 보는 리소스가 Groovy 파일이고, 그 파일이 변경된다면 그 파일은 자동으로 재로드 되고 onChange 이벤트 객체의 클로져로 보내진다.<p class="paragraph"/>event 객체는 몇 개의 유용한 프로퍼티를 정의한다.
<ul class="star">
<li>event.source - 다시 읽어들인 클래스나 스프링 리소스의 이벤트의 소스</li>
<li>event.ctx - 스프링 ApplicationContext 인스턴스</li>
<li>event.plugin - 리소스를 관리하는 플러그인 객체 (대개 this이다)</li>
<li>event.application - GrailsApplication 인스턴스</li>
</ul><p class="paragraph"/>이런 객체들로부터 관례을 평가할 수 있고 ApplicationContext나 관례에 기반한 기타 등등에 적절한 변화를 적용시킬 수 있다. 위의 “Services” 예제에서 새로운 서비스 빈은 서비스 클래스들중 하나가 바뀌면 ApplicationContext에 다시 등록된다.<p class="paragraph"/><h4>Influencing Other Plugins(다른 플러그인에 영향 주기)</h4><p class="paragraph"/>플러그인에서 변화가 일어날 때 일어나는 변화에 대응하는것 뿐만 아니라 종종 한 플러그인은 다른 플러그인에 영향을 줄 필요가 있다.<p class="paragraph"/>서비스와 컨트롤러 플러그인의 예를 들어보자. 서비스가 다시 로드되면, 컨트롤러 또한 다시 로드되지 않는 한 문제가 발생한다. 그 문제는 다시 로드된 서비스를 예전의 컨트롤러 클래스에 자동으로 연결하려고 할 때 발생한다.<p class="paragraph"/>이를 해결하기 위해 어느 플러그인이 다른 플러그인에 영향을 주는지 지정할 수 있다. 이것이 의미하는 것은 한 플러그인이 변화를 감지했을때 자신은 재로딩 될 것이고 그 후에 모든 영향을 주는 플러그인을 재로딩 할 것이다. 이 점을 ServicesGrailsPlugin의 부분을 통해 볼 수 있다.<p class="paragraph"/><div class="code"><pre>def influences = &#91;'controllers'&#93;</pre></div><p class="paragraph"/><h4>Observing other plugins(다른 플러그인을 관찰하기)</h4><p class="paragraph"/>변화를 관찰하고자 하는 어떤 특정한 플러그인이 있다면 “observe” 프로퍼티를 사용할 수 있다. 지켜보고자 하는 플러그인이 모니터링하는 리소스의 변화를 지켜보는것이 아니라 플러그인의 변화 자체만을 관찰하는 것이다:<p class="paragraph"/><div class="code"><pre>def observe = &#91;<span class="java&#45;quote">"hibernate"</span>&#93;</pre></div><p class="paragraph"/>이 경우에 Hibernate 도메인 클래스가 변화될 때 hibernate 플러그인으로부터 연결된 이벤트를 받을 것이다.
<h2><a name="12.9 Understanding Plug-in Load Order">12.9 Understanding Plug-in Load Order</a></h2>플러그인은 종종 다른 플러그인의 존재 여부에 영향을 받는다. 또한 다른 플러그인의 존재 여부에 따라 적응하기도 한다. 플러그인은 두가지 프로퍼티를 정의하여 이를 다룰 수 있다. 하나는 dependsOn이라 부르는 것이다. 예를 들어 Grails Hibernate 플러그인으로부터 가져온 부분을 살펴보자.<p class="paragraph"/><div class="code"><pre>class HibernateGrailsPlugin &#123;
	def version = 1.0
	def dependsOn = &#91;dataSource:1.0,
	                 domainClass:1.0,
	                 i18n:1.0,
	                 core: 1.0&#93;<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/>위의 예제에서 보듯이 Hibernate 플러그인은 4개의 플러그인에 의존적이다. 그 4개의 플러그인은 dataSource, domainClass, i18n, core 플러그인이다.<p class="paragraph"/>필수로 의존성에 걸리는 플러그인은 Hibernate 플러그인보다 먼저 로드가 된다. 모든 의존성에 걸린 플러그인이 로드되지 않으면, Hibernate 플러그인은 로드되지 않는다.<p class="paragraph"/>하지만, 이것은 의존성에 걸리는 플러그인에 대해서 로드하지 못하면 로드하는 것을 포기하는 굉장히 엄격한 의존성이다. loadAfter 프로퍼티를 통해 좀 더 약한(유연한) 의존성을 가지게 할 수 있다:<p class="paragraph"/><div class="code"><pre>def loadAfter = &#91;'controllers'&#93;</pre></div><p class="paragraph"/>controller 플러그인이 존재한다면 controllers 플러그인이 로드된 이후에 이 플러그인은 로드될 것이다. controller 플러그인이 존재하지 않는다면 그냥 이 플러그인은 의존성 없이 로드될 것이다. 플러그인은 다른 플러그인이 로드되었는지에 대해서 적응할 수 있다. 예를 들어 Hibernate 플러그인은 doWithSpring 클로져에서 아래와 같은 코드를 가지고 있다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">if</span>(manager?.hasGrailsPlugin(<span class="java&#45;quote">"controllers"</span>)) &#123;
	openSessionInViewInterceptor(OpenSessionInViewInterceptor) &#123;
        	flushMode = HibernateAccessor.FLUSH_MANUAL
	        sessionFactory = sessionFactory
	&#125;
        grailsUrlHandlerMapping.interceptors &#60;&#60; openSessionInViewInterceptor
  &#125;</pre></div><p class="paragraph"/>Hibernate 플러그인은 controllers플러그인이 로드되었을 때만 OpenSessionInViewInterceptor를 등록한다. manager변수는 <a href="../api/org/codehaus/groovy/grails/plugins/GrailsPluginManager.html" class="api">GrailsPluginManager</a> 인터페이스의 인스턴스이며 어떠한 플러그인이라도 다른 플러그인이나 GrailsPluginManager 자신과의 상호작용에 대한 메소드를 지원한다.
<h1><a name="13. Web Services">13. Web Services</a></h1>Web services are all about providing a web API onto your web application and are typically implemented in either <a href="http://en.wikipedia.org/wiki/SOAP" target="blank">SOAP</a> or <a href="http://en.wikipedia.org/wiki/Representational_State_Transfer" target="blank">REST</a>.<p class="paragraph"/>웹서비스라는것은 웹 어플리케이션에 대한 웹 API를 제공하는 것에 대한 모든것을 말한다. 이것은 일반적으로 <a href="http://en.wikipedia.org/wiki/SOAP" target="blank">SOAP</a> 나 <a href="http://en.wikipedia.org/wiki/Representational_State_Transfer" target="blank">REST</a>로 구현한다.<p class="paragraph"/><h2><a name="13.1 REST">13.1 REST</a></h2>REST는 사실 그 자체로는 어떠한 기술도 아니고 구조적인 형태이다. REST는 매우 간단하고 URL형태와 결합된 보통의 XML이나 JSON을 통신 매체로 사용하는 것이다. 이 URL 형태은 기존(underlying) 시스템의 “표현(representational)“과 GET, PUT, POST, DELETE와 같은 HTTP 메소드을 의미한다.<p class="paragraph"/>각 HTTP메소드는 하나의 액션에 연결된다. 예를들어 GET은 데이터를 얻어오기위해, PUT은 데이터를 생성하기위해, POST는 데이터를 수정하기위해, DELETE는 데이터를 삭제하기위해 사용한다. 이러한 점에서, REST는 <a href="../guide/single.html#16. Scaffolding" class="guide">CRUD</a>에 매우 잘 들어맞는다.<p class="paragraph"/><h4>URL patterns(URL 패턴)</h4><p class="paragraph"/>Grails로 REST를 구현하기위한 첫번째 과정은 RESTful URL 매핑(<a href="../guide/single.html#6.4 URL Mappings" class="guide">URL mappings</a>)을 제공하는것이다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">static</span> mappings = &#123;
   <span class="java&#45;quote">"/product/$id?"</span>(controller:<span class="java&#45;quote">"product"</span>)&#123;
       action = &#91;GET:<span class="java&#45;quote">"show"</span>, PUT:<span class="java&#45;quote">"update"</span>, DELETE:<span class="java&#45;quote">"delete"</span>, POST:<span class="java&#45;quote">"save"</span>&#93;
   &#125;	
&#125;</pre></div><p class="paragraph"/>컨트롤러에게 RESTful API를 제공하기 위해 HTTP메소드에 매핑하는 URL 매핑(<a href="../guide/single.html#6.4.5 Mapping to HTTP methods" class="guide">map to HTTP methods</a>)의 기능을 사용했다. GET, PUT, POST, DELETE 같은 각 HTTP 메소드들은 Controller의 액션에 매핑된다.<p class="paragraph"/><h4>XML Marshaling - Reading(XML 마샬링 - 읽기)</h4><p class="paragraph"/>컨트롤러의 GET 메소드 액션은 Grail의 XML 마셜링(<a href="../guide/single.html#6.1.7 XML and JSON Responses" class="guide">XML marshaling</a>) 기능을 사용하여 구현할 수 있다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> grails.converters.&#42;
class ProductController &#123;
	def show = &#123;
		<span class="java&#45;keyword">if</span>(params.id &#38;&#38; Product.exists(params.id)) &#123;
			def p = Product.findByName(params.id)
			render p as XML
		&#125;
		<span class="java&#45;keyword">else</span> &#123;
			def all = Product.list()
			render all as XML
		&#125;
	&#125;
	..
&#125;</pre></div><p class="paragraph"/>이제 만약 좀 더 해야 할 일이 있다면 이름으로 제품의 id을 찾아 반환하거나 모든 제품을 반한하는 것이다. 이 방식에서 /products 로 간다면 모든 제품을 얻을 것이고, 아니면 /products/MacBook으로 간다면 하나의 MacBook만을 얻을 것이다.<p class="paragraph"/><h4>XML Marshalling - Updating(XMl 마샬링 - 업데이트)</h4><p class="paragraph"/>PUT과 POST 같은 업데이트를 지원하기 위해서 params 객체를 쓸 수 있다. <a href="../ref/Controllers/params.html" class="controllers">params</a> 객체는 XML로부터 들어오는 정보를 Grails가 접근하기 쉽도록 개선해놓은 것이다. 다음과 같은 들어오는 XML 패킷이 있다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;?xml version=<span class="xml&#45;quote">"1.0"</span> encoding=<span class="xml&#45;quote">"ISO&#45;8859&#45;1"</span>?&#62;</span>
<span class="xml&#45;tag">&#60;product&#62;</span>
	<span class="xml&#45;tag">&#60;name&#62;</span>MacBook<span class="xml&#45;tag">&#60;/name&#62;</span>
	<span class="xml&#45;tag">&#60;vendor id=<span class="xml&#45;quote">"12"</span>&#62;</span>
		<span class="xml&#45;tag">&#60;name&#62;</span>Apple<span class="xml&#45;tag">&#60;/name&#62;</span>
     <span class="xml&#45;tag">&#60;/vender&#62;</span>
<span class="xml&#45;tag">&#60;/product&#62;</span></pre></div><p class="paragraph"/>데이터 바인딩 절에서 설명한 기술을 이용하는 params 객체를 통해 이 XML 패킷을 읽을 수 있다:<p class="paragraph"/><div class="code"><pre>def save = &#123;
	def p = <span class="java&#45;keyword">new</span> Product(params&#91;'product'&#93;)<p class="paragraph"/>	<span class="java&#45;keyword">if</span>(p.save()) &#123;
		render p as XML
	&#125;
	<span class="java&#45;keyword">else</span> &#123;
		def errors = p.errors.allErrors.collect &#123; g.message(error:it) &#125;
		render(contentType:<span class="java&#45;quote">"text/xml"</span>) &#123;
			error &#123;
				<span class="java&#45;keyword">for</span>(err in errors) &#123;
					message(error:err)
				&#125;
			&#125;
		&#125;
	&#125;
&#125;</pre></div><p class="paragraph"/>이 예제에서 params 객체속에서 'project'키를 사용하여 인덱싱함으로써 Product 클래스의 생성자를 이용하여 xml을 자동으로 생성하고 바인딩할 수 있다. 아래 코드는 그 예제이다:<p class="paragraph"/><div class="code"><pre>def p = <span class="java&#45;keyword">new</span> Product(params&#91;'product'&#93;)</pre></div><p class="paragraph"/>폼 데이터를 전송하는 코드와 XML 요청을 다루는 코드 모두 수정할 필요 없고 XML 요청 뿐만아니라 JSON 요청에도 동일한 방법을 사용할 수 있다.<p class="paragraph"/><blockquote class="note">
만약 여러 클라이언트(REST, HTML 기타)에 대해 여러 응답이 필요하다면 컨텐츠 협상(<a href="../guide/single.html#6.8 Content Negotiation" class="guide">content negotation</a>)을 사용할 수 있음
</blockquote><p class="paragraph"/>그래서 Product 객체는 XML로 저장되고 표현되며, 그렇지 않으면 오류 메시지가 생성된다. 오류 메시지는 Grails의 검증(<a href="../guide/single.html#7. Validation" class="guide">validation</a>)지원을 사용하여 아래와 같은 형식으로 표현된다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;error&#62;</span>
   <span class="xml&#45;tag">&#60;message&#62;</span>The property 'title' of class 'Person' must be specified<span class="xml&#45;tag">&#60;/message&#62;</span>
<span class="xml&#45;tag">&#60;/error&#62;</span></pre></div> <h2><a name="13.2 SOAP">13.2 SOAP</a></h2>Grails는 XFire 플러그인을 통해 SOAP를 지원한다. XFire플러그인은 많이 쓰이는 XFire SOAP스택을 사용하여 Grails에 SOAP지원을 통합시켜준다. XFire 플러그인은 expose 속성을 사용하여 Grails 서비스를 SOAP 서비스(<a href="../guide/single.html#8. The Service Layer" class="guide">services</a>)로 노출시켜준다:<p class="paragraph"/><div class="code"><pre>class BookService &#123;<p class="paragraph"/>  <span class="java&#45;keyword">static</span> expose=&#91;'xfire'&#93;<p class="paragraph"/>  Book&#91;&#93; getBooks()&#123;
    Book.list() as Book&#91;&#93;
  &#125;
&#125;</pre></div><p class="paragraph"/>WSDL은 다음과 같은 URL로 접근가능하다.<p class="paragraph"/>XFire 플러그인에 대한 정보는 <a href="http://grails.org/XFire+plugin" target="blank">위키의 문서</a>를 참고하라.
<h2><a name="13.3 RSS and Atom">13.3 RSS and Atom</a></h2>Grails에서 RSS나 Atom에 대한 직접적인 지원은 없다. <a href="../ref/Controllers/render.html" class="controllers">render</a>의 xml 지원을 사용하여 RSS나 ATOM 피드를 만들 수 있다. 하지만 Grails에서 사용할 수 있는 <a href="http://docs.codehaus.org/display/GRAILS/Feeds+Plugin" target="blank">Feed 플러그인</a> 을 사용하여 RSS나 Atom피드를 제공할 수 있다. 이 플러그인은 "ROME"":https://rome.dev.java.net/ 라이브러리를 이용하여 피드를 생성한다. 아래에 그 사용 예제가 있다:<p class="paragraph"/><div class="code"><pre>def feed = &#123;
    render(feedType:<span class="java&#45;quote">"rss"</span>, feedVersion:<span class="java&#45;quote">"2.0"</span>) &#123;
        title = <span class="java&#45;quote">"My test feed"</span>
        link = <span class="java&#45;quote">"http://your.test.server/yourController/feed"</span><p class="paragraph"/>        Article.list().each() &#123;
            entry(it.title) &#123;
                link = <span class="java&#45;quote">"http://your.test.server/article/$&#123;it.id&#125;"</span>
                it.content // <span class="java&#45;keyword">return</span> the content
            &#125;
        &#125;
    &#125;
&#125;</pre></div><h1><a name="14. Grails and Spring">14. Grails and Spring</a></h1>이번 장은 어떻게 Grails를 Spring 프레임워크와 통합하는지 또는 Spring 프레임워크 위에서 구축하는지에 관심이 있는 전문적인 사용자를 위한 것이다. 또한 런타임 Grails 설정을 하는것에 대해 고민하는 <a href="../guide/single.html#12. Plug-ins" class="guide">플러그인 개발자</a>에게 유용하다.
<h2><a name="14.1 The Underpinnings of Grails">14.1 The Underpinnings of Grails</a></h2>Grails는 사실 Spring MVC 어플리케이션이 변장한 것이다. <a href="http://www.springframework.org/docs/MVC-step-by-step/Spring-MVC-step-by-step.html" target="blank">Spring MVC</a>는 Spring Framework에 내재된 MVC 웹 어플리케이션 프레임워크이다. Spring MVC가 사용하기에 쉬운가 라는 점에서 Structs만큼 어렵지만, Grails는 멋지게 설계되고 구조화 되었다. Grails는 다른 프레임워크의 꼭대기에 만들었기에 가장 완벽한 프레임워크가 되었다.<p class="paragraph"/>다음과 같은 부분에서 Grails는 Spring MVC를 확대화(leverage) 한다.
<ul class="star">
<li>기본 컨트롤러 로직 - Grails는 Spring의 <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/servlet/DispatcherServlet.html" class="api">DispatcherServlet</a>을 상속받아 Grails 컨트롤러(<a href="../guide/single.html#6.1 Controllers" class="guide">controllers</a>)의 delegate를 통해 사용함</li>
<li>데이터 바인딩과 검증 - Grails의 검증(<a href="../guide/single.html#7. Validation" class="guide">validation</a>)과 데이터 바인딩 능력은 Spring으로부터 제공받은 것들 위에서 이뤄짐</li>
<li>런타임 설정 - Grails의 전체 런타임 관례기반 시스템은 Spring <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/context/ApplicationContext.html" class="api">ApplicationContext</a>에 의해 서로 연결됨</li>
<li>트랜잭션 - Grails는 <a href="../guide/single.html#5. Object Relational Mapping (GORM)" class="guide">GORM</a>에서 Spring의 트랜잭션 관리구조(transaction management)를 사용함</li>
</ul><p class="paragraph"/>달리 말하자면 Grails는 전체에 걸쳐서 Spring을 품고 동작한다.<p class="paragraph"/><h4>The Grails ApplicationContext</h4><p class="paragraph"/>Spring 개발자들은 종종 Grails ApplicationContext 인스턴스가 어떻게 생성되는지 이해하고 싶어한다. 그 기본구조는 다음과 같다.
<ul class="star">
<li>Grails는 부모 ApplicationContext를 web-app/WEB-INF/applicationContext.xml로부터 생성한다. 이 ApplicationContext는 <a href="../api/org/codehaus/groovy/grails/commons/GrailsApplication.html" class="api">GrailsApplication</a> 객체와 <a href="../api/org/codehaus/groovy/grails/plugins/GrailsPluginManager.html" class="api">GrailsPluginManager</a>를 설정한다.</li>
<li>ApplicationContext 를 Grails의 부모로서 사용하여 GrailsApplication의 인스턴스를 통해 관례을 분석하고 웹 어플리케이션의 최상위root ApplicationContext 로서 사용되는 자식 ApplicationContext를 생성한다.</li>
</ul><p class="paragraph"/><h4>Configured Spring Beans(설정된 Spring Bean)</h4><p class="paragraph"/>대부분의 Grails 설정은 런타임에 일어난다. 각 <a href="../guide/single.html#12. Plug-ins" class="guide">플러그인</a>은 아마도 Spring Bean을 설정 할 것이다. Spring Bean은 ApplicationContext에 등록되어 있다. 한 참조가 어떤 Bean으로 설정 되기 위해(to which beans are configured) 레퍼런스 가이드를 참조한다. 그것은 각 Grails 플러그인의 어떤 설명이나 플러그인들이 어떤 Bean을 설정할지에 대한 참조 가이드이다(Most of Grails' configuration happens at runtime. Each <a href="../guide/single.html#12. Plug-ins" class="guide">plug-in</a> may configure Spring beans that are registered with the <code>ApplicationContext</code>. For a reference as to which beans are configured refer to the reference guide which describes each of the Grails plug-ins and which beans they configure).<h2><a name="14.2 Configuring Additional Beans">14.2 Configuring Additional Beans</a></h2><h4>Using XML(XML 사용)</h4><p class="paragraph"/>Bean은 Grails 어플리케이션의 grails-app/conf/spring/resources.xml 파일을 사용하여 설정 할 수 있다. 이 파일은 일반적인 Spring XML 파일이며 Spring 문서는 Spring Bean을 어떤식으로 설정하는지에 대한 <a href="http://static.springframework.org/spring/docs/2.0.x/reference/beans.html#beans-basics" target="blank">가장 좋은 참고자료</a>이다. 간단한 예제로서 다음과 같은 형식으로 하나의 Bean을 설정할 수 있다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;bean id=<span class="xml&#45;quote">"myBean"</span> class=<span class="xml&#45;quote">"my.company.MyBeanImpl"</span>&#62;</span><span class="xml&#45;tag">&#60;/bean&#62;</span></pre></div><p class="paragraph"/>이와 같이 myBean으로 이름지어서 Bean을 한번 설정하면 Grails의 컨트롤러들, 태그라이브러리들, 서비스들 기타 등등에서 사용할 있도록 자동으로 연결된다:<p class="paragraph"/><div class="code"><pre>class ExampleController &#123;<p class="paragraph"/>     def myBean
&#125;</pre></div><p class="paragraph"/><h4>Referencing Existing Beans(존재하는 Bean을 참조하기)</h4><p class="paragraph"/>resources.xml 파일에 정의된 Bean은 관례에 따라 Grails 클래스를 참조할 수 있다. 예를 들어, 한 Bean에서 BookSerivce와 같은 한 서비스에 대한 참조가 필요하면 클래스 이름으로 표현된 프로퍼티(the property name representation)를 사용한다. 예를 들어, BookService의 경우 bookService가 될 것이다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;bean id=<span class="xml&#45;quote">"myBean"</span> class=<span class="xml&#45;quote">"my.company.MyBeanImpl"</span>&#62;</span>
	<span class="xml&#45;tag">&#60;property name=<span class="xml&#45;quote">"bookService"</span> ref=<span class="xml&#45;quote">"bookService"</span> /&#62;</span>	
<span class="xml&#45;tag">&#60;/bean&#62;</span></pre></div><p class="paragraph"/>Bean은 그 자체로 퍼블릭 지정자(setter)를 필요로 하며 Grails에서는 다음과 같이 정의한다.<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">package</span> my.company
class MyBeanImpl &#123;
	BookService bookService
&#125;</pre></div><p class="paragraph"/>자바에서라면 다음과 같다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">package</span> my.company;
class MyBeanImpl &#123;
	<span class="java&#45;keyword">private</span> BookService bookService;
	<span class="java&#45;keyword">public</span> void setBookService(BookService theBookService) &#123;
		<span class="java&#45;keyword">this</span>.bookService = theBookService;
	&#125;
&#125;</pre></div><p class="paragraph"/>많은 Grails 설정이 관례적으로 런타임에 이루어지기 때문에 Bean들을 아무데나 정의하면 안된다. Spring 설정을 통해서 참조할 수 있도록 해야 한다. 예를 들어, Grails DataSource를 참조할 필요가 있다면 다음과 같이 할 수 있다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;bean id=<span class="xml&#45;quote">"myBean"</span> class=<span class="xml&#45;quote">"my.company.MyBeanImpl"</span>&#62;</span>
	<span class="xml&#45;tag">&#60;property name=<span class="xml&#45;quote">"bookService"</span> ref=<span class="xml&#45;quote">"bookService"</span> /&#62;</span>	
	<span class="xml&#45;tag">&#60;property name=<span class="xml&#45;quote">"dataSource"</span> ref=<span class="xml&#45;quote">"dataSource"</span> /&#62;</span>
<span class="xml&#45;tag">&#60;/bean&#62;</span></pre></div><p class="paragraph"/>Hibernate SessionFactory가 필요하다면 다음과 같이 할 수 있다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;bean id=<span class="xml&#45;quote">"myBean"</span> class=<span class="xml&#45;quote">"my.company.MyBeanImpl"</span>&#62;</span>
	<span class="xml&#45;tag">&#60;property name=<span class="xml&#45;quote">"bookService"</span> ref=<span class="xml&#45;quote">"bookService"</span> /&#62;</span>	
	<span class="xml&#45;tag">&#60;property name=<span class="xml&#45;quote">"sessionFactory"</span> ref=<span class="xml&#45;quote">"sessionFactory"</span> /&#62;</span>
<span class="xml&#45;tag">&#60;/bean&#62;</span></pre></div><p class="paragraph"/>사용가능한 모든 Bean에 대한 참조를 살펴보려면 참조 가이드에서 플러그인 참조를 살펴보라.<p class="paragraph"/><h4>Using the Spring DSL(Spring DSL 사용)</h4><p class="paragraph"/>Grails가 제공하는 <a href="../guide/single.html#14.3 Runtime Spring with the Beans DSL" class="guide">Spring DSL</a>을 사용하고자 한다면 grails-app/conf/spring/resources.groovy 파일을 만들고 다음과 같은 코드를 가지는 beans로 불리는 메소드를 정의해야 한다.<p class="paragraph"/><div class="code"><pre>beans &#123;
	// beans here
&#125;</pre></div><p class="paragraph"/>XML 예제에 대한 동일한 설정은 다음과 같이 쓸 수 있다:<p class="paragraph"/><div class="code"><pre>beans &#123;
	myBean(my.company.MyBeanImpl) &#123;
		bookService = ref(<span class="java&#45;quote">"bookService"</span>)
	&#125;	
&#125;</pre></div><p class="paragraph"/>이런 방식에서 주요 장점은 이제 beans 정의안에서 로직을 섞을 수 있다. 환경(<a href="../guide/single.html#3.2 Environments" class="guide">environment</a>)에 기반한 예제는 다음과 같다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> grails.util.&#42;
beans &#123;
	<span class="java&#45;keyword">switch</span>(GrailsUtil.environment) &#123;
		<span class="java&#45;keyword">case</span> <span class="java&#45;quote">"production"</span>:
			myBean(my.company.MyBeanImpl) &#123;
				bookService = ref(<span class="java&#45;quote">"bookService"</span>)
			&#125;<p class="paragraph"/>		<span class="java&#45;keyword">break</span>
		<span class="java&#45;keyword">case</span> <span class="java&#45;quote">"development"</span>:
			myBean(my.company.mock.MockImpl) &#123;
				bookService = ref(<span class="java&#45;quote">"bookService"</span>)
			&#125;	
		<span class="java&#45;keyword">break</span>
	&#125;	
&#125;</pre></div><p class="paragraph"/><h2><a name="14.3 Runtime Spring with the Beans DSL">14.3 Runtime Spring with the Beans DSL</a></h2>Spring은 매우 강력하지만 XML 기반 문법은 번거롭고 다양한 수준에서 최근에 Spring 2.0에서 추가된 것들 조차 DRY를 위반한다. Grails의 BeanBuider는 Spring과 그 Core를 사용하여 의존성을 서로 연결하는 간단한 방법을 제공하는 것을 목표로 하고 있다.<p class="paragraph"/>더불어 Spring의 (XML을 통해) 설정하는 방식은 반드시 정적으로 해야 하고, 런타임에 수정하고 설정하기 매우 힘들 뿐 아니라, 프로그램으로 XML을 생성하는 것보다 자주 오류를 발생시키고 틀리기 쉽다. Grails <a href="../api/grails/spring/BeanBuilder.html" class="api">BeanBuilder</a>는 런타임에 컴포넌트들을 서로 함께 프로그램적으로 연결하는것을 가능하게 함으로써 모든 것을 바꾼다. 그래서 시스템 프로퍼티나 환경 변수에 따라 로직을 적응할 수 있도록 할 수 있다.<p class="paragraph"/>이것은 코드가 자신이 속한 환경에 적응할 수 있도록 하며 불필요한 코드의 중복(테스트, 개발, 실제품환경에 대한 서로다른 Spring 설정을 갖는것)을 줄여준다.<p class="paragraph"/><h4>The BeanBuilder class(BeanBuilder 클래스)</h4><p class="paragraph"/>Grails는 <a href="../api/grails/spring/BeanBuilder.html" class="api">grails.spring.BeanBuilder</a> 클래스를 제공하며 Bean 정의들을 만들기위해 동적 Groovy를 사용한다. 기본 코드는 다음과 같다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> org.apache.commons.dbcp.BasicDataSource
<span class="java&#45;keyword">import</span> org.codehaus.groovy.grails.orm.hibernate.ConfigurableLocalSessionFactoryBean;
<span class="java&#45;keyword">import</span> org.springframework.context.ApplicationContext;<p class="paragraph"/>def bb = <span class="java&#45;keyword">new</span> grails.spring.BeanBuilder()<p class="paragraph"/>bb.beans &#123;
	dataSource(BasicDataSource) &#123;
		driverClassName = <span class="java&#45;quote">"org.hsqldb.jdbcDriver"</span>
		url = <span class="java&#45;quote">"jdbc:hsqldb:mem:grailsDB"</span>
		username = <span class="java&#45;quote">"sa"</span>
		password = <span class="java&#45;quote">""</span>
	&#125;
        sessionFactory(ConfigurableLocalSessionFactoryBean) &#123;
              dataSource = dataSource
              hibernateProperties = &#91; <span class="java&#45;quote">"hibernate.hbm2ddl.auto"</span>:<span class="java&#45;quote">"create&#45;drop"</span>,
                                      <span class="java&#45;quote">"hibernate.show_sql"</span>:<span class="java&#45;keyword">true</span>  &#93;
        &#125;<p class="paragraph"/>&#125;<p class="paragraph"/>ApplicationContext appContext = bb.createApplicationContext()</pre></div><p class="paragraph"/><blockquote class="note">
plug-ins나 <a href="../guide/single.html#14.2 Configuring Additional Beans" class="guide">grails-app/conf/spring/resources.groovy</a> 파일에서 새로운 BeanBuider 인스턴스를 새로 만들 필요는 없다. 그 대신 DSL은 묵시적으로 doWithSpring 안에서나 각 beans block에서 사용가능하다.
</blockquote><p class="paragraph"/>위의 예제는 BeanBuider 클래스를 이용하여 어떻게 Hibernate를 적절한 dataSource와 설정을 할 수 있는지를 보여준다.<p class="paragraph"/>각 메소드 호출(이번 경우는 dataSource나 sessionFactory의 호출)은 필히 Spring에서 Bean의 이름에 매핑된다. 메소드에 대한 첫 번째 인자는 Bean의 클래스이며 마지막 인자는 코드 블럭이다. 블럭의 본체에서 표준 Groovy 문법을 이용하여 Bean의 프로퍼티를 정할 수 있다.<p class="paragraph"/>Bean 참조문제는 Bean의 이름을 이용하여 자동적으로 풀어간다. 이것은 위의 예제에서 sessionFactory Bean이 dataSource 참조를 풀어가는 방식을 통해살펴 볼 수 있다.<p class="paragraph"/>Bean 관리에 관계된 일정한 특정 프로퍼티는 아래의 코드에서 볼 수 있듯이 빌더에의해 정해질 수 있다:<p class="paragraph"/><div class="code"><pre>sessionFactory(ConfigurableLocalSessionFactoryBean) &#123; bean &#45;&#62;
    bean.autowire = 'byName'       // Autowiring behaviour. The other option is 'byType'. &#91;autowire&#93;
    bean.initMethod = 'init'       // Sets the initialisation method to 'init'. &#91;init&#45;method&#93;
    bean.destroyMethod = 'destroy' // Sets the destruction method to 'destroy'. &#91;destroy&#45;method&#93;
    dataSource = dataSource
    hibernateProperties = &#91; <span class="java&#45;quote">"hibernate.hbm2ddl.auto"</span>:<span class="java&#45;quote">"create&#45;drop"</span>,
                            <span class="java&#45;quote">"hibernate.show_sql"</span>:<span class="java&#45;keyword">true</span>  &#93;
&#125;</pre></div><p class="paragraph"/>'', '' 안의 문자열은 Spring의 XML 정의 안에서의 Bean 속성(Attribute)과 동일한 이름들이다.<p class="paragraph"/><h4>Using Constructor Arguments(생성자 인자 사용)</h4><p class="paragraph"/>생성자의 인자는 각 메소드의 파라미터를 통해서 정의할 수 있고 Bean의 클래스와 마지막 클로져 사이에 위치한다:<p class="paragraph"/><div class="code"><pre>bb.beans &#123;
   exampleBean(MyExampleBean, <span class="java&#45;quote">"firstArgument"</span>, 2) &#123;
       someProperty = &#91;1,2,3&#93;
   &#125;
&#125;</pre></div><p class="paragraph"/><h4>Configuring the BeanDefinition (Using factory methods) (BeanDefinition을 설정(팩토리 메소드 사용하여))</h4><p class="paragraph"/>클로져의 첫 번째 인자는 Bean 설정 인스턴스의 한 참조이며 팩토리 메소드를 통해 설정하곤 하고 <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/beans/factory/support/AbstractBeanDefinition.html" class="api">AbstractBeanDefinition</a> 클래스상에서는 어떤 메소드도 실행할 수 있다:<p class="paragraph"/><div class="code"><pre>bb.beans &#123;
   exampleBean(MyExampleBean) &#123; bean &#45;&#62;
       bean.factoryMethod = <span class="java&#45;quote">"getInstance"</span>
       bean.singleton = <span class="java&#45;keyword">false</span>
       someProperty = &#91;1,2,3&#93;
   &#125;
&#125;</pre></div><p class="paragraph"/>다른 대안으로서 Bean을 설정하기 위해 정의하는 메소드의 리턴 값을 이용할 수도 있다:<p class="paragraph"/><div class="code"><pre>bb.beans &#123;
   def example = exampleBean(MyExampleBean) &#123;
       someProperty = &#91;1,2,3&#93;
   &#125;
   example.factoryMethod = <span class="java&#45;quote">"getInstance"</span>
&#125;</pre></div><p class="paragraph"/><h4>Using Factory beans(Factory Bean을 이용)</h4><p class="paragraph"/>Spring은 Factory Bean이라는 개념을 정의한다. 그리고 종종 Bean은 클래스로부터 만들어지지 않고 이런 Factory들로부터 만들어진다. 이런 경우 Bean은 어떠한 클래스도 가지지 않으며 대신 Bean으로 Factory Bean의 이름을 넘겨줘야 한다:<p class="paragraph"/><div class="code"><pre>bb.beans &#123;
   myFactory(ExampleFactoryBean) &#123;
       someProperty = &#91;1,2,3&#93;
   &#125;
   myBean(myFactory) &#123;
        name = <span class="java&#45;quote">"blah"</span>
   &#125;
&#125;</pre></div><p class="paragraph"/>이 예제를 살펴보면 클래스 대신 myFactory Bean에 대한 참조를 메소드를 정의하는 Bean으로 넘긴다. 또 다른 것은 Factory Bean에서 호출되도록 Factory 메소드의 이름을 제공하는 것이다. 이것은 Groovy의 네임드 파라미터 문법을 이용하여 한다:<p class="paragraph"/><div class="code"><pre>bb.beans &#123;
   myFactory(ExampleFactoryBean) &#123;
       someProperty = &#91;1,2,3&#93;
   &#125;
   myBean(myFactory:<span class="java&#45;quote">"getInstance"</span>) &#123;
        name = <span class="java&#45;quote">"blah"</span>
   &#125;
&#125;</pre></div><p class="paragraph"/>myBean을 만들기 위해 ExampleFactoryBean의 getInstance메소드를 호출한다.<p class="paragraph"/><h4>Creating Bean References at Runtime(런타임에 Bean 참조를 만들기)</h4><p class="paragraph"/>때때로 런타임에나 만들어야 할 Bean의 이름을 알게 될 수도 있다. 이런 경우 동적으로 Bean이 정의하는 메소드를 실행하려면 문자열 interpolation을 사용할 수 있다:<p class="paragraph"/><div class="code"><pre>def beanName = <span class="java&#45;quote">"example"</span>
bb.beans &#123;
   <span class="java&#45;quote">"$&#123;beanName&#125;Bean"</span>(MyExampleBean) &#123;
       someProperty = &#91;1,2,3&#93;
   &#125;
&#125;</pre></div><p class="paragraph"/>이 경우 앞에서 정의된 beanName 변수를 이용하여 Bean 정의 메소드를 실행할 때 사용한다.<p class="paragraph"/>게다가 Bean의 이름을 런타임까지 알 수 없기 때문에 다른 Bean들과 함께 사용하려면 그것들을 참조할 필요가 있다. 이럴 경우 ref 메소드를 사용한다:<p class="paragraph"/><div class="code"><pre>def beanName = <span class="java&#45;quote">"example"</span>
bb.beans &#123;
   <span class="java&#45;quote">"$&#123;beanName&#125;Bean"</span>(MyExampleBean) &#123;
       someProperty = &#91;1,2,3&#93;
   &#125;
   anotherBean(AnotherBean) &#123;
       example = ref(<span class="java&#45;quote">"$&#123;beanName&#125;Bean"</span>)
   &#125;
&#125;</pre></div><p class="paragraph"/>
AnotherBean의 example 프로퍼티는 exampleBean에 대한 런타임 참조를 사용해 정해진다. ref 메소드는 또한 BeanBuider의 생성자에서 제공된 부모 ApplicationContext로부터의 Bean들을 참조하기 위해서도 사용한다:<p class="paragraph"/><div class="code"><pre>ApplicationContext parent = ...//
der bb = <span class="java&#45;keyword">new</span> BeanBuilder(parent)
bb.beans &#123;
   anotherBean(AnotherBean) &#123;
       example = ref(<span class="java&#45;quote">"$&#123;beanName&#125;Bean"</span>, <span class="java&#45;keyword">true</span>)
   &#125;
&#125;</pre></div><p class="paragraph"/>두번째 파라미터 true는 참조가 parent context에서 Bean을 찾도록 지정한다.<p class="paragraph"/><h4>Using Anonymous (Inner) Beans(익명(내부) Bean 이용)</h4><p class="paragraph"/>Bean의 한 프로퍼티를 Bean 타입으로 인자를 받을 수 있는 코드로 설정해서 익명 내부 Bean을 이용할 수 있다:<p class="paragraph"/><div class="code"><pre>bb.beans &#123;
  marge(Person.class) &#123;
      name = <span class="java&#45;quote">"marge"</span>
      husband =  &#123; Person p &#45;&#62;
 	              name = <span class="java&#45;quote">"homer"</span>
		      age = 45
                      props = &#91;overweight:<span class="java&#45;keyword">true</span>, height:<span class="java&#45;quote">"1.8m"</span>&#93; &#125;
      children = &#91;bart, lisa&#93;
  &#125;
  bart(Person) &#123;
      name = <span class="java&#45;quote">"Bart"</span>
      age = 11
  &#125;
  lisa(Person) &#123;
      name = <span class="java&#45;quote">"Lisa"</span>
      age = 9
  &#125;
&#125;</pre></div><p class="paragraph"/>위의 예제에서 marge Bean의 husband 프로퍼티를 내부 Bean 참조를 생성하는 코드로 정하였다. 또한 Factory Bean을 가지고 있다면 타입을 생략하고 Factory를 설정하는 대신에 넘겨받은 Bean 정의를 사용할 수 있다:<p class="paragraph"/><div class="code"><pre>bb.beans &#123;
  personFactory(PersonFactory.class)
  marge(Person.class) &#123;
      name = <span class="java&#45;quote">"marge"</span>
      husband =  &#123; bean &#45;&#62;
                     bean.factoryBean = <span class="java&#45;quote">"personFactory"</span>
                     bean.factoryMethod = <span class="java&#45;quote">"newInstance"</span>
 	              name = <span class="java&#45;quote">"homer"</span>
		      age = 45
                      props = &#91;overweight:<span class="java&#45;keyword">true</span>, height:<span class="java&#45;quote">"1.8m"</span>&#93; &#125;
      children = &#91;bart, lisa&#93;
  &#125;
&#125;</pre></div><p class="paragraph"/><h4>Abstract Beans and Parent Bean Definitions(추상 Bean과 부모 Bean 정의)</h4><p class="paragraph"/>추상 Bean 정의를 만들기위해서 아무 클래스도 받지 않는 클래스를 정의한다:<p class="paragraph"/><div class="code"><pre>class HolyGrailQuest &#123;
	   def start() &#123; println <span class="java&#45;quote">"lets begin"</span> &#125;
&#125;
class KnightOfTheRoundTable &#123;
   <span class="java&#45;object">String</span> name
   <span class="java&#45;object">String</span> leader
   KnightOfTheRoundTable(<span class="java&#45;object">String</span> n) &#123;
      <span class="java&#45;keyword">this</span>.name = n
   &#125;
   HolyGrailQuest quest<p class="paragraph"/>   def embarkOnQuest() &#123;
       quest.start()
   &#125;
&#125;<p class="paragraph"/>def bb = <span class="java&#45;keyword">new</span> grails.spring.BeanBuilder()
bb.beans &#123;
  abstractBean &#123;
      leader = <span class="java&#45;quote">"Lancelot"</span>
  &#125;
  &#8230;
&#125;</pre></div><p class="paragraph"/>leader 프로퍼티가 “Lancelot”값을 갖도록 하는 추상 Bean을 정의하였다. 이 추상 Bean을 이용하기 위해서 자식 Bean의 부모로 Bean을 정한다:<p class="paragraph"/><div class="code"><pre>bb.beans &#123;
  &#8230;
  quest(HolyGrailQuest)
  knights(KnightOfTheRoundTable, <span class="java&#45;quote">"Camelot"</span>) &#123; bean &#45;&#62;
      bean.parent = abstractBean
      quest = quest
  &#125;
&#125;</pre></div><p class="paragraph"/><blockquote class="note">
부모 Bean을 쓸 때 Bean의 다른 프로퍼티를 정하기전에 parent 프로퍼티를 먼저 정해야한다.
</blockquote><p class="paragraph"/>어떤 추상 Bean이 클래스를 가지도록 하려면 다음과 같이 할 수 있다.<p class="paragraph"/><div class="code"><pre>def bb = <span class="java&#45;keyword">new</span> grails.spring.BeanBuilder()
bb.beans &#123;                                          
  abstractBean(KnightOfTheRoundTable) &#123; bean &#45;&#62;
      bean.'<span class="java&#45;keyword">abstract</span>' = <span class="java&#45;keyword">true</span>                  
      leader = <span class="java&#45;quote">"Lancelot"</span>
  &#125;
  quest(HolyGrailQuest)
  knights(<span class="java&#45;quote">"Camelot"</span>) &#123; bean &#45;&#62;
      bean.parent = abstractBean
      quest = quest
  &#125;
&#125;</pre></div><p class="paragraph"/>위의 예제에서 KnightOfTheroundTable이라는 타입의 추상 Bean을 만들고 Bean의 인자를 추상화하는데 사용했다. 그리고 나서 knights Bean을 클래스 없이 정의하고 부모 Bean에서 클래스를 상속한다.<p class="paragraph"/><h4>Adding Variables to the Binding (Context) ((Context) 바인딩에 변수를 더하기)</h4><p class="paragraph"/>스크립트로부터 Bean을 로드하고 있다면 Groovy 바인딩 객체를 생성함으로써 사용할 바인딩을 설정할 수 있다:<p class="paragraph"/><div class="code"><pre>def bb = <span class="java&#45;keyword">new</span> BeanBuilder(<span class="java&#45;quote">"classpath:&#42;SpringBeans.groovy"</span>)
def binding = <span class="java&#45;keyword">new</span> Binding()
binding.foo = <span class="java&#45;quote">"bar"</span><p class="paragraph"/>bb.binding = binding<p class="paragraph"/>def ctx = bb.createApplicationContext()</pre></div><p class="paragraph"/><h4>Loading Bean Definitions from the File System(파일시스템으로부터 Bean 정의를 불러오기)</h4><p class="paragraph"/>외부의 Groovy 스크립트를 불러오기위해 BeanBuilder 클래스를 사용할 수 있다. Groovy 스크립트는 아래와 같이 경로 매칭 문법을 사용하여 Bean을 정의하고 있다:<p class="paragraph"/><div class="code"><pre>def bb = <span class="java&#45;keyword">new</span> BeanBuilder(<span class="java&#45;quote">"classpath:&#42;SpringBeans.groovy"</span>)<p class="paragraph"/>def applicationContext = bb.createApplicationContext()</pre></div><p class="paragraph"/>BeanBuilder는 SpringBeans.groovy로 끝나는 클래스 경로에서 Groovy 파일들을 불러올 것이며 그 파일들을 Bean 정의로 파싱한다. 그 예제가 아래와 같다:<p class="paragraph"/><div class="code"><pre>beans = &#123;
	dataSource(BasicDataSource) &#123;
		driverClassName = <span class="java&#45;quote">"org.hsqldb.jdbcDriver"</span>
		url = <span class="java&#45;quote">"jdbc:hsqldb:mem:grailsDB"</span>
		username = <span class="java&#45;quote">"sa"</span>
		password = <span class="java&#45;quote">""</span>
	&#125;
        sessionFactory(ConfigurableLocalSessionFactoryBean) &#123;
              dataSource = dataSource
              hibernateProperties = &#91; <span class="java&#45;quote">"hibernate.hbm2ddl.auto"</span>:<span class="java&#45;quote">"create&#45;drop"</span>,
                                      <span class="java&#45;quote">"hibernate.show_sql"</span>:<span class="java&#45;keyword">true</span>  &#93;
        &#125;<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/><h2><a name="14.4 Property Placeholder Configuration">14.4 Property Placeholder Configuration</a></h2>Grails는 프로퍼티 위치지정 설정의 개념을 제공한다. 이것은 Spring의 <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/beans/factory/config/PropertyPlaceholderConfigurer.html" class="api">PropertyPlaceholderConfigurer</a>의 확장 버전을 통해 제공한다. 그리고 외부화된 설정(<a href="../guide/single.html#3.4 Externalized Configuration" class="guide">externalized configuration</a>)과 함께 묶여서 사용될때 유용하다.<p class="paragraph"/>자바 프로퍼티 파일의 <a href="http://groovy.codehaus.org/ConfigSlurper" target="blank">ConfigSlurper</a> 스크립트에서 정의된 설정들은 grails-app/conf/spring/resources.xml 에서 Spring 설정을 위한 위치지정 값들로 사용된다. 예를 들어 grails-app/conf/Config.groovy 파일(또는 외부화된 설정)에서 다음 목록들entries을 들 수 있다:<p class="paragraph"/><div class="code"><pre>database.driver=<span class="java&#45;quote">"com.mysql.jdbc.Driver"</span>
database.dbname=<span class="java&#45;quote">"mysql:mydb"</span></pre></div><p class="paragraph"/>그리고 위치지정을 resources.xml파일에서 다음과 같은 ${..} 형식과 비슷하게 지정할 수 있다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;bean id=<span class="xml&#45;quote">"dataSource"</span> class=<span class="xml&#45;quote">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&#62;</span>
   <span class="xml&#45;tag">&#60;property name=<span class="xml&#45;quote">"driverClassName"</span>&#62;</span><span class="xml&#45;tag">&#60;value&#62;</span>$&#123;database.driver&#125;<span class="xml&#45;tag">&#60;/value&#62;</span><span class="xml&#45;tag">&#60;/property&#62;</span>
   <span class="xml&#45;tag">&#60;property name=<span class="xml&#45;quote">"url"</span>&#62;</span><span class="xml&#45;tag">&#60;value&#62;</span>jdbc:$&#123;database.dbname&#125;<span class="xml&#45;tag">&#60;/value&#62;</span><span class="xml&#45;tag">&#60;/property&#62;</span>
 <span class="xml&#45;tag">&#60;/bean&#62;</span></pre></div><h2><a name="14.5 Property Override Configuration">14.5 Property Override Configuration</a></h2>Grails는 프로퍼티 오버라이드 설정의 개념을 제공한다. 이것은 Spring의 <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/beans/factory/config/PropertyOverrideConfigurer.html" class="api">PropertyOverrideConfigurer</a>의 확장 버전을 통해 제공한다. 이것은 외부화된 설정(<a href="../guide/single.html#3.4 Externalized Configuration" class="guide">externalized configuration</a>)과 함께 묶여서 사용될때 일반적으로 유용하다.<p class="paragraph"/>기본적으로 Bean에서 설정을 오버라이드 할 수 있는 Bean 코드를 정의하는 <a href="http://groovy.codehaus.org/ConfigSlurper" target="blank">ConfigSlurper</a> 스크립트를 제공할 수 있다:<p class="paragraph"/><div class="code"><pre>beans &#123;
   bookService.webServiceURL = <span class="java&#45;quote">"http://www.amazon.com"</span>
&#125;</pre></div><p class="paragraph"/>오버라이드는 Spring ApplicationContext가 생성되기 전에 적용된다. 그 형식은 아래와 같다:<p class="paragraph"/><div class="code"><pre>&#91;bean name&#93;.&#91;property name&#93; = &#91;value&#93;</pre></div><p class="paragraph"/>또한 Bean으로 이름이 시작되는 각 Entry를 써서 자바 프로퍼티 파일을 제공할 수 있다:<p class="paragraph"/><div class="code"><pre>beans.bookService.webServiceURL=http://www.amazon.com</pre></div><h1><a name="15. Grails and Hibernate">15. Grails and Hibernate</a></h1>만약 <a href="../guide/single.html#5. Object Relational Mapping (GORM)" class="guide">GORM</a>으로 하고싶은대로 할 수 없다면 Hibernate를 이용하여 도메인 클래스를 매핑할 수도 있다. Hibernate을 용하기 위해서는 grails-app/conf/hibernate 디렉토리에 hibernate.cfg.xml파일을 만들고 도메인 클래스에 대응되는 HBM mapping xml 파일들을 생성한다.<p class="paragraph"/><blockquote class="note">
이 것에 대한 자세한 정보는 Hiberate 웹사이트에서 매핑에 관한 <a href="http://www.hibernate.org/" target="blank">문서</a>를 읽어보라.
</blockquote><p class="paragraph"/>Hibernate는 Grails 도메인 클래스를 더 폭 넓은 레거시Legacy/이미 존재하는 시스템에 매핑할 수 있으며, 데이터베이스 스키마를 훨씬 더 유연하게 생성할 수 있게 해준다<p class="paragraph"/>또한 Grails에서는 도메인 모델을 자바로 작성할 수 있도 있다. Grails에서는 이미 작성된 Hibernate로 매핑된 도메인 클래스를 재사용할 수 있다. 이 것은 grails-app/conf/hibernate 디렉토리에 hibernate.cfg.xml과 관련 매핑 파일들을 위치시키는 것 만으로 가능하다.<p class="paragraph"/>게다가 여러분은 여전히 모든 동적 영속성과 <a href="../guide/single.html#5. Object Relational Mapping (GORM)" class="guide">GORM</a>에서 허용된 쿼리 메소드를 호출할 수 있다.
<h2><a name="15.1 Mapping with Hibernate Annotations">15.1 Mapping with Hibernate Annotations</a></h2>Grails는 Hibernate가 지원하는 자바 5.0 어노테이션을 사용하여 매핑된 도메인 클래스를 만들 수 있도록 지원한다. 그렇게 하기 위해 DataSource에 다음과 같이 configClass를 설정함으로써 어노테이션의 설정을 사용한다는 것을 Grails에 알려줄 필요가 있다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> org.codehaus.groovy.grails.orm.hibernate.cfg.GrailsAnnotationConfiguration
dataSource &#123;
	configClass = GrailsAnnotationConfiguration.class
   &#8230; // remaining properties
&#125;</pre></div><p class="paragraph"/>이제 어노테이션을 위한 설정이 끝났다. 어노테이션을 사용하려면 Java 5.0이 필요하다는 것을 잊지 마라. 이제 쉽게 어노테이션을 사용한 클래스를 만들 수 있다. src/java 디렉토리에 새로운 자바 클래스를 생성하고 EJB 3.0 스펙의 한 부분으로 정의되어 있는 어노테이션을 사용한다(더 자세한 정보를 얻으려면 <a href="http://annotations.hibernate.org/" target="blank">Hibernate 어노테이션 Docs</a>를 찾아보라):<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">package</span> com.books;
@Entity
<span class="java&#45;keyword">public</span> class Book &#123;
    <span class="java&#45;keyword">private</span> <span class="java&#45;object">Long</span> id;
    <span class="java&#45;keyword">private</span> <span class="java&#45;object">String</span> title;
    <span class="java&#45;keyword">private</span> <span class="java&#45;object">String</span> description;
    <span class="java&#45;keyword">private</span> Date date;<p class="paragraph"/>    @Id
    @GeneratedValue
    <span class="java&#45;keyword">public</span> <span class="java&#45;object">Long</span> getId() &#123;
        <span class="java&#45;keyword">return</span> id;
    &#125;<p class="paragraph"/>    <span class="java&#45;keyword">public</span> void setId(<span class="java&#45;object">Long</span> id) &#123;
        <span class="java&#45;keyword">this</span>.id = id;
    &#125;<p class="paragraph"/>    <span class="java&#45;keyword">public</span> <span class="java&#45;object">String</span> getTitle() &#123;
        <span class="java&#45;keyword">return</span> title;
    &#125;<p class="paragraph"/>    <span class="java&#45;keyword">public</span> void setTitle(<span class="java&#45;object">String</span> title) &#123;
        <span class="java&#45;keyword">this</span>.title = title;
    &#125;<p class="paragraph"/>    <span class="java&#45;keyword">public</span> <span class="java&#45;object">String</span> getDescription() &#123;
        <span class="java&#45;keyword">return</span> description;
    &#125;<p class="paragraph"/>    <span class="java&#45;keyword">public</span> void setDescription(<span class="java&#45;object">String</span> description) &#123;
        <span class="java&#45;keyword">this</span>.description = description;
    &#125;
&#125;</pre></div><p class="paragraph"/>이제 하이버네이트 sessionFactory에 클래스를 등록해야 하기 위해서 grails-app/conf/hibernate/hibernate.cfg.xml 파일에 다음과 같이 추가 한다:<p class="paragraph"/><div class="code"><pre>&#60;!DOCTYPE hibernate&#45;configuration SYSTEM
  <span class="xml&#45;quote">"http://hibernate.sourceforge.net/hibernate&#45;configuration&#45;3.0.dtd"</span>&#62;
<span class="xml&#45;tag">&#60;hibernate&#45;configuration&#62;</span>
    <span class="xml&#45;tag">&#60;session&#45;factory&#62;</span>
        <span class="xml&#45;tag">&#60;mapping package=<span class="xml&#45;quote">"com.books"</span> /&#62;</span>
        <span class="xml&#45;tag">&#60;mapping class=<span class="xml&#45;quote">"com.books.Book"</span> /&#62;</span>
    <span class="xml&#45;tag">&#60;/session&#45;factory&#62;</span>
<span class="xml&#45;tag">&#60;/hibernate&#45;configuration&#62;</span></pre></div><p class="paragraph"/>Grails가 이것을 로드할 때 해당 클래스에 관련된 필요한 동적 메소드를 등록한다. Hibernate 도메인 클래스로 할 수 있는 다른 것들을 살펴보려면 스케폴드(<a href="../guide/single.html#16. Scaffolding" class="guide">Scaffolding</a>)장에서 Hibernate절을 살펴보라.<p class="paragraph"/><h2><a name="15.2 Further Reading">15.2 Further Reading</a></h2>Grails의 커미터인 Jason Rudolph는 다음과 같은 Hibernate 매핑을 정의하여 Grails를 함께 사용하는데 관한 많은 유용한 글을 쓰는데 시간을 보냈다.
<ul class="star">
<li><a href="http://jasonrudolph.com/blog/2006/06/20/hoisting-grails-to-your-legacy-db/" target="blank">Grails를 여러분의 레거시 데이터베이스로 끌어당기기</a> - 하이버네이트 XML을 이용하여 Grails를 사용하는데 관한 매우 좋은 글.</li>
<li><a href="http://www.infoq.com/articles/grails-ejb-tutorial" target="blank">Grails + EJB3 도메인 모델</a> - EJB3 형식의 어노테이션을 이용한 도메인 모델을 Grails와 함께 사용하는데 관한 또 다른 대단히 좋은 글.</li>
</ul><p class="paragraph"/><h1><a name="16. Scaffolding">16. Scaffolding</a></h1>스케폴드는 주어진 도메인 클래스에 대해서 어플리케이션을 자동으로 생성해준다. 생성하는 내용은 다음과 같다:
<ul class="star">
<li>필요한 <a href="../guide/single.html#6.2 Groovy Server Pages" class="guide">View</a>들</li>
<li>create/read/update/delete (CRUD)에 필요한 컨트롤러의 액션들</li>
</ul><p class="paragraph"/><h4>스케폴드 기능 활성화</h4><p class="paragraph"/>scaffold 속성을 통해 스케폴드를 하도록 설정하하여 쉽게 스케폴드를 시작할 수 있다. <code>Book</code>도메인 클래스라면, 컨트롤러에서 <code>scaffold</code> 속성을 true로 설정한다.<p class="paragraph"/><div class="code"><pre>class BookController &#123;
   def scaffold = <span class="java&#45;keyword">true</span>
&#125;</pre></div><p class="paragraph"/><code>BookControoler</code>는 <code>Book</code>이라는 도메인 클래스의 동일한 이름짓기 관례를 따르고 있기 때문에 위의 코드는 동작한다. 관례를 따르는 것이 아니라 따로 지정된 도메인 클래스를 스케폴드하려면 다음과 같이 scaffold의 프로퍼티를 도메인 클래스에 직접 연결할 수 있다.<p class="paragraph"/><div class="code"><pre>def scaffold = Author</pre></div><p class="paragraph"/>이렇게 하고 실행을하면 Grails 어플리케이션은 자동으로 실행하는 시점에 필요한 액션과 뷰를 자동으로 생성한다. CRUD 인터페이스 뿐만 아니라 다음과 같은 액션들이 스케폴드 메커니즘을통해 기본적으로 동적으로 구현된다.
<ul class="star">
<li>list</li>
<li>show</li>
<li>edit</li>
<li>delete</li>
<li>create</li>
<li>save</li>
<li>update</li>
</ul><p class="paragraph"/>위 예제의 인터페이스를 사용해 보려면 간단히 <code>http://localhost:8080/app/book</code> 사이트를 열어본다.<p class="paragraph"/>자바로 작성된 도메인 모델을 여전히 <a href="../guide/single.html#15. Grails and Hibernate" class="guide">하이버네이트와 매핑</a>시킨다고해도 여전히 스케폴딩을 할 수 있다. 간단히 필요한 클래스를 불러들여 스케폴드 프로퍼티를 설정해주면 된다.<p class="paragraph"/><h4>동적 스케폴드</h4><p class="paragraph"/>스케폴드 프로퍼티를 사용할때 생각해볼 점은 Grails는 코드템플릿이나 스케폴드만을 위한 코드생성을 하지 않는다. 따라서 사용자가 액션을 컨트롤러에 추가하여 스케폴드된 액션과 함께 사용할 수 있다. 예를 들어 아래의 예제를 보면 <code>changeAuthor</code>는 실제적으로 존재하지 않는 <code>show</code> 액션으로 리다이렉트한다.<p class="paragraph"/><div class="code"><pre>class BookController &#123;
   def scaffold = Book<p class="paragraph"/>   def changeAuthor = &#123;
        def b = Book.get( params&#91;<span class="java&#45;quote">"id"</span>&#93; )
        b.author = Author.get( params&#91;<span class="java&#45;quote">"author.id"</span>&#93; )
        b.save()<p class="paragraph"/>        // redirect to a scaffolded action
        redirect(action:show)
   &#125;
&#125;</pre></div><p class="paragraph"/>필요하다면 스케폴드 액션을 사용자가 정의한 오버라이드할 수 있다:<p class="paragraph"/><div class="code"><pre>class BookController &#123;
   def scaffold = Book<p class="paragraph"/>   // overrides scaffolded action to <span class="java&#45;keyword">return</span> both authors and books
   def list = &#123;
         &#91; <span class="java&#45;quote">"books"</span> : Book.list(), <span class="java&#45;quote">"authors"</span>: Author.list() &#93;
   &#125;
&#125;</pre></div><p class="paragraph"/>이 모든것이 실행시에 동적으로 CRUD 인터페이스가 생성되는 “동적 스케폴딩”이라고 알려진 것이다. Grails는 이 밖에도 다음에 이어지는 절에서 다루는 “static” 스케폴딩을 지원한다.<p class="paragraph"/><h4>생성된 뷰를 사용자 정의하기</h4><p class="paragraph"/>Grails가 생성하는 뷰는 <a href="../guide/single.html#7.1 Declaring Constraints" class="guide">유효성 제약</a>들에 적용하는면에 있어서 어떤 지능적인 형태를 가진다. 예를 들어 간단히 빌드시 제약조건의 순서를 변경함으로써 뷰에서 필드가 나타나는 순서를 간단히 변경할 수 있다:<p class="paragraph"/><div class="code"><pre>def constraints = &#123;
      title()
      releaseDate()
&#125;</pre></div><p class="paragraph"/>또한 <code>inList</code> 제약조건을 사용한다면 텍스트 입력 대신에 리스트를 생성하는 생성자를 얻을 수 있다.<p class="paragraph"/><div class="code"><pre>def constraints = &#123;
      title()
      category(inList:&#91;<span class="java&#45;quote">"Fiction"</span>, <span class="java&#45;quote">"Non&#45;fiction"</span>, <span class="java&#45;quote">"Biography"</span>&#93;)
      releaseDate()
&#125;</pre></div><p class="paragraph"/>숫자의 경우는 <code>range</code> 제약조건을 사용할 수 있다:<p class="paragraph"/><div class="code"><pre>def constraints = &#123;
        age(range:18..65)
&#125;</pre></div><p class="paragraph"/>제약조건을 통해 길이에 제한을 거는 것은 생성된 뷰에서 입력할 수 있는 문자열의 길이도 제한한다:<p class="paragraph"/><div class="code"><pre>def constraints = &#123;
        name(size:0..30)
&#125;</pre></div><p class="paragraph"/><h4>컨트롤러와 뷰를 생성하기</h4><p class="paragraph"/>위에서 살펴본 스케폴드 기능은 매우 유용하지만 실제 상황에서는 로직이나 뷰를 사용가 정의해야 할 것이다. Grails는 명령줄을 통해서 위의 컨트롤러와 뷰에서 사용되는 인터페이스를 생성하는데 쓸 수 있다. 다음과 같이 컨트롤러 타입을 생성할 수 있다:<p class="paragraph"/><div class="code"><pre>grails generate&#45;controller Book</pre></div><p class="paragraph"/>뷰 타입도 생성할 수 있다:<p class="paragraph"/><div class="code"><pre>grails generate&#45;views Book</pre></div><p class="paragraph"/>이 모든것을 한꺼번에 생성할 수도 있다:<p class="paragraph"/><div class="code"><pre>grails generate&#45;all Book</pre></div><p class="paragraph"/>패키지를 사용하여 도메인 클래스를 생성하거나 <a href="../guide/single.html#15. Grails and Hibernate" class="guide">하이버네이트로 매핑된 클래스</a>로부터 생성을 한다면 패키지네임을 완전하게 입력하는것을 기억해야 한다.<p class="paragraph"/><div class="code"><pre>grails generate&#45;all com.bookstore.Book</pre></div><p class="paragraph"/>
         			
		</div>
		<div id="footer">
			  Sponsored by <a href="http://g2one.com">G2One Inc</a>
		</div>	
	</body>
</html>