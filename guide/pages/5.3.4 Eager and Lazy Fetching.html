<html>
     <head>
     	<meta http-equiv="Content-type" content="text/html; charset=utf-8">
     	<title>5.3.4 Eager and Lazy Fetching</title>
     	<link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8">
     </head>
	<body class="body">
		GORM은 기본적으로 Lazy 패칭을 사용한다. 다음 예가 이를 잘 설명한다.<p class="paragraph"/><div class="code"><pre>class Airport &#123;
	<span class="java&#45;object">String</span> name
	<span class="java&#45;keyword">static</span> hasMany = &#91;flights:Flight&#93;
&#125;
class Flight &#123;
	<span class="java&#45;object">String</span> number
	<span class="java&#45;keyword">static</span> belongsTo = &#91;airport:Airport&#93;
&#125;</pre></div><p class="paragraph"/>위의 도메인 클래스로 다음과 같이 코드를 작성한다.<p class="paragraph"/><div class="code"><pre>def airport = Airport.findByName(<span class="java&#45;quote">"Gatwick"</span>)
airport.flights.each &#123;
	println it.name
&#125;</pre></div><p class="paragraph"/>GORM은 <code>Airport</code> 인스턴스를 가져오기 위해 단 하나의 SQL을 실행하고 <code>Flight</code>마다 추가로 1개의 쿼리를 더 실행할 것이다. 결국에 N+1번 질의한다.<p class="paragraph"/>관계(association)에 드물게 접근하는 경우에는 이 방법이 최적일 것이다. 전적으로 관계(association)의 사용빈도에 달려있다.<p class="paragraph"/>다음과 같이 Eager 패칭을 사용하는 것으로 Lazy 패칭의 단점을 해결할 수 있다.<p class="paragraph"/><div class="code"><pre>class Airport &#123;
	<span class="java&#45;object">String</span> name
	<span class="java&#45;keyword">static</span> hasMany = &#91;flights:Flight&#93;
	<span class="java&#45;keyword">static</span> fetchMode = &#91;flights:<span class="java&#45;quote">"eager"</span>&#93;
&#125;</pre></div><p class="paragraph"/><code>Airport</code> 인스턴스와 <code>Flight</code> 관계는 매핑 규칙에 따라 한번에 전부 로드될 것이다. 데이터베이스에 질의하는 빈도가 줄어드는 장점이 있지만 Eager Association이 너무 많으면 데이터베이스 전체를 메모리로 로드하게 될 수도 있으니 주의해야 한다.<p class="paragraph"/><blockquote class="note">
<a href="../guide/single.html#5.5.2 Custom ORM Mapping" class="guide">ORM DSL</a>을 이용하여 Lazy 패치없이 관계를 정의할 수 있다.
</blockquote><p class="paragraph"/>

	</body>
</html>