<html>
     <head>
     	<meta http-equiv="Content-type" content="text/html; charset=utf-8">
     	<title>9.1 Unit Testing</title>
     	<link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8">
     </head>
	<body class="body">
		유닛 테스팅은 "유닛" 수준에서 수행하는 테스트를 말한다. 즉, 기반 구조에 대한 고려없이 각각의 메소드나 코드 블럭을 테스트하는 것이다. Grails의 유닛 테스트와 통합 테스트의 차이점을 알아야 한다. Grails는 런타임이나 통합 테스트를 할 때처럼 유닛 테스트에 어떠한 동적 메소드도 주입하지 않는다.<p class="paragraph"/>This makes sense if you consider that the methods injected by Grails typically community with the database (with GORM) or the underlying Servlet engine (with Controllers).<p class="paragraph"/>Grails가 데이터베이스(GORM)와 통신하기 위해 주입하는 메소드나 서블릿 엔진에 의해 컨트롤러에 주입되는 메소드와 함께 이해할 수 있다. 예를 들어 <code>BookController</code>에 다음과 같은 액션이 있다고 하면:<p class="paragraph"/><div class="code"><pre>class MyService &#123;
    def otherService<p class="paragraph"/>	<span class="java&#45;object">String</span> createSomething() &#123; 
		def stringId = otherService.newIdentifier()
		def item = <span class="java&#45;keyword">new</span> Item(code: stringId, name: <span class="java&#45;quote">"Bangle"</span>) 
		item.save() 
		<span class="java&#45;keyword">return</span> stringId 
	&#125;<p class="paragraph"/>	<span class="java&#45;object">int</span> countItems(<span class="java&#45;object">String</span> name) &#123; 
		def items = Item.findAllByName(name) 
		<span class="java&#45;keyword">return</span> items.size() 
	&#125; 
&#125;</pre></div><p class="paragraph"/>
As you can see the service takes advantage of GORM methods. So how do you go about testing the above code in a unit test? The answer can be found in Grails' testing support classes.<p class="paragraph"/><h3>The Testing Framework</h3><p class="paragraph"/>The core of the testing plugin is the <code>grails.test.GrailsUnitTestCase</code> class. This is a sub-class of <code>GroovyTestCase</code> geared towards Grails applications and their artifacts. It provides several methods for mocking particular types as well as support for general mocking a la Groovy's MockFor and StubFor classes.<p class="paragraph"/>Normally you might look at the <code>MyService</code> example shown previously and the dependency on another service and the use of dynamic domain class methods with a bit of a groan. You can use meta-class programming and the "map as object" idiom, but these can quickly get ugly. How might we write the test with GrailsUnitTestCase ?<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> grails.test.GrailsUnitTestCase<p class="paragraph"/>class MyServiceTests <span class="java&#45;keyword">extends</span> GrailsUnitTestCase &#123; 
	void testCreateSomething() &#123; 
		// Mock the domain class. 
		def testInstances = &#91;&#93; 
		mockDomain(Item, testInstances)<p class="paragraph"/>		// Mock the <span class="java&#45;quote">"other"</span> service. 
		<span class="java&#45;object">String</span> testId = <span class="java&#45;quote">"NH&#45;12347686"</span> 
		def otherControl = mockFor(OtherService) 
		otherControl.demand.newIdentifier(1..1) &#123;&#45;&#62; <span class="java&#45;keyword">return</span> testId &#125;<p class="paragraph"/>		// 	Initialise the service and test the target method. 
		def testService = <span class="java&#45;keyword">new</span> MyService() 
		testService.otherService = otherControl.createMock()<p class="paragraph"/>		def retval = testService.createSomething()<p class="paragraph"/>		// Check that the method returns the identifier returned by the 
		// mock <span class="java&#45;quote">"other"</span> service and also that a <span class="java&#45;keyword">new</span> Item instance has 
		// been saved. 
		assertEquals testId, retval 
		assertEquals 1, testInstances 
		assertTrue testInstances&#91;0&#93; <span class="java&#45;keyword">instanceof</span> Item 
	&#125;<p class="paragraph"/>	void testCountItems() &#123; 
		// Mock the domain class, <span class="java&#45;keyword">this</span> time providing a list of test 
		// Item instances that can be searched. 
		def testInstances = &#91; <span class="java&#45;keyword">new</span> Item(code: <span class="java&#45;quote">"NH&#45;4273997"</span>, name: <span class="java&#45;quote">"Laptop"</span>), 
							  <span class="java&#45;keyword">new</span> Item(code: <span class="java&#45;quote">"EC&#45;4395734"</span>, name: <span class="java&#45;quote">"Lamp"</span>), 
							  <span class="java&#45;keyword">new</span> Item(code: <span class="java&#45;quote">"TF&#45;4927324"</span>, name: <span class="java&#45;quote">"Laptop"</span>) &#93; 
		mockDomain(Item, testInstances)<p class="paragraph"/>		// Initialise the service and test the target method. def testService = <span class="java&#45;keyword">new</span> MyService()<p class="paragraph"/>		assertEquals 2, testService.countItems(<span class="java&#45;quote">"Laptop"</span>) 
		assertEquals 1, testService.countItems(<span class="java&#45;quote">"Lamp"</span>) 
		assertEquals 0, testService.countItems(<span class="java&#45;quote">"Chair"</span>) 
	&#125; 
&#125;</pre></div><p class="paragraph"/>OK, so a fair bit of new stuff there, but once we break it down you should quickly see how easy it is to use the methods available to you. Take a look at the "testCreateSomething()" test method. The first thing you will probably notice is the <code>mockDomain()</code> method, which is one of several provided by <code>GrailsUnitTestCase</code>:<p class="paragraph"/><div class="code"><pre>def testInstances = &#91;&#93; 
mockDomain(Item, testInstances)</pre></div><p class="paragraph"/>It adds all the common domain methods (both instance and static) to the given class so that any code using it sees it as a full-blown domain class. So for example, once the <code>Item</code> class has been mocked, we can safely call the <code>save()</code> method on instances of it. Speaking of which, what happens when we call that method on a mocked domain class? Simple: the new instance is added to the <code>testInstances</code> list we passed into the <code>mockDomain()</code> method.<p class="paragraph"/>The next bit we want to look at is centered on the <code>mockFor</code> method:<p class="paragraph"/><div class="code"><pre>def otherControl = mockFor(OtherService) 
otherControl.demand.newIdentifier(1..1) &#123;&#45;&#62; <span class="java&#45;keyword">return</span> testId &#125;</pre></div><p class="paragraph"/>This is analagous to the <code>MockFor</code> and <code>StubFor</code> classes that come with Groovy and it can be used to mock any class you want. In fact, the "demand" syntax is identical to that used by Mock/StubFor, so you should feel right at home. Of course you often need to inject a mock instance as a dependency, but that is pretty straight forward with the <code>createMock()</code> method, which you simply call on the mock control as shown. For those familiar with EasyMock, the name <code>otherControl</code> highlights the role of the object returned by <code>mockFor()</code> - it is a control object rather than the mock itself.<p class="paragraph"/>The rest of the <code>testCreateSomething()</code> method should be pretty familiar, particularly as you now know that the mock <code>save()</code> method adds instances to <code>testInstances</code> list. However, there is an important technique missing from the test method. We can determine that the mock <code>newIdentifier()</code> method is called because its return value has a direct impact on the result of the <code>createSomething()</code> method. But what if that weren't the case? How would we know whether it had been called or not? With Mock/StubFor the check would be performed at the end of the <code>use()</code> closure, but that's not available here. Instead, you can call <code>verify()</code> on the control object - in this case <code>otherControl</code>. This will perform the check and throw an assertion error if it hasn't been called when it should have been.<p class="paragraph"/>Lastly, <code>testCountItems()</code> in the example demonstrates another facet of the <code>mockDomain()</code> method:<p class="paragraph"/><div class="code"><pre>def testInstances = &#91; <span class="java&#45;keyword">new</span> Item(code: <span class="java&#45;quote">"NH&#45;4273997"</span>, name: <span class="java&#45;quote">"Laptop"</span>), 
					  <span class="java&#45;keyword">new</span> Item(code: <span class="java&#45;quote">"EC&#45;4395734"</span>, name: <span class="java&#45;quote">"Lamp"</span>), 
					  <span class="java&#45;keyword">new</span> Item(code: <span class="java&#45;quote">"TF&#45;4927324"</span>, name: <span class="java&#45;quote">"Laptop"</span>) &#93; 
mockDomain(Item, testInstances)</pre></div><p class="paragraph"/>It is normally quite fiddly to mock the dynamic finders manually, and you often have to set up different data sets for each invocation. On top of that, if you decide a different finder should be used then you have to update the tests to check for the new method! Thankfully the <code>mockDomain()</code> method provides a lightweight implementation of the dynamic finders backed by a list of domain instances. Simply provide the test data as the second argument of the method and the mock finders will just work.<p class="paragraph"/><h3>GrailsUnitTestCase - the mock methods</h3><p class="paragraph"/>You have already seen a couple of examples in the introduction of the <code>mock..()</code> methods provided by the <code>GrailsUnitTestCase</code> class. Here we will look at all the available methods in some detail, starting with the all-purpose <code>mockFor()</code>. But before we do, there is a very important point to make: using these methods ensures that any changes you make to the given classes do not leak into other tests! This is a common and serious problem when you try to perform the mocking yourself via meta-class programming, but that headache just disappears as long as you use at least one of <code>mock..()</code> methods on each class you want to mock.<p class="paragraph"/><div class="code"><pre>mockFor(class, loose = <span class="java&#45;keyword">false</span>)</pre></div><p class="paragraph"/>General purpose mocking that allows you to set up either strict or loose demands on a class.<p class="paragraph"/>This method is surprisingly intuitive to use. By default it will create a strict mock control object (one for which the order in which methods are called is important) that you can use to specify demands:<p class="paragraph"/><div class="code"><pre>def strictControl = mockFor(MyService)
strictControl.demand.someMethod(0..2) &#123; <span class="java&#45;object">String</span> arg1, <span class="java&#45;object">int</span> arg2 &#45;&#62; ‚Ä¶ &#125;
strictControl.demand.<span class="java&#45;keyword">static</span>.aStaticMethod &#123;&#45;&#62; ‚Ä¶ &#125;</pre></div><p class="paragraph"/>Notice that you can mock static methods as well as instance ones simply by using the "static" property after "demand". You then specify the name of the method that you want to mock with an optional range as its argument. This range determines how many times you expect the method to be called, so if the number of invocations falls outside of that range (either too few or too many) then an assertion error will be thrown. If no range is specified, a default of "1..1" is assumed, i.e. that the method must be called exactly once.<p class="paragraph"/>The last part of a demand is a closure representing the implementation of the mock method. The closure arguments should match the number and types of the mocked method, but otherwise you are free to add whatever you want in the body.<p class="paragraph"/>As we mentioned before, if you want an actual mock instance of the class that you are mocking, then you need to call <code>mockControl.createMock()</code>. In fact, you can call this as many times as you like to create as many mock instances as you need. And once you have executed the test method, you can call <code>mockControl.verify()</code> to check whether the expected methods were actually called or not.<p class="paragraph"/>Lastly, the call:<p class="paragraph"/><div class="code"><pre>def looseControl = mockFor(MyService, <span class="java&#45;keyword">true</span>)</pre></div><p class="paragraph"/>will create a mock control object that has only loose expectations, i.e. the order that methods are invoked does not matter.<p class="paragraph"/><h4>mockDomain(class, testInstances = )</h4><p class="paragraph"/>Takes a class and makes mock implementations of all the domain class methods (both instance- and static-level) accessible on it.<p class="paragraph"/>Mocking domain classes is one of the big wins from using the testing plugin. Manually doing it is fiddly at best, so it's great that mockDomain() takes that burden off your shoulders.<p class="paragraph"/>In effect, <code>mockDomain()</code> provides a lightweight version of domain classes in which the "database" is simply a list of domain instances held in memory. All the mocked methods ( <code>save()</code> , <code>get()</code> , <code>findBy*()</code> , etc.) work against that list, generally behaving as you would expect them to. In addition to that, both the mocked <code>save()</code> and validate() methods will perform real validation (support for the unique constraint included!) and populate an errors object on the corresponding domain instance.<p class="paragraph"/>There isn't much else to say other than that the plugin does not support the mocking of criteria or HQL queries. If you use either of those, simply mock the corresponding methods manually (for example with <code>mockFor()</code> ) or use an integration test with real data.<p class="paragraph"/><h4>mockForConstraintsTests(class, testInstances = )</h4><p class="paragraph"/>Highly specialised mocking for domain classes and command objects that allows you to check whether the constraints are behaving as you expect them to.<p class="paragraph"/>Do you test your domain constraints? If not, why not? If your answer is that they don't need testing, think again. Your constraints contain logic and that logic is highly susceptible to bugs - the kind of bugs that can be tricky to track down (particularly as save() doesn't throw an exception when it fails). If your answer is that it's too hard or fiddly, that is no longer an excuse. Enter the <code>mockForConstraintsTests()</code> method.<p class="paragraph"/>This is like a much reduced version of the <code>mockDomain()</code> method that simply adds a <code>validate()</code> method to a given domain class. All you have to do is mock the class, create an instance with field values, and then call <code>validate()</code>. You can then access the errors property on your domain instance to find out whether the validation failed or not. So if all we are doing is mocking the <code>validate()</code> method, why the optional list of test instances? That is so that we can test unique constraints as you will soon see.<p class="paragraph"/>So, suppose we have a simple domain class like so:<p class="paragraph"/><div class="code"><pre>class Book &#123;
    <span class="java&#45;object">String</span> title
    <span class="java&#45;object">String</span> author<p class="paragraph"/>	<span class="java&#45;keyword">static</span> constraints = &#123; 
		title(blank: <span class="java&#45;keyword">false</span>, unique: <span class="java&#45;keyword">true</span>) 
		author(blank: <span class="java&#45;keyword">false</span>, minSize: 5) 
	&#125; 
&#125;</pre></div><p class="paragraph"/>Don't worry about whether the constraints are sensible or not (they're not!), they are for demonstration only. To test these constraints we can do the following:<p class="paragraph"/><div class="code"><pre>class BookTests <span class="java&#45;keyword">extends</span> GrailsUnitTestCase &#123;
    void testConstraints() &#123;
        def existingBook = <span class="java&#45;keyword">new</span> Book(title: <span class="java&#45;quote">"Misery"</span>, author: <span class="java&#45;quote">"Stephen King"</span>)
        mockForConstraintsTests(Book, &#91; existingBook &#93;)<p class="paragraph"/>		// Validation should fail <span class="java&#45;keyword">if</span> both properties are <span class="java&#45;keyword">null</span>. 
		def book = <span class="java&#45;keyword">new</span> Book() 
		assertFalse book.validate() 
		assertEquals <span class="java&#45;quote">"nullable"</span>, book.errors&#91;<span class="java&#45;quote">"title"</span>&#93; 
		assertEquals <span class="java&#45;quote">"nullable"</span>, book.errors&#91;<span class="java&#45;quote">"author"</span>&#93;<p class="paragraph"/>		// So let's demonstrate the unique and minSize constraints. 
		book = <span class="java&#45;keyword">new</span> Book(title: <span class="java&#45;quote">"Misery"</span>, author: <span class="java&#45;quote">"JK"</span>) 
		assertFalse book.validate() 
		assertEquals <span class="java&#45;quote">"unique"</span>, 	book.errors&#91;<span class="java&#45;quote">"title"</span>&#93; 
		assertEquals <span class="java&#45;quote">"minSize"</span>, book.errors&#91;<span class="java&#45;quote">"author"</span>&#93;<p class="paragraph"/>		// Validation should pass! 
		book = <span class="java&#45;keyword">new</span> Book(title: <span class="java&#45;quote">"The Shining"</span>, author: <span class="java&#45;quote">"Stephen King"</span>) 
		assertTrue book.validate() 
	&#125; 
&#125;</pre></div><p class="paragraph"/>You can probably look at that code and work out what's happening without any further explanation. The one thing we will explain is the way the errors property is used. First, it does return a real Spring <code>Errors</code> instance, so you can access all the properties and methods you would normally expect. Second, this particular <code>Errors</code> object also has map/property access as shown. Simply specify the name of the field you are interested in and the map/property access will return the name of the constraint that was violated. Note that it is the constraint name , not the message code (as you might expect).<p class="paragraph"/>That's it for testing constraints. One final thing we would like to say is that testing the constraints in this way catches a common error: typos in the "constraints" property! It is currently one of the hardest bugs to track down normally, and yet a unit test for your constraints will highlight the problem straight away.<p class="paragraph"/><h4>mockLogging(class, enableDebug = false)</h4><p class="paragraph"/>Adds a mock "log" property to a class. Any messages passed to the mock logger are echoed to the console.<p class="paragraph"/><h4>mockController(class)</h4><p class="paragraph"/>Adds mock versions of the dynamic controller properties and methods to the given class. This is typically used in conjunction with the <code>ControllerUnitTestCase</code> class.<p class="paragraph"/><h4>mockTagLib(class)</h4><p class="paragraph"/>Adds mock versions of the dynamic taglib properties and methods to the given class. This is typically used in conjunction with the <code>TagLibUnitTestCase</code> class.

	</body>
</html>