<html>
     <head>
     	<meta http-equiv="Content-type" content="text/html; charset=utf-8">
     	<title>5.2.4 Sets, Lists and Maps</title>
     	<link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8">
     </head>
	<body class="body">
		<h4>Sets of objects(집합)</h4><p class="paragraph"/>관계를 만들면 GORM은 기본적으로 <code>java.util.Set</code>을 이용한다. 이 것은 정렬되지 않으며 중복을 허용하지 않는 컬렉션이다. 다음의 Author 클래스가 있다면<p class="paragraph"/><div class="code"><pre>class Author &#123;
   <span class="java&#45;keyword">static</span> hasMany = &#91;books:Book&#93;
&#125;</pre></div><p class="paragraph"/>GORM은 이 books 프로퍼티를 <code>java.util.Set</code>형식으로 만든다. 컬렉션을 사용할 때 정렬되지 않았다는 것이 문제가 될 수 있다. 정렬된 컬렉션을 사용하길 원한다면 다음처럼 books를 <code>SortedSet</code>으로 명시한다.<p class="paragraph"/><div class="code"><pre>class Author &#123;
   SortedSet books
   <span class="java&#45;keyword">static</span> hasMany = &#91;books:Book&#93;
&#125;</pre></div><p class="paragraph"/><code>java.util.SortedSet</code>을 사용하는 경우에는 Book 클래스에 <code>java.lang.Comparable</code>을 구현해야 한다.<p class="paragraph"/><div class="code"><pre>class Book <span class="java&#45;keyword">implements</span> Comparable &#123;
   <span class="java&#45;object">String</span> title
   Date releaseDate = <span class="java&#45;keyword">new</span> Date()<p class="paragraph"/>   <span class="java&#45;object">int</span> compareTo(obj) &#123;
       releaseDate.compareTo(obj.releaseDate)
   &#125;
&#125;</pre></div><p class="paragraph"/>이 예제대로 라면 Author 클래스의 books 프로퍼티에 Book 객체들이 있게된다. Book 객체들은 releaseDate를 기준으로 정렬될 것이다.<p class="paragraph"/><h4>Lists of objects(리스트)</h4><p class="paragraph"/>단순하게 집합을 객체가 추가된 순서로 유지하고 배열처럼 인덱스로 객체를 참조하게 하고 싶을 땐 <code>List</code>를 사용하면 된다:<p class="paragraph"/><div class="code"><pre>class Author &#123;
   List books
   <span class="java&#45;keyword">static</span> hasMany = &#91;books:Book&#93;
&#125;</pre></div><p class="paragraph"/>books 컬렉션의 순서는 객체를 추가한 순서대로 유지된다. 0부터 시작하는 인덱스를 이용하여 다음과 같이 사용할 수 있다:<p class="paragraph"/><div class="code"><pre>author.books&#91;0&#93; // 첫 번째 책</pre></div><p class="paragraph"/>데이터베이스 수준에서 일어나는 일을 살펴보면 Hibernate는 books_idx 컬럼을 생성한다. 데이터베이스에서도 순서를 지키기위해서 <code>book_idx</code>에 컬렉션 요소(element)의 인덱스를 저장한다.<p class="paragraph"/><code>List</code>를 사용할 때 요소를 저장하기 전에 컬렉션에 추가해야 한다. 그렇지 않으면 Hibernate는 예외를 던질 것이다(<code>org.hibernate.HibernateException: null index column for collection</code>):<p class="paragraph"/><div class="code"><pre>// This won't work!
def book = <span class="java&#45;keyword">new</span> Book(title: 'The Shining')
book.save()
author.addToBooks(book)<p class="paragraph"/>// Do it <span class="java&#45;keyword">this</span> way instead.
def book = <span class="java&#45;keyword">new</span> Book(title: 'Misery')
author.addToBooks(book)
author.save()</pre></div><p class="paragraph"/><h4>Maps of Objects(맵)</h4><p class="paragraph"/>만약 string/value 쌍만으로 이루어진 단순한 맵을 원하면 다음처럼 사용하면 된다:<p class="paragraph"/><div class="code"><pre>class Author &#123;
   Map books // map of ISBN:book names
&#125;<p class="paragraph"/>def a = <span class="java&#45;keyword">new</span> Author()
a.books = &#91;<span class="java&#45;quote">"1590597583"</span>:<span class="java&#45;quote">"Grails Book"</span>&#93;
a.save()</pre></div><p class="paragraph"/>맵의 키와 값은 모두 <strong class="bold">반드시</strong> 문자열이어야 한다.<p class="paragraph"/>객체의 맵을 원한다면 다음처럼 한다.<p class="paragraph"/><div class="code"><pre>class Book &#123;
  Map authors
  <span class="java&#45;keyword">static</span> hasMany = &#91;authors:Author&#93;
&#125;<p class="paragraph"/>def a = <span class="java&#45;keyword">new</span> Author(name:<span class="java&#45;quote">"Stephen King"</span>)<p class="paragraph"/>def book = <span class="java&#45;keyword">new</span> Book()
book.authors = &#91;stephen:a&#93;
book.save()</pre></div><p class="paragraph"/>static <code>hasMany</code> 프로퍼티로 맵의 요소의 형식을 정의할 수 있다. 이 맵의 키는 <strong class="bold">반드시</strong> 문자열이어야 한다.

	</body>
</html>