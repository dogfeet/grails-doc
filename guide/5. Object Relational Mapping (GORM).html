<html>
     <head>
     	<meta http-equiv="Content-type" content="text/html; charset=utf-8">
     	<title>5. Object Relational Mapping (GORM)</title>
     	<link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8">
     </head>
	<body class="body">
		<h1><a name="5. Object Relational Mapping (GORM)">5. Object Relational Mapping (GORM)</a></h1>도메인 클래스는 모든 비지니스 어플리케이션에서 핵심이다. 도메인 클래스에는 비지니스 프로세스의 상태를 유지시키고 행동을 구현한다. 도메인 클래스는 서로 일대일 혹은 일대다 관계를 이룬다.<p class="paragraph"/>GORM은 Grails에서 사용하는 객체 관계형 매핑 구현체이다. 내부적으로 Hibernate 3(아주 인기있고 유연한 오픈소스 ORM)를 이용하지만 Groovy의 동적인 성질과 관례 때문에 Grails의 도메인 클래스를 생성하는 것까지 포함하더라도 설정할게 별로 없다. 실제로 Grails는 정적 타이핑과 동적 타이핑을 모두 지원한다.<p class="paragraph"/>Grails 도메인 클래스는 자바로도 작성할 수 있다. Hibernate와 통합하는 장을 보면 자바로 Grails의 도메인 클래스를 작성하는 법을 확인할 수 있다. 그러나 여전히 동적인 영속성 메소드를 사용한다. 다음은 GORM을 활용하는 예이다:<p class="paragraph"/><div class="code"><pre>def book = Book.findByTitle(<span class="java&#45;quote">"Groovy in Action"</span>)<p class="paragraph"/>book
  .addToAuthors(name:<span class="java&#45;quote">"Dierk Koenig"</span>)
  .addToAuthors(name:<span class="java&#45;quote">"Guillaume LaForge"</span>)
  .save()</pre></div><p class="paragraph"/><h2><a name="5.1 Quick Start Guide">5.1 Quick Start Guide</a></h2><a href="../ref/Command Line/create-domain-class.html" class="commandLine">create-domain-class</a> 명령으로 도메인 클래스를 만든다:<p class="paragraph"/><div class="code"><pre>grails create&#45;domain&#45;class Person</pre></div><p class="paragraph"/>도메인 클래스는 <code>grails-app/domain/Person.groovy</code> 에 생성되며 그 내용은 다음과 같다:<p class="paragraph"/><div class="code"><pre>class Person &#123;	
&#125;</pre></div><p class="paragraph"/><blockquote class="note">
<a href="../guide/single.html#3.3 The DataSource" class="guide">DataSource</a>에 dbCreate 프로퍼티가 “update”, “create”, “create-drop”중에 하나로 설정하면 Grails는 자동으로 데이터베이스 테이블을 생성하거나 수정한다.
</blockquote><p class="paragraph"/>다음과 같이 클래스에 몇 개의 프로퍼티를 추가한다:<p class="paragraph"/><div class="code"><pre>class Person &#123;	
	<span class="java&#45;object">String</span> name
	<span class="java&#45;object">Integer</span> age
	Date lastVisit
&#125;</pre></div><p class="paragraph"/>도메인 클래스를 만들고 <a href="../ref/Command Line/shell.html" class="commandLine">shell</a>이나 <a href="../ref/Command Line/console.html" class="commandLine">console</a>에서 관리할 수 있다:<p class="paragraph"/><div class="code"><pre>grails console</pre></div><p class="paragraph"/>이제 Groovy 명령을 입력할 수 있는 GUI 프로그램이 실행된다.<h2><a name="5.1.1 Basic CRUD">5.1.1 Basic CRUD</a></h2>기본적인 CRUD(Create/Read/Update/Delete) 명령을 사용해 보자.<p class="paragraph"/><h4>Create</h4><p class="paragraph"/>Groovy의 new 연산자를 사용하여 도메인 클래스를 생성하고 프로퍼티 값을 입력하고 <a href="../ref/Domain Classes/save.html" class="domainClasses">save</a> 메소드를를 호출한다:<p class="paragraph"/><div class="code"><pre>def p = <span class="java&#45;keyword">new</span> Person(name:<span class="java&#45;quote">"Fred"</span>, age:40, lastVisit:<span class="java&#45;keyword">new</span> Date())
p.save()</pre></div><p class="paragraph"/><a href="../ref/Domain Classes/save.html" class="domainClasses">save</a> 메소드는 Hibernate을 이용하여 도메인 클래스를 영속화한다.<p class="paragraph"/><h4>Read</h4><p class="paragraph"/>Grails는 내부적으로 도메인 클래스에 <code>id</code> 프로퍼티를 추가한다.<p class="paragraph"/><div class="code"><pre>def p = Person.get(1)
assert 1 == p.id</pre></div><p class="paragraph"/>이 예에서는 <a href="../ref/Domain Classes/get.html" class="domainClasses">get</a> 메소드를 이용하여 데이터베이스에서 Person 객체를 읽는다.<p class="paragraph"/><h4>Update</h4><p class="paragraph"/>특정 인스턴스의 정보를 업데이트하기 위해서 필요한 프로퍼티들을 변경하고 단순하게 다시 <a href="../ref/Domain Classes/save.html" class="domainClasses">save</a> 메소드를 호출하면 된다:<p class="paragraph"/><div class="code"><pre>def p = Person.get(1)
p.name = <span class="java&#45;quote">"Bob"</span>
p.save()</pre></div><p class="paragraph"/><h4>Delete</h4><p class="paragraph"/><a href="../ref/Domain Classes/delete.html" class="domainClasses">delete</a> 메소드로 인스턴스를 삭제한다:<p class="paragraph"/><div class="code"><pre>def p = Person.get(1)
p.delete()</pre></div><p class="paragraph"/><h2><a name="5.2 Domain Modelling in GORM">5.2 Domain Modelling in GORM</a></h2>
Grails 어플리케이션을 만들려면 해결할 문제의 도메인을 알아야 한다. <a href="http://www.amazon.com/" target="blank">Amazon</a> 서점을 만들고 싶다면 책, 저자, 고객, 출판사들을 고려하게 될 것이다.<p class="paragraph"/>여기에서는 제목, 출판일, ISBN등의 정보를 가지는 Book 클래스를 GORM으로 모델링 할 것이다. 계속해서 GORM으로 도메인을 모델링하는 법을 보여줄 것이다.<p class="paragraph"/><a href="../ref/Command Line/create-domain-class.html" class="commandLine">create-domain-class</a> 명령으로 도메인 클래스를 생성할 수 있다:<p class="paragraph"/><div class="code"><pre>grails create&#45;domain&#45;class Book</pre></div><p class="paragraph"/>이 명령을 실행하면 <code>grails-app/domain/Book.groovy</code> 파일이 다음과 같은 내용으로 생성된다:<p class="paragraph"/><div class="code"><pre>class Book &#123;	
&#125;</pre></div><p class="paragraph"/><blockquote class="note">
패키지를 사용하려면 도메인 클래스의 위치를 도메인 디렉토리 밑의 하위 디렉토리로 옮기고 Groovy 패키지 규칙(Java와 동일하다)에 따라 패키지를 정의하면 된다.
</blockquote><p class="paragraph"/>위 클래스는 자동적으로 클래스 이름과 동일한 데이터베이스의 book 테이블과 매핑된다. 이 규칙은 <a href="../guide/single.html#5.5.2 Custom ORM Mapping" class="guide">ORM Domain Specific Language</a> 도메인 명세 언어(ORM Domain Specific Language)로 수정할 수 있다.<p class="paragraph"/>이제 도메인 클래스를 만들었고 Java 데이터 형식을 이용하여 프로퍼티를 정의해보자. 다음의 예를 보면:<p class="paragraph"/><div class="code"><pre>class Book &#123;
	<span class="java&#45;object">String</span> title
	Date releaseDate
	<span class="java&#45;object">String</span> ISBN
&#125;</pre></div><p class="paragraph"/>각 프로퍼티는 데이터베이스의 컬럼으로 매핑되고 그 컬럼 이름은 '_'로 구분되는 소문자로 만들어진다. 예를 들어 releaseDate는 release_date의 컬럼이름으로 매핑된다. SQL 데이터 형식은 Java 데이터 형식에 따라 자동으로 매핑된다. 그리고 <a href="../guide/single.html#5.5.2 Custom ORM Mapping" class="guide">ORM DSL</a> 이나 제약조건(<a href="../guide/single.html#7.1 Declaring Constraints" class="guide">Constraints</a>)을 이용하여 매핑 규칙을 수정할 수 있다.
<h2><a name="5.2.1 Association in GORM">5.2.1 Association in GORM</a></h2>관계(Relationships)는 도메인 클래스들이 상호 동작하는 방식을 의미한다. 양쪽 클래스에 정확하게 정의하지 않으면 관계는 정의된 쪽에서만 적용된다.<h2><a name="5.2.1.1 One-to-one">5.2.1.1 One-to-one</a></h2>일대일 관계은 가장 단순형태다. 이 관계는 다른 도메인 클래스의 형식으로 프로퍼티를 정의하는 것만으로 쉽게 정의할 수 있다. 다음의 예를 보자:<p class="paragraph"/><h5>Example A</h5><p class="paragraph"/><div class="code"><pre>class Face &#123;
    Nose nose
&#125;
class Nose &#123;	
&#125;</pre></div><p class="paragraph"/>Face에서 Nose로의 단뱡향 일대일 관계를 만들었다. 이제 양뱡향 관계를 만들어보자:<p class="paragraph"/><h5>Example B</h5><p class="paragraph"/><div class="code"><pre>class Face &#123;
    Nose nose
&#125;
class Nose &#123;	
	Face face
&#125;</pre></div><p class="paragraph"/>이제 양뱡향 관계를 만들었다. 하지만 아직 두 클래스 모두 연쇄적으로 업데이트되지 않는다.<p class="paragraph"/>연쇄적으로 업데이트 되게하면 다음과 같다:<p class="paragraph"/><h5>Example C</h5><p class="paragraph"/><div class="code"><pre>class Face &#123;
    Nose nose
&#125;
class Nose &#123;	
	<span class="java&#45;keyword">static</span> belongsTo = &#91;face:Face&#93;
&#125;</pre></div><p class="paragraph"/>belongsTo를 이용하여 Nose를 Face에 종속시켰다. 이제 Face를 생성하고 저장하면 <em class="italic">연쇄적으로</em> Nose도 추가되고 변경된다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">new</span> Face(nose:<span class="java&#45;keyword">new</span> Nose()).save()</pre></div><p class="paragraph"/>The example above will save both face and nose. Note that the inverse <em class="italic">is not</em> true and will result in an error due to a transient <code>Face</code>:<p class="paragraph"/>위 예제는 Face와 Nose가 모두 잘 저장되지만 Face가 비영속 객체(transient object)므로 역순으로 생성하면 저장이 <em class="italic">안되고</em> 오류가 발생할 것이다.<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">new</span> Nose(face:<span class="java&#45;keyword">new</span> Face()).save() // will cause an error</pre></div><p class="paragraph"/>그리고 Nose는 Face에 종속되어 있기 때문에 Face를 삭제하면 Nose 역시 삭제된다.<p class="paragraph"/><div class="code"><pre>def f = Face.get(1)
f.delete() // both Face and Nose deleted</pre></div><p class="paragraph"/>belongsTo를 명시하지 않았다면 연쇄적으로 삭제되지 않는다. Nose를 명시적으로 삭제하지 않은 상태에서 Face를 삭제하면 외래키 제약조건(foreign key constraint) 에러가 발생한다:<p class="paragraph"/><div class="code"><pre>// error here without belongsTo
def f = Face.get(1)
f.delete()<p class="paragraph"/>// no error as we explicitly delete both
def f = Face.get(1)
f.nose.delete()
f.delete()</pre></div><p class="paragraph"/>다음과 같이 작성하면 이 관계를 단방향으로 만들 수도 있다. 그리고 연쇄적으로 저장, 업데이트 시킬 수 있다.<p class="paragraph"/><div class="code"><pre>class Face &#123;
    Nose nose
&#125;
class Nose &#123;	
	<span class="java&#45;keyword">static</span> belongsTo = Face
&#125;</pre></div><p class="paragraph"/>이 예제에서 belongsTo를 선언할 때 map 문법을 사용하지 않았고 관계(association)라고 부르지도 않았다는 점을 주목하자. Grails는 단방향으로 해석한다. 3가지 예제를 모두 요약하면 아래의 다이어그램과 같다.<p class="paragraph"/><img border="0" class="center" src="../img/GORM-1to1.png"></img><h2><a name="5.2.1.2 One-to-many">5.2.1.2 One-to-many</a></h2>일대다 관계는 하나의 클래스가 많은 다른 클래스의 인스턴스를 가지고 있는 것이다. <code>Author</code> 와 <code>Book</code> 의 관계가 그렇다. hasMany를 이용하여 이런 관계를 정의한다.<p class="paragraph"/><div class="code"><pre>class Author &#123;
    <span class="java&#45;keyword">static</span> hasMany = &#91; books : Book &#93;<p class="paragraph"/>    <span class="java&#45;object">String</span> name
&#125;
class Book &#123;
	<span class="java&#45;object">String</span> title
&#125;</pre></div><p class="paragraph"/>우리는 단방향 1-n 관계를 만들었다. Grails는 기본적으로 Join 테이블로 이런한 관계를 매핑한다.<p class="paragraph"/><blockquote class="note">
<a href="../guide/single.html#5.5.2 Custom ORM Mapping" class="guide">ORM DSL</a> 은 외래키 관계을 사용하여 단방향 관계를 가능하게 한다.
</blockquote><p class="paragraph"/>Grails는 자동으로 도메인 클래스의 <code>hasMany</code> 가 명시된 프로퍼티들을 <code>java.util.Set</code> 형식으로 만든다. 따라서 컬렉션(collection)의 이터레이션(iteration)을 사용할 수 있다.<p class="paragraph"/><div class="code"><pre>def a = Author.get(1)<p class="paragraph"/>a.books.each &#123;
	println it.title
&#125;</pre></div><p class="paragraph"/><blockquote class="note">
Grails에서 사용하는 기본 패치(fetch) 전략은 필요할 때(lazily) 패치하는 "lazy" 전략이다. <a href="http://www.javalobby.org/java/forums/t20533.html" target="blank">n+1 문제</a>가 발생하지 않도록 조심해야 한다.<p class="paragraph"/>"eager" 패치 전략을 취하도록 <a href="../guide/single.html#5.4 Querying with GORM" class="guide">query</a>의 일부로서 <a href="../guide/single.html#5.5.2 Custom ORM Mapping" class="guide">ORM DSL</a> 에 명시 할 수도 있다.
</blockquote><p class="paragraph"/>연쇄적으로 저장, 갱신하는 것이 기본적인 연쇄 방식이고 belongsTo가 명시되어 있지 않으면 연쇄적으로 삭제되지도 않는다.<p class="paragraph"/><div class="code"><pre>class Author &#123;
    <span class="java&#45;keyword">static</span> hasMany = &#91; books : Book &#93;<p class="paragraph"/>    <span class="java&#45;object">String</span> name
&#125;
class Book &#123;
	<span class="java&#45;keyword">static</span> belongsTo = &#91;author:Author&#93;
	<span class="java&#45;object">String</span> title
&#125;</pre></div><p class="paragraph"/>일대다 관계에서 '다'쪽의 도메인 클래스에 '일'쪽의 형식으로 정의된 프로퍼티가 두 개 이상 있다면 mappedBy를 사용하여 어떤 컬렉션에 매핑돼야 하는지 명시해야 한다.<p class="paragraph"/><div class="code"><pre>class Airport &#123;
	<span class="java&#45;keyword">static</span> hasMany = &#91;flights:Flight&#93;
	<span class="java&#45;keyword">static</span> mappedBy = &#91;flights:<span class="java&#45;quote">"departureAirport"</span>&#93;
&#125;
class Flight &#123;
	Airport departureAirport
	Airport destinationAirport
&#125;</pre></div><p class="paragraph"/>또, 컬렉션을 어러개 만들어 '다'쪽의 도메인 클래스의 다른 프로퍼티로 매핑시키는 것도 가능하다.<p class="paragraph"/><div class="code"><pre>class Airport &#123;
	<span class="java&#45;keyword">static</span> hasMany = &#91;outboundFlights:Flight, inboundFlights:Flight&#93;
	<span class="java&#45;keyword">static</span> mappedBy = &#91;outboundFlights:<span class="java&#45;quote">"departureAirport"</span>, inboundFlights:<span class="java&#45;quote">"destinationAirport"</span>&#93;
&#125;
class Flight &#123;
	Airport departureAirport
	Airport destinationAirport
&#125;</pre></div><p class="paragraph"/><h2><a name="5.2.1.3 Many-to-many">5.2.1.3 Many-to-many</a></h2>Grails는 다대다 관계를 지원한다. 양쪽 클래스에 hasMany를 정의하고 관계를 소유하는 쪽에 belongsTo를 사용하면 다대다 관계가 만들어진다.<p class="paragraph"/><div class="code"><pre>class Book &#123;
   <span class="java&#45;keyword">static</span> belongsTo = Author
   <span class="java&#45;keyword">static</span> hasMany = &#91;authors:Author&#93;
   <span class="java&#45;object">String</span> title
&#125;
class Author &#123;
   <span class="java&#45;keyword">static</span> hasMany = &#91;books:Book&#93;
   <span class="java&#45;object">String</span> name
&#125;</pre></div><p class="paragraph"/>Grails는 데이터베이스의 테이블 조인을 사용하여 다대다 관계를 구현한다. 관계를 소유하는 쪽에 관계를 영속화할 책임이 있다. 오직 한쪽에서만 연쇄적으로 저장할 수 있다. 이 경우에는 Author 클래스에 책임이 있다.<p class="paragraph"/>다음의 예는 올바르게 작동하고 연쇄적으로 저장된다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">new</span> Author(name:<span class="java&#45;quote">"Stephen King"</span>)
		.addToBooks(<span class="java&#45;keyword">new</span> Book(title:<span class="java&#45;quote">"The Stand"</span>))
		.addToBooks(<span class="java&#45;keyword">new</span> Book(title:<span class="java&#45;quote">"The Shining"</span>))		
		.save()</pre></div><p class="paragraph"/>하지만 아래의 예는 Book만 저장되고 Author들은 저장되지 않는다.<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">new</span> Book(name:<span class="java&#45;quote">"Groovy in Action"</span>)
		.addToAuthors(<span class="java&#45;keyword">new</span> Author(name:<span class="java&#45;quote">"Dierk Koenig"</span>))
		.addToAuthors(<span class="java&#45;keyword">new</span> Author(name:<span class="java&#45;quote">"Guillaume Laforge"</span>))		
		.save()</pre></div><p class="paragraph"/>다대다 관계에서는 오직 한 쪽에서만 관계를 관리할 수 있는데 이것은 Hibernate에서도 마찬가지다.<p class="paragraph"/><blockquote class="warning">
Grails의 <a href="../guide/single.html#16. Scaffolding" class="guide">Scaffolding</a> 기능은 현재 다대다 관계를 <strong class="bold">지원하지 않는다</strong>. 따라서 관계를 관리하는 코드를 직접 작성해야 한다.
</blockquote><h2><a name="5.2.2 Composition in GORM">5.2.2 Composition in GORM</a></h2><a href="../guide/single.html#5.2.1 Association in GORM" class="guide">association</a> 외에도 Grails는 결합(Composition)도 지원한다. 클래스를 각각의 테이블에 매핑하지 않고 하나의 테이블에 "포함하여" 매핑할 수 있다.<p class="paragraph"/><div class="code"><pre>class Person &#123;
	Address homeAddress
	Address workAddress
	<span class="java&#45;keyword">static</span> embedded = &#91;'homeAddress', 'workAddress'&#93;
&#125;
class Address &#123;
	<span class="java&#45;object">String</span> number
	<span class="java&#45;object">String</span> code
&#125;</pre></div><p class="paragraph"/>다음과 같이 테이블이 매핑된다.<p class="paragraph"/><img border="0" class="center" src="../img/5.2.2-composition.jpg"></img><p class="paragraph"/><blockquote class="note">
<code>grails-app/domain</code> 디렉토리에 새로운 Groovy 파일을 만들고 그 파일에 <code>Address</code> 클래스를 만들면 <code>address</code> 테이블이 생성된다. 이 것을 원하지 않으면 <code>grails-app/domain/Person.groovy</code> 파일의 <code>Person</code> 클래스 아래에 <code>Address</code> 클래스를 만든다. Groovy에서는 한 파일에 여러개의 클래스를 정의할 수 있다.
</blockquote><h2><a name="5.2.3 Inheritance in GORM">5.2.3 Inheritance in GORM</a></h2>GORM 에서는 추상 부모 클래스와 영속 GORM 엔터티에서 상속받을 수 있다. 예를 들면:<p class="paragraph"/><div class="code"><pre>class Content &#123;
     <span class="java&#45;object">String</span> author
&#125;
class BlogEntry <span class="java&#45;keyword">extends</span> Content &#123;
    URL url
&#125;
class Book <span class="java&#45;keyword">extends</span> Content &#123;
    <span class="java&#45;object">String</span> ISBN
&#125;
class PodCast <span class="java&#45;keyword">extends</span> Content &#123;
    <span class="java&#45;object">byte</span>&#91;&#93; audioStream
&#125;</pre></div><p class="paragraph"/>이 예에서 우리는 부모 클래스인 <code>Content</code> 와 다른 특징을 가진 자식 클래스들을 만들었다.<p class="paragraph"/><h4>Considerations(고려 사항)</h4><p class="paragraph"/>Grails는 기본적으로 상속 구조당 하나의 테이블(table-per-hierarchy)에 매핑한다. 부모 클래스와 그 자식 클래스들은(<code>BlogEntry</code>, <code>Book</code>, 등등) <strong class="bold">동일한</strong> 테이블을 사용하고 식별 칼럼을 두어 구분한다.<p class="paragraph"/>상속 구조당 하나의 테이블(table-per-hierarchy)에 매핑하는 것은 'not null'인 프로퍼티를 가질 수 없다는 단점이 있다. 다른 방법으로 <a href="../guide/single.html#5.5.2 Custom ORM Mapping" class="guide">ORM DSL</a>을 이용하여 클래스당 하나의 테이블(table-per-subclass)에 매핑하는 전략을 사용하는 것이다.<p class="paragraph"/>그러나 클래스당 하나의 테이블(table-per-subclass)에 매핑하는 전략을 과도하게 사용하면 조인 쿼리가 남발되기 때문에 쿼리 성능이 형편없어 진다. 우리는 상속을 남용하지말고 상속 계층를 너무 깊게 가져가지 말라고 권고한다.<p class="paragraph"/><h4>Polymorphic Queries(쿼리의 다형성)</h4><p class="paragraph"/>상속은 다형적으로(polymorphically) 질의할 수 있게 해준다. 예를 들어 <code>Content</code> 부모 클래스에서 <a href="../ref/Domain Classes/list.html" class="domainClasses">list</a> 메소드를 사용하면 모든 자식 클래스들이 반환된다:<p class="paragraph"/><div class="code"><pre>def content = Content.list() // 블로그 글, 책, 팟 캐스트 모두 나열된다.
content = Content.findAllByAuthor('Joe Bloggs') // 저자를 기준으로 찾는다.<p class="paragraph"/>def podCasts = PodCast.list() //팟 캐스트만 나열된다.</pre></div><h2><a name="5.2.4 Sets, Lists and Maps">5.2.4 Sets, Lists and Maps</a></h2><h4>Sets of objects(집합)</h4><p class="paragraph"/>관계를 만들면 GORM은 기본적으로 <code>java.util.Set</code>을 이용한다. 이 것은 정렬되지 않으며 중복을 허용하지 않는 컬렉션이다. 다음의 Author 클래스가 있다면<p class="paragraph"/><div class="code"><pre>class Author &#123;
   <span class="java&#45;keyword">static</span> hasMany = &#91;books:Book&#93;
&#125;</pre></div><p class="paragraph"/>GORM은 이 books 프로퍼티를 <code>java.util.Set</code>형식으로 만든다. 컬렉션을 사용할 때 정렬되지 않았다는 것이 문제가 될 수 있다. 정렬된 컬렉션을 사용하길 원한다면 다음처럼 books를 <code>SortedSet</code>으로 명시한다.<p class="paragraph"/><div class="code"><pre>class Author &#123;
   SortedSet books
   <span class="java&#45;keyword">static</span> hasMany = &#91;books:Book&#93;
&#125;</pre></div><p class="paragraph"/><code>java.util.SortedSet</code>을 사용하는 경우에는 Book 클래스에 <code>java.lang.Comparable</code>을 구현해야 한다.<p class="paragraph"/><div class="code"><pre>class Book <span class="java&#45;keyword">implements</span> Comparable &#123;
   <span class="java&#45;object">String</span> title
   Date releaseDate = <span class="java&#45;keyword">new</span> Date()<p class="paragraph"/>   <span class="java&#45;object">int</span> compareTo(obj) &#123;
       releaseDate.compareTo(obj.releaseDate)
   &#125;
&#125;</pre></div><p class="paragraph"/>이 예제대로 라면 Author 클래스의 books 프로퍼티에 Book 객체들이 있게된다. Book 객체들은 releaseDate를 기준으로 정렬될 것이다.<p class="paragraph"/><h4>Lists of objects(리스트)</h4><p class="paragraph"/>단순하게 집합을 객체가 추가된 순서로 유지하고 배열처럼 인덱스로 객체를 참조하게 하고 싶을 땐 <code>List</code>를 사용하면 된다:<p class="paragraph"/><div class="code"><pre>class Author &#123;
   List books
   <span class="java&#45;keyword">static</span> hasMany = &#91;books:Book&#93;
&#125;</pre></div><p class="paragraph"/>books 컬렉션의 순서는 객체를 추가한 순서대로 유지된다. 0부터 시작하는 인덱스를 이용하여 다음과 같이 사용할 수 있다:<p class="paragraph"/><div class="code"><pre>author.books&#91;0&#93; // 첫 번째 책</pre></div><p class="paragraph"/>데이터베이스 수준에서 일어나는 일을 살펴보면 Hibernate는 books_idx 컬럼을 생성한다. 데이터베이스에서도 순서를 지키기위해서 <code>book_idx</code>에 컬렉션 요소(element)의 인덱스를 저장한다.<p class="paragraph"/><code>List</code>를 사용할 때 요소를 저장하기 전에 컬렉션에 추가해야 한다. 그렇지 않으면 Hibernate는 예외를 던질 것이다(<code>org.hibernate.HibernateException: null index column for collection</code>):<p class="paragraph"/><div class="code"><pre>// This won't work!
def book = <span class="java&#45;keyword">new</span> Book(title: 'The Shining')
book.save()
author.addToBooks(book)<p class="paragraph"/>// Do it <span class="java&#45;keyword">this</span> way instead.
def book = <span class="java&#45;keyword">new</span> Book(title: 'Misery')
author.addToBooks(book)
author.save()</pre></div><p class="paragraph"/><h4>Maps of Objects(맵)</h4><p class="paragraph"/>만약 string/value 쌍만으로 이루어진 단순한 맵을 원하면 다음처럼 사용하면 된다:<p class="paragraph"/><div class="code"><pre>class Author &#123;
   Map books // map of ISBN:book names
&#125;<p class="paragraph"/>def a = <span class="java&#45;keyword">new</span> Author()
a.books = &#91;<span class="java&#45;quote">"1590597583"</span>:<span class="java&#45;quote">"Grails Book"</span>&#93;
a.save()</pre></div><p class="paragraph"/>맵의 키와 값은 모두 <strong class="bold">반드시</strong> 문자열이어야 한다.<p class="paragraph"/>객체의 맵을 원한다면 다음처럼 한다.<p class="paragraph"/><div class="code"><pre>class Book &#123;
  Map authors
  <span class="java&#45;keyword">static</span> hasMany = &#91;authors:Author&#93;
&#125;<p class="paragraph"/>def a = <span class="java&#45;keyword">new</span> Author(name:<span class="java&#45;quote">"Stephen King"</span>)<p class="paragraph"/>def book = <span class="java&#45;keyword">new</span> Book()
book.authors = &#91;stephen:a&#93;
book.save()</pre></div><p class="paragraph"/>static <code>hasMany</code> 프로퍼티로 맵의 요소의 형식을 정의할 수 있다. 이 맵의 키는 <strong class="bold">반드시</strong> 문자열이어야 한다.
<h2><a name="5.3 Persistence Basics">5.3 Persistence Basics</a></h2>Grails에서 잊지 말아야 할 것이 있는데 Grails는 내부적으로 <a href="http://www.hibernate.org/" target="blank">Hibernate</a> 을 사용하여 영속성을 구현했다. <a href="http://wiki.rubyonrails.org/rails/pages/ActiveRecord" target="blank">ActiveRecord</a> 나 <a href="http://ibatis.apache.org/" target="blank">iBatis</a> 를 사용한적이 있다면 Hibernate의 "세션 모델"이 조금 어색할 수 있다.<p class="paragraph"/>Grails는 자동으로 현재 실행하는 요청을 Hibernate 세션에 바인드(bind)시킨다. 이 것은 우리가 <a href="../ref/Domain Classes/save.html" class="domainClasses">save</a>, <a href="../ref/Domain Classes/delete.html" class="domainClasses">delete</a> 등의 GORM 메소드를 투명하게 사용할 수 있게 해준다.
<h2><a name="5.3.1 Saving and Updating">5.3.1 Saving and Updating</a></h2>다음은 <a href="../ref/Domain Classes/save.html" class="domainClasses">save</a> 메소드를 사용하는 예이다.<p class="paragraph"/><div class="code"><pre>def p = Person.get(1)
p.save()</pre></div><p class="paragraph"/>Hibernate와 가장 큰 차이점은 <a href="../ref/Domain Classes/save.html" class="domainClasses">save</a> 메소드를 호출할 때 어떠한 SQL도 실행할 필요가 없다는 것이다. 보통 Hibernate는 SQL 문을 모았다가 끝날때 일괄 처리한다. Grails는 Hibernate Session을 관리해서 자동으로 이 일을 해낸다.<p class="paragraph"/>그러나 SQL 문이 언제 실행돼야 하는지를 결정하고 싶을 때도 있다. Hibernate에서는 이 것을 세션을 "flush" 했다라고 한다. 이렇게 하기 위해서 다음처럼 save 메소드를 호출할 때 flush를 인자로 넘길 수 있다.<p class="paragraph"/><div class="code"><pre>def p = Person.get(1)
p.save(flush:<span class="java&#45;keyword">true</span>)</pre></div><p class="paragraph"/>이전의 save를 포함하여 지연된 모든 SQL 문장들이 DB와 동기화될 것이다. 이 때 예외를 처리할 수 있다. 이 예외처리는 일반적으로 낙관적 잠금(<a href="../guide/single.html#5.3.5 Pessimistic and Optimistic Locking" class="guide">optimistic locking</a>)을 포함하는 고도의 동시적concurrent 시나리오에 유용하다.<p class="paragraph"/><div class="code"><pre>def p = Person.get(1)
<span class="java&#45;keyword">try</span> &#123;
	p.save(flush:<span class="java&#45;keyword">true</span>)
&#125;
<span class="java&#45;keyword">catch</span>(Exception e) &#123;
	// deal with exception
&#125;</pre></div><h2><a name="5.3.2 Deleting Objects">5.3.2 Deleting Objects</a></h2>다음은 <a href="../ref/Domain Classes/delete.html" class="domainClasses">delete</a> 메소드를 사용하는 예이다.<p class="paragraph"/><div class="code"><pre>def p = Person.get(1)
p.delete()</pre></div><p class="paragraph"/><a href="../ref/Domain Classes/delete.html" class="domainClasses">delete</a> 메소드에도 flush 인자를 이용하여 flush시킬 수 있다.<p class="paragraph"/><div class="code"><pre>def p = Person.get(1)
p.delete(flush:<span class="java&#45;keyword">true</span>)</pre></div><p class="paragraph"/>데이터를 삭제하는 것은 조심해야 하기 때문에 Grails도 <code>deleteAll</code> 메소드를 제공하지 않는다. 이진 flags/logic을 이용해서 데이터를 삭제할 수 있다.<p class="paragraph"/>정말 일괄 삭제해야 한다면 <a href="../ref/Domain Classes/executeUpdate.html" class="domainClasses">executeUpdate</a> 메소드를 이용하여 DML 문을 실행시켜서 삭제할 수 있다.<p class="paragraph"/><div class="code"><pre>Customer.executeUpdate(<span class="java&#45;quote">"delete Customer c where c.name = :oldName"</span>, &#91;oldName:<span class="java&#45;quote">"Fred"</span>&#93;)</pre></div><p class="paragraph"/><h2><a name="5.3.3 Understanding Cascading Updates and Deletes">5.3.3 Understanding Cascading Updates and Deletes</a></h2>GORM을 사용할 때 연쇄(Cascade) 갱신과 삭제가 어떻게 동작하는 지를 이해하는 것은 중요하다. 클래스가 관계를 "소유"하는 것을 제어하는 <code>belongsTo</code> 설정이 우리가 기억해야 할 핵심이다.<p class="paragraph"/>일대일, 일대다, 다대다 관계에 상관없이 <code>belongsTo</code>를 정의했다면 갱신과 삭제는 소유한 클래스에서 그 소유물(관계의 다른 쪽)까지 연쇄적으로 동작할 것이다.<p class="paragraph"/>_belongsTo를 정의하지 않으면_ 연쇄 작업은 일어나지 않으며 모든 객체를 일일이 손수 저장해야 한다.<p class="paragraph"/>여기에 한 예가 있다.<p class="paragraph"/><div class="code"><pre>class Airport &#123;
	<span class="java&#45;object">String</span> name
	<span class="java&#45;keyword">static</span> hasMany = &#91;flights:Flight&#93;
&#125;
class Flight &#123;
	<span class="java&#45;object">String</span> number
	<span class="java&#45;keyword">static</span> belongsTo = &#91;airport:Airport&#93;
&#125;</pre></div><p class="paragraph"/><code>Airport</code>를 생성하고 <code>Flight</code>를 몇 개 추가한 후 <code>Airport</code>를 저장하면 <code>Flight</code>도 연쇄적으로 저장된다. 결국 생성한 모든 객체가 저장된다.<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">new</span> Airport(name:<span class="java&#45;quote">"Gatwick"</span>)
	 .addToFlights(<span class="java&#45;keyword">new</span> Flight(number:<span class="java&#45;quote">"BA3430"</span>))
	 .addToFlights(<span class="java&#45;keyword">new</span> Flight(number:<span class="java&#45;quote">"EZ0938"</span>))
	 .save()</pre></div><p class="paragraph"/>반대로 <code>Airport</code>를 삭제하면 관련된 모든 <code>Flight</code>도 삭제될 것이다.<p class="paragraph"/><div class="code"><pre>def airport = Airport.findByName(<span class="java&#45;quote">"Gatwick"</span>)
airport.delete()</pre></div><p class="paragraph"/>그러나 <code>belongsTo</code>를 제거하면 위의 코드는 더 이상 연쇄적으로 삭제하지 않는다. <a href="../guide/single.html#5.5.2 Custom ORM Mapping" class="guide">ORM DSL</a>을 사용하여 연쇄 행동을 제어할 수 있다.
<h2><a name="5.3.4 Eager and Lazy Fetching">5.3.4 Eager and Lazy Fetching</a></h2>GORM은 기본적으로 Lazy 패칭을 사용한다. 다음 예가 이를 잘 설명한다.<p class="paragraph"/><div class="code"><pre>class Airport &#123;
	<span class="java&#45;object">String</span> name
	<span class="java&#45;keyword">static</span> hasMany = &#91;flights:Flight&#93;
&#125;
class Flight &#123;
	<span class="java&#45;object">String</span> number
	<span class="java&#45;keyword">static</span> belongsTo = &#91;airport:Airport&#93;
&#125;</pre></div><p class="paragraph"/>위의 도메인 클래스로 다음과 같이 코드를 작성한다.<p class="paragraph"/><div class="code"><pre>def airport = Airport.findByName(<span class="java&#45;quote">"Gatwick"</span>)
airport.flights.each &#123;
	println it.name
&#125;</pre></div><p class="paragraph"/>GORM은 <code>Airport</code> 인스턴스를 가져오기 위해 단 하나의 SQL을 실행하고 <code>Flight</code>마다 추가로 1개의 쿼리를 더 실행할 것이다. 결국에 N+1번 질의한다.<p class="paragraph"/>관계(association)에 드물게 접근하는 경우에는 이 방법이 최적일 것이다. 전적으로 관계(association)의 사용빈도에 달려있다.<p class="paragraph"/>다음과 같이 Eager 패칭을 사용하는 것으로 Lazy 패칭의 단점을 해결할 수 있다.<p class="paragraph"/><div class="code"><pre>class Airport &#123;
	<span class="java&#45;object">String</span> name
	<span class="java&#45;keyword">static</span> hasMany = &#91;flights:Flight&#93;
	<span class="java&#45;keyword">static</span> fetchMode = &#91;flights:<span class="java&#45;quote">"eager"</span>&#93;
&#125;</pre></div><p class="paragraph"/><code>Airport</code> 인스턴스와 <code>Flight</code> 관계는 매핑 규칙에 따라 한번에 전부 로드될 것이다. 데이터베이스에 질의하는 빈도가 줄어드는 장점이 있지만 Eager Association이 너무 많으면 데이터베이스 전체를 메모리로 로드하게 될 수도 있으니 주의해야 한다.<p class="paragraph"/><blockquote class="note">
<a href="../guide/single.html#5.5.2 Custom ORM Mapping" class="guide">ORM DSL</a>을 이용하여 Lazy 패치없이 관계를 정의할 수 있다.
</blockquote><p class="paragraph"/>
<h2><a name="5.3.5 Pessimistic and Optimistic Locking">5.3.5 Pessimistic and Optimistic Locking</a></h2><h4>Optimistic Locking(낙관적 잠금)</h4><p class="paragraph"/>기본적으로 GORM 클래스는 낙관적 잠금을 사용하도록 돼 있다. 낙관적 잠금은 Hibernate의 것을 이용하므로 데이터베이스의 <code>version</code> 컬럼에 버전을 저장한다.<p class="paragraph"/><code>version</code> 프로퍼티를 통해서 이 버전 컬럼을 읽을 수 있다. 사용하고 있는 영속성 인스턴스의 버전을 읽는다.<p class="paragraph"/><div class="code"><pre>def airport = Airport.get(10)<p class="paragraph"/>println airport.version</pre></div><p class="paragraph"/>도메인 클래스에 대해서 업데이트를 실행하면 Hiberate는 자동으로 version 프로퍼티과 데이터베이스의 version 컬럼을 검사한다. 만약 서로 다르면 <a href="http://www.hibernate.org/hib_docs/v3/api/org/hibernate/StaleObjectStateException.html" class="api">StaleObjectException</a>을 던지고 트랜잭션을 롤백한다.<p class="paragraph"/>이 것은 성능 문제를 야기하는 비관적 잠금을 사용하지도 않고서도 원자성을 확실하게 보장하기 때문에 유용하다. 단, 동시 쓰기가 많이 발생한다면 이 예외를 직접 처리해야 한다.<p class="paragraph"/><div class="code"><pre>def airport = Airport.get(10)<p class="paragraph"/><span class="java&#45;keyword">try</span> &#123;
	airport.name = <span class="java&#45;quote">"Heathrow"</span>
	airport.save(flush:<span class="java&#45;keyword">true</span>)
&#125;
<span class="java&#45;keyword">catch</span>(org.springframework.dao.OptimisticLockingFailureException e) &#123;
	// deal with exception
&#125;</pre></div><p class="paragraph"/>어플리케이션에 따라 예외를 처리하는 방법이 달라질 수 있다. 전적으로 사용자에게 떠넘길 수도 있고 프로그램으로 데이터를 자동으로 병합해줄 수도 있고 충돌을 해결하도록 사용자에게 요청할 수 있다.<p class="paragraph"/>이 방법이 싫다면 비관적 잠금을 사용하면 된다.<p class="paragraph"/><h4>Pessimistic Locking(비관적 잠금)</h4><p class="paragraph"/>비관적 잠금은 "SELECT * FOR UPDATE" 라는 SQL 문을 실행하는 것과 동일하게 데이터베이스의 특정 열을 잠근다. 잠긴 것이 해제될 때까지 다른 읽기가 블럭된다.<p class="paragraph"/><a href="../ref/Domain Classes/lock.html" class="domainClasses">lock</a> 메소드를 이용하여 비관적 잠금을 사용할 수 있다.<p class="paragraph"/><div class="code"><pre>def airport = Airport.get(10)
airport.lock() // lock <span class="java&#45;keyword">for</span> update
airport.name = <span class="java&#45;quote">"Heathrow"</span>
airport.save()</pre></div><p class="paragraph"/>트랜잭션이 커밋되면 Grails는 잠금을 자동으로 해제한다.<h2><a name="5.4 Querying with GORM">5.4 Querying with GORM</a></h2>GORM은 동적 파인더(dynamic finder)라는 강력한 질의 방법을 제공한다. 이 것은 Hibernate의 객체지향 쿼리 언어인 HQL에 버금같다.<p class="paragraph"/><a href="http://groovy.codehaus.org/GPath" target="blank">GPath</a> 와 sort, findAll 같은 메소드들로 컬렉션을 관리할 수 있는 Groovy와 GORM의 결합은 강력한 조합을 만들어 낸다.<p class="paragraph"/>그러나. 언제나 천리길도 한 걸음부터.<p class="paragraph"/><h4>Listing instances(리스트)</h4><p class="paragraph"/>단순하게 <a href="../ref/Domain Classes/list.html" class="domainClasses">list</a> 메소드를 사용하여 클래스의 모든 인스턴스를 조회할 수 있다:<p class="paragraph"/><div class="code"><pre>def books = Book.list()</pre></div><p class="paragraph"/>페이지정보(pagination)를 <a href="../ref/Domain Classes/list.html" class="domainClasses">list</a> 메소드의 인자로 넘길 수 있다:<p class="paragraph"/><div class="code"><pre>def books = Book.list(offset:10, max:20)</pre></div><p class="paragraph"/>정렬도 가능하다.<p class="paragraph"/><div class="code"><pre>def books = Book.list(sort:<span class="java&#45;quote">"title"</span>, order:<span class="java&#45;quote">"asc"</span>)</pre></div><p class="paragraph"/>sort 인자로 정열할 때 기준이되는 도메인 클래스의 프로퍼티를 명시하고 order 인자에는 오름 정렬일 때 <strong class="bold">asc</strong>를, 내림 정렬일 때에는 <strong class="bold">desc</strong>를 사용한다<p class="paragraph"/><h4>Retrieval by Database Identifier(데이터베이스 식별자로 조회)</h4><p class="paragraph"/><a href="../ref/Domain Classes/get.html" class="domainClasses">get</a> 메소드에 데이터베이스 식별자를 인자로 넘겨서 조회할 수 있다.<p class="paragraph"/><div class="code"><pre>def book = Book.get(23)</pre></div><p class="paragraph"/>식별자들의 집합을 <a href="../ref/Domain Classes/getAll.html" class="domainClasses">getAll</a> 메소드의 인자로 넘겨서 인스턴스의 목록을 조회할 수 있다.<p class="paragraph"/><div class="code"><pre>def books = Book.getAll(23, 93, 81)</pre></div>
<h2><a name="5.4.1 Dynamic Finders">5.4.1 Dynamic Finders</a></h2>GORM은 <strong class="bold">동적 파인더</strong> 개념을 지원한다. 동적 파인더는 정적 메소드를 실행하는 것과 비슷하다. 그렇지만 동적 파인더를 지원하기 위해 특별한 메소드가 존재하는 것은 아니다.<p class="paragraph"/>메소드를 사용하는 것이 아니다. 클래스의 프로퍼티를 기반으로 런타임에 코드를 합성하여 마술처럼 자동으로 생성한다. 다음 Book 클래스의 예를 보자.<p class="paragraph"/><div class="code"><pre>class Book &#123;
	<span class="java&#45;object">String</span> title
	Date releaseDate
	Author author
&#125;                
class Author &#123;
	<span class="java&#45;object">String</span> name
&#125;</pre></div><p class="paragraph"/><code>Book</code> 클래스는 title, releaseDate, author같은 프로퍼티를 가지고 있다. 이 프로퍼티들은 '메소드 표현식(method expressions)'에 따라 <a href="../ref/Domain Classes/findBy.html" class="domainClasses">findBy</a> <a href="../ref/Domain Classes/findAllBy.html" class="domainClasses">findAllBy</a> 메소드에서 사용된다.<p class="paragraph"/><div class="code"><pre>def book = Book.findByTitle(<span class="java&#45;quote">"The Stand"</span>)<p class="paragraph"/>book = Book.findByTitleLike(<span class="java&#45;quote">"Harry Pot%"</span>)<p class="paragraph"/>book = Book.findByReleaseDateBetween( firstDate, secondDate )<p class="paragraph"/>book = Book.findByReleaseDateGreaterThan( someDate )<p class="paragraph"/>book = Book.findByTitleLikeOrReleaseDateLessThan( <span class="java&#45;quote">"%Something%"</span>, someDate )</pre></div><p class="paragraph"/><h4>Method Expressions(메소드 표현식)</h4><p class="paragraph"/>GORM의 메소드 표현식은 <a href="../ref/Domain Classes/findBy.html" class="domainClasses">findBy</a> 같은 접두어 뒤에 프로퍼티들을 연결시켜서 완성된다. 기본식은 다음과 같다.<p class="paragraph"/><div class="code"><pre>Book.findBy&#91;Property&#93;&#91;Suffix&#93;&#42;&#91;<span class="java&#45;object">Boolean</span> Operator&#93;&#42;&#91;Property&#93;&#91;Suffix&#93;</pre></div><p class="paragraph"/>*는 생략가능하고 각각의 접미어에 따라 쿼리가 달라진다. 예를 들면:<p class="paragraph"/><div class="code"><pre>def book = Book.findByTitle(<span class="java&#45;quote">"The Stand"</span>)<p class="paragraph"/>book =  Book.findByTitleLike(<span class="java&#45;quote">"Harry Pot%"</span>)</pre></div><p class="paragraph"/>
이 예에서 전자는 등호 연산과 동일하고 후자는 접미어 <code>Like</code>로 인해 <code>like</code> 연산으로 동작한다.<p class="paragraph"/>가능한 접미어들:
<ul class="star">
<li><code>LessThan</code> - less than the given value</li>
<li><code>LessThanEquals</code> - less than or equal a give value</li>
<li><code>GreaterThan</code> - greater than a given value</li>
<li><code>GreaterThanEquals</code> - greater than or equal a given value</li>
<li><code>Like</code> - Equivalent to a SQL like expression</li>
<li><code>Ilike</code> - Similar to a <code>Like</code>, except case insensitive</li>
<li><code>NotEqual</code> - Negates equality</li>
<li><code>Between</code> - Between two values (requires two arguments)</li>
<li><code>IsNotNull</code> - Not a null value (doesn't require an argument)</li>
<li><code>IsNull</code> - Is a null value (doesn't require an argument)</li>
</ul><p class="paragraph"/>You'll notice the last 3 effect the number of arguments required to the method as demonstrated by the example:<p class="paragraph"/><div class="code"><pre>def now = <span class="java&#45;keyword">new</span> Date()
def lastWeek = now &#45; 7
def book = Book.findByReleaseDateBetween( lastWeek, now )</pre></div><p class="paragraph"/>Equally <code>isNull</code> and <code>isNotNull</code> require no arguments:<p class="paragraph"/><div class="code"><pre>def books = Book.findAllByReleaseDateIsNull()</pre></div><p class="paragraph"/><h4>Boolean logic (AND/OR) </h4><p class="paragraph"/>Method expressions can also use a boolean operator to combine two criteria:<p class="paragraph"/><div class="code"><pre>def books = 
    Book.findAllByTitleLikeAndReleaseDateGreaterThan(<span class="java&#45;quote">"%Java%"</span>, <span class="java&#45;keyword">new</span> Date()&#45;30)</pre></div><p class="paragraph"/>In this case we're using <code>And</code> in the middle of the query to make sure both conditions are satisfied, but you could equally use <code>Or</code>:<p class="paragraph"/><div class="code"><pre>def books = 
    Book.findAllByTitleLikeOrReleaseDateGreaterThan(<span class="java&#45;quote">"%Java%"</span>, <span class="java&#45;keyword">new</span> Date()&#45;30)</pre></div><p class="paragraph"/>Clearly, method names can end up being quite long, in which case you should consider using <a href="../guide/single.html#5.4.2 Criteria" class="guide">Criteria</a>.<p class="paragraph"/><h4>Querying Associations</h4><p class="paragraph"/>Associations can also be used within queries:<p class="paragraph"/><div class="code"><pre>def author = Author.findByName(<span class="java&#45;quote">"Stephen King"</span>)<p class="paragraph"/>def books = author ? Book.findAllByAuthor(author) : &#91;&#93;</pre></div><p class="paragraph"/>In this case if the <code>Author</code> instance is not null we use it in a query to obtain all the <code>Book</code> instances for the given <code>Author</code>.<p class="paragraph"/><h4>Pagination &#38; Sorting</h4><p class="paragraph"/>The same pagination and sorting parameters available on the <a href="../ref/Domain Classes/list.html" class="domainClasses">list</a> method can also be used with dynamic finders by supplying a map as the final parameter:<p class="paragraph"/><div class="code"><pre>def books = 
  Book.findAllByTitleLike(<span class="java&#45;quote">"Harry Pot%"</span>, &#91;max:3, 
                                         offset:2, 
                                         sort:<span class="java&#45;quote">"title"</span>,
                                         order:<span class="java&#45;quote">"desc"</span>&#93;)</pre></div>
<h2><a name="5.4.2 Criteria">5.4.2 Criteria</a></h2>Criteria는 복잡한 쿼리를 만들기 위해 Groovy 빌더를 사용한다. Criteria는 자료형이 보장(type safe)되는 매우 훌륭한 도구다. 이 것이 StringBuffer보다 훨씬 훌륭하다.<p class="paragraph"/><a href="../ref/Domain Classes/createCriteria.html" class="domainClasses">createCriteria</a>나 <a href="../ref/Domain Classes/withCriteria.html" class="domainClasses">withCriteria</a> 메소드를 통해서 Criteria를 사용한다. 이 빌더는 Hibernate의 Criteria API를 사용한다. 빌더의 노드들은 Hibernate의 Criteria API의 <a href="http://www.hibernate.org/hib_docs/v3/api/org/hibernate/criterion/Restrictions.html" class="api">Restrictions</a> 클래스에 있는 static method들에 매핑된다. 다음의 예를 보자:<p class="paragraph"/><div class="code"><pre>def c = Account.createCriteria()
def results = c &#123;
	like(<span class="java&#45;quote">"holderFirstName"</span>, <span class="java&#45;quote">"Fred%"</span>)
	and &#123;
		between(<span class="java&#45;quote">"balance"</span>, 500, 1000)
		eq(<span class="java&#45;quote">"branch"</span>, <span class="java&#45;quote">"London"</span>)
	&#125;
	maxResults(10)
	order(<span class="java&#45;quote">"holderLastName"</span>, <span class="java&#45;quote">"desc"</span>)
&#125;</pre></div><p class="paragraph"/><h4>Conjunctions and Disjunctions(논리곱과 논리합)</h4><p class="paragraph"/>위의 예에서 보여주듯이 <code>and { }</code>을 이용하여 논리블럭을 만들고 Criteria에 논리연산을 적용할 수 있다:<p class="paragraph"/><div class="code"><pre>and &#123;
	between(<span class="java&#45;quote">"balance"</span>, 500, 1000)
	eq(<span class="java&#45;quote">"branch"</span>, <span class="java&#45;quote">"London"</span>)
&#125;</pre></div><p class="paragraph"/>OR 연산자도 마찬가지다:<p class="paragraph"/><div class="code"><pre>or &#123;
	between(<span class="java&#45;quote">"balance"</span>, 500, 1000)
	eq(<span class="java&#45;quote">"branch"</span>, <span class="java&#45;quote">"London"</span>)
&#125;</pre></div><p class="paragraph"/>NOT 연산자에서도 잘 동작한다:<p class="paragraph"/><div class="code"><pre>not &#123;
	between(<span class="java&#45;quote">"balance"</span>, 500, 1000)
	eq(<span class="java&#45;quote">"branch"</span>, <span class="java&#45;quote">"London"</span>)
&#125;</pre></div><p class="paragraph"/><h4>Querying Associations(관계 질의하기)</h4><p class="paragraph"/>프로퍼티에 알 맞는 노드가 있으면 관계를 질의할 수 있다. 다음 예제는 <code>Account</code> 클래스는 많은 <code>Transaction</code> 객체를 가질 수 있다는 것을 말해준다.<p class="paragraph"/><div class="code"><pre>class Account &#123;
    &#8230;
    def hasMany = &#91;transactions:Transaction&#93;
    Set transactions
    &#8230;
&#125;</pre></div><p class="paragraph"/>우리는 빌더 노드에 <code>transaction</code> 프로퍼티을 사용하여 이 관계를 질의할 수 있다.<p class="paragraph"/><div class="code"><pre>def c = Account.createCriteria()
def now = <span class="java&#45;keyword">new</span> Date()
def results = c.list &#123;
       transactions &#123;
            between('date',now&#45;10, now)
       &#125;
&#125;</pre></div><p class="paragraph"/>이 예제는 최근 10일안에 <code>transaction</code>이 있었던 <code>Account</code> 인스턴스를 모두 찾는다.
그리고 그러한 관계를 질의하는 쿼리를 논리 블럭안에 넣을 수 있다.:<p class="paragraph"/><div class="code"><pre>def c = Account.createCriteria()
def now = <span class="java&#45;keyword">new</span> Date()
def results = c.list &#123;
     or &#123;
        between('created',now&#45;10,now)
        transactions &#123;
             between('date',now&#45;10, now)
        &#125;
     &#125;
&#125;</pre></div><p class="paragraph"/>이 예제는 최근 10일 이내에 transaction이 수행됐었거나 생성된 Account 인스턴스들은 모두 찾는다.<p class="paragraph"/><h4>Querying with Projections(프로젝션으로 질의하기)</h4><p class="paragraph"/>프로젝션은 결과를 사용자 사정에 맞추는데(customize) 사용된다. 프로젝션을 사용하기 위해서는 Criteria 빌더 트리에 "projections" 노드를 정의해야 한다. projections 노드의 메소드은 Hibernate의 <a href="http://www.hibernate.org/hib_docs/v3/api/org/hibernate/criterion/Projections.html" class="api">Projections</a> 클래스의 메소드와 동일하다:<p class="paragraph"/><div class="code"><pre>def c = Account.createCriteria()<p class="paragraph"/>def numberOfBranches = c.get &#123;
	projections &#123;
		countDistinct('branch')
	&#125;
&#125;</pre></div><p class="paragraph"/><h4>Using Scrollable Results(스크롤되는 결과의 사용)</h4><p class="paragraph"/>scroll 메소드를 호출하여 Hiberate의 <a href="http://www.hibernate.org/hib_docs/v3/api/org/hibernate/ScrollableResults.html" class="api">ScrollableResults</a> 기능을 사용할 수 있다.<p class="paragraph"/><div class="code"><pre>def results = crit.scroll &#123;
      maxResults(10)
&#125;
def f = results.first()
def l = results.last()
def n = results.next()
def p = results.previous()<p class="paragraph"/>def <span class="java&#45;keyword">future</span> = results.scroll(10)
def accountNumber = results.getLong('number')</pre></div><p class="paragraph"/>Hiberate에서 ScrollableResult를 설명하는 문서를 인용했다:<p class="paragraph"/><blockquote class="quote">
원하는 개수만큼 결과를 스크롤할 수 있는 result iterator이다. Query/ScrollableResults 패턴은 JDBC PreparedStatement/ResultSet 패턴과 매우 유사하고 메소드의 이름도 ResultSet의 것과 비슷하게 지어졌다.
</blockquote><p class="paragraph"/>하지만 JDBC와는 다르게 결과의 컬럼의 인덱스는 0부터 시작한다.<p class="paragraph"/><h4>Setting properties in the Criteria instance(Criteria 인스턴스의 프로퍼티를 설정하기)</h4><p class="paragraph"/>빌더 트리에서 기술한 조건이 해석할 수 없으면 Criteria 인스턴스의 자체 프로퍼티를 설정하려고 시도한다. 그래서 이 클래스의 모든 프로퍼티에 접근하는 것이 가능하다. 아래의 예를 보면 <a href="http://www.hibernate.org/hib_docs/v3/api/org/hibernate/Criteria.html" class="api">Criteria</a> 인스턴스의 <code>setMaxResults</code>와 <code>setFirstResult</code> 메소드가 호출된다.<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> org.hibernate.FetchMode as FM
	&#8230;
	def results = c.list &#123;
		maxResults(10)
		firstResult(50)
		fetchMode(<span class="java&#45;quote">"aRelationship"</span>, FM.EAGER)
	&#125;</pre></div><p class="paragraph"/><h4>Querying with Eager Fetching(Eager 패칭으로 질의하기)</h4><p class="paragraph"/><a href="../guide/single.html#5.3.4 Eager and Lazy Fetching" class="guide">Eager and Lazy Fetching</a> 을 설명하면서 우리는 N+1 select 문제를 회피하는 방법에 대해 이미 다루었다. 하지만 Criteria를 이용하여 동일한 일을 할 수 있다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> org.hibernate.FetchMode as FM
...<p class="paragraph"/>def criteria = Task.createCriteria()
def tasks = criteria.list&#123;
     eq(<span class="java&#45;quote">"assignee.id"</span>, task.assignee.id)
     fetchMode('assignee', FM.EAGER)
     fetchMode('project', FM.EAGER)
     order('priority', 'asc')
&#125;</pre></div><p class="paragraph"/>
<h4>Method Reference(메소드 레퍼런스)</h4><p class="paragraph"/>만약 다음의 예제처럼 아무것도 없이 빌더를 실행하면:<p class="paragraph"/><div class="code"><pre>c &#123; &#8230; &#125;</pre></div><p class="paragraph"/>결과의 목록을 얻어오는 것이 빌더의 목적이므로 다음의 예제와 동일하게 작동된다:<p class="paragraph"/><div class="code"><pre>c.list &#123; &#8230; &#125;</pre></div><p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th>메소드</th><th>설명</th></tr><tr class="table-odd"></tr><tr class="table-even"><td><strong class="bold">list</strong></td><td>기본 메소드로 조건에 만족하는 모든 열을 반환한다.</td></tr><tr class="table-odd"><td><strong class="bold">get</strong></td><td>단 한 개의 결과 집합(result set)를 반환한다. 이 메소드를 위한 Criteria는 단 한 개의 결과를 반환하도록 만들어져야 한다. 이 메소드와 단지 첫 열만을 얻어오는 것과 혼동하지 말아야 한다.</td></tr><tr class="table-even"><td><strong class="bold">scroll</strong></td><td>스크롤되는 결과를 반환한다.</td></tr><tr class="table-odd"><td><strong class="bold">listDistinct</strong></td><td>서브쿼리나 관계를 이용할 때 결과 집합에서 동일한 열이 여러개 존재할 수 있는데 이 것으로 중복을 허용하지 않을 수 있다. <a href="http://www.hibernate.org/hib_docs/v3/api/org/hibernate/criterion/CriteriaSpecification.html" class="api">CriteriaSpecification</a> 클래스의 <code>DISTINCT_ROOT_ENTITY</code>와 동일하다.</td></tr></table><p class="paragraph"/><h2><a name="5.4.3 Hibernate Query Language (HQL)">5.4.3 Hibernate Query Language (HQL)</a></h2>GORM에서는 HQL도 사용할 수 있다. Hiberate 문서의 <a href="http://www.hibernate.org/hib_docs/reference/en/html/queryhql.html" target="blank">14장 HQL: The Hibernate Query Language</a>에서 HQL에대한 모든 것을 참고할 수 있다.<p class="paragraph"/>GORM은 find, <a href="../ref/Domain Classes/findAll.html" class="domainClasses">findAll</a> <a href="../ref/Domain Classes/executeQuery.html" class="domainClasses">executeQuery</a> 등의 HQL을 사용할 수 있는 얼마간의 메소드들을 제공한다.<p class="paragraph"/><div class="code"><pre>def results =
      Book.findAll(<span class="java&#45;quote">"from Book as b where b.title like 'Lord of the%'"</span>)</pre></div><p class="paragraph"/><h4>Positional and Named Parameters(위치 파라미터와 이름 파라미터)</h4><p class="paragraph"/>쿼리에 필요한 값은 하드코딩하려 한다면 위치 파리미터를 사용할 수 있다:<p class="paragraph"/><div class="code"><pre>def results =
      Book.findAll(<span class="java&#45;quote">"from Book as b where b.title like ?"</span>, &#91;<span class="java&#45;quote">"The Shi%"</span>&#93;)</pre></div><p class="paragraph"/>이름 파라미터를 사용하는 것도 가능하다:<p class="paragraph"/><div class="code"><pre>def results =
      Book.findAll(<span class="java&#45;quote">"from Book as b where b.title like :search or b.author like :search"</span>, &#91;search:<span class="java&#45;quote">"The Shi%"</span>&#93;)</pre></div><p class="paragraph"/><h4>Multiline Queries(여러 줄로 질의하기)</h4><p class="paragraph"/>쿼리를 여러줄에 걸쳐서 만들어야 한다면 라인연결문자를 사용하라:<p class="paragraph"/><img border="0" class="center" src="../img/multilinehql.png"></img><p class="paragraph"/><blockquote class="note">
여러 줄 문자열을 만들기 위한 Groovy로 표현법은 HQL 쿼리에 사용할 수 없다.
</blockquote><p class="paragraph"/><h4>Pagination and Sorting(페이지 매김과 정렬)</h4><p class="paragraph"/>HQL에서도 패이지를 매길 수 있고 정열할 수 있다. 간단하게 메소드 끝에 맵 형식으로 페이지 매김과 정열 옵션을 기술한다.<p class="paragraph"/><div class="code"><pre>def results =
      Book.findAll(<span class="java&#45;quote">"from Book as b where b.title like 'Lord of the%'"</span>, 
                   &#91;max:10, offset:20, sort:<span class="java&#45;quote">"title"</span>, order:<span class="java&#45;quote">"asc"</span>&#93;)</pre></div><h2><a name="5.5 Advanced GORM Features">5.5 Advanced GORM Features</a></h2>앞으로 우리는 캐싱, 매핑 방법, 이벤트를 다루는 방법들에 대해 알아보자.
<h2><a name="5.5.1 Events and Auto Timestamping">5.5.1 Events and Auto Timestamping</a></h2>GORM은 delete, insert, update같은 이벤트가 발생할 때 수행될 클로저(closure)를 등록할 수 있다. 단순히 도메인 클래스의 이벤트에 적절한 클로저를 동록하면 된다. 다음과 같은 이벤트들이 있다.<p class="paragraph"/><h4>The beforeInsert event(beforeInsert 이벤트)</h4><p class="paragraph"/>객체가 데이터베이스에 저장되기 전에 실행된다.<p class="paragraph"/><div class="code"><pre>class Person &#123;
   Date dateCreated<p class="paragraph"/>   def beforeInsert = &#123;
       dateCreated = <span class="java&#45;keyword">new</span> Date()
   &#125;
&#125;</pre></div><p class="paragraph"/><h4>The beforeUpdate event(beforeUpdate 이벤트)</h4><p class="paragraph"/>객체가 업데이트되기 전에 실행된다.<p class="paragraph"/><div class="code"><pre>class Person &#123;
   Date dateCreated
   Date lastUpdated<p class="paragraph"/>   def beforeInsert = &#123;
       dateCreated = <span class="java&#45;keyword">new</span> Date()
   &#125;
   def beforeUpdate = &#123;
       lastUpdated = <span class="java&#45;keyword">new</span> Date()
   &#125;
&#125;</pre></div><p class="paragraph"/><h4>The beforeDelete event(beforeDelete 이벤트)</h4><p class="paragraph"/>객체가 삭제되기 전에 실행된다.<p class="paragraph"/><div class="code"><pre>class Person &#123;
   <span class="java&#45;object">String</span> name
   Date dateCreated
   Date lastUpdated<p class="paragraph"/>   def beforeDelete = &#123;
      <span class="java&#45;keyword">new</span> ActivityTrace(eventName:<span class="java&#45;quote">"Person Deleted"</span>,data:name).save()
   &#125;
&#125;</pre></div><p class="paragraph"/><h4>The onLoad event(onLoad 이벤트)</h4><p class="paragraph"/>데이터베이스에서 객체가 로드될때 실행된다:<p class="paragraph"/><div class="code"><pre>class Person &#123;
   <span class="java&#45;object">String</span> name
   Date dateCreated
   Date lastUpdated<p class="paragraph"/>   def onLoad = &#123;
      name = <span class="java&#45;quote">"I'm loaded"</span>
   &#125;
&#125;</pre></div><p class="paragraph"/><h4>Automatic timestamping(자동 시간도장)</h4><p class="paragraph"/>위의 예에서 이벤트를 사용하여 <code>lastUpdated</code>와 <code>dateCreated</code> 프로퍼티를 업데이트하는 방법에 대해 알아보았다. GORM은 객체의 히스토리를 유지하는 다른방법을 제공한다. GORM에서는 단순히 <code>lastUpdated</code>와 <code>dateCreated</code> 프로퍼티만 정의하는 것만으로도 충분한다.<p class="paragraph"/>이 기능이 맘에 들지 않는다면 끌 수 있다:<p class="paragraph"/><div class="code"><pre>class Person &#123;
   Date dateCreated
   Date lastUpdated
   <span class="java&#45;keyword">static</span> mapping = &#123;
      autoTimestamp <span class="java&#45;keyword">false</span>
   &#125;
&#125;</pre></div><p class="paragraph"/><h2><a name="5.5.2 Custom ORM Mapping">5.5.2 Custom ORM Mapping</a></h2>Grails의 도메인 클래스는 ORM DSL(Object Relational Mapping Domain Specify Language) 레거시 스키마에 매핑될 수 있다. 다음 장에서 ORM DSL로 할 수 있는 일들을 설명한다.<p class="paragraph"/><blockquote class="note">
GORM의 관례에 따르는 테이블, 컬럼 이름등이 마음에 든다면 이 것은 전혀 필요없다. 캐싱을 한다거나 GORM을 레거시 스키마에 매핑하려 할때에만 이 기능이 필요하다.
</blockquote><p class="paragraph"/>도메인 클래스에 정적 mapping 블럭을 사용하므로써 매핑 규칙을 정의할 수 있다:<p class="paragraph"/><div class="code"><pre>class Person &#123;
  ..
  <span class="java&#45;keyword">static</span> mapping = &#123;<p class="paragraph"/>  &#125;
&#125;</pre></div>
<h2><a name="5.5.2.1 Table and Column Names">5.5.2.1 Table and Column Names</a></h2><h4>Table names(테이블 이름)</h4><p class="paragraph"/><code>table</code>을 사용하여 클래스가 매핑될 데이터베이스 테이블 이름을 정의할 수 있다.:<p class="paragraph"/><div class="code"><pre>class Person &#123;
  ..
  <span class="java&#45;keyword">static</span> mapping = &#123;
      table 'people'
  &#125;
&#125;</pre></div><p class="paragraph"/>이 경우 <code>person</code>이 아니라 <code>people</code>이라는 테이블에 매핑될 것이다.<p class="paragraph"/><h4>Column names(컬럼 이름)</h4><p class="paragraph"/>데이터베이스의 컬럼에 매핑하는 규칙도 정의할 수 있다. 다음의 예제처럼 원하는 이름으로 매핑시킬 수 있다:<p class="paragraph"/><div class="code"><pre>class Person &#123;
  <span class="java&#45;object">String</span> firstName
  <span class="java&#45;keyword">static</span> mapping = &#123;
      table 'people'
      firstName column:'First_Name'
  &#125;
&#125;</pre></div><p class="paragraph"/>이 예제에서는 매핑할 프로퍼티 이름은 <code>firstName</code>이고 <code>column</code>이라는 파라미터를 이용하여 어느 컬럼에 매핑할지 명시한다.<p class="paragraph"/><h4>Column type(컬럼 타입)</h4><p class="paragraph"/>GORM은 DSL의 타입 속성(attribute)으로 Hibernate 타입을 설정할 수 있다. 이 것은 <a href="http://www.hibernate.org/hib_docs/v3/api/org/hibernate/types/UserType.html" class="api">org.hibernate.types.UserType</a>를 상속한 사용자 타입도 명시할 수 있고 타입에 어떻게 영속성을 부여할지 정의할 수 있게 한다. <code>PostCodeType</code>을 만들었고 이 것을 사용한다면 다음의 예제처럼 할 수 있다:<p class="paragraph"/><div class="code"><pre>class Address &#123;
   <span class="java&#45;object">String</span> number
   <span class="java&#45;object">String</span> postCode
   <span class="java&#45;keyword">static</span> mapping = &#123;
      postCode type:PostCodeType
   &#125;
&#125;</pre></div><p class="paragraph"/>뿐만아니라 Grails가 선택하는 기본 타입을 사용하지 않고 Hibernate가 제공하는 기본 타입중에 하나로 매핑하게 할 수 있다:<p class="paragraph"/><div class="code"><pre>class Address &#123;
   <span class="java&#45;object">String</span> number
   <span class="java&#45;object">String</span> postCode
   <span class="java&#45;keyword">static</span> mapping = &#123;
      postCode type:'text'
   &#125;
&#125;</pre></div><p class="paragraph"/>이 예제에서는 <code>postCode</code> 컬럼이 SQL TEXT나 CLOB 형식에 매핑된다. 매핑되는 형식은 사용하는 데이터베이스에 따라 다르다.<p class="paragraph"/><h4>One-to-One Mapping(일대일 매핑)</h4><p class="paragraph"/>관계(association)가 있을 때 관계를 매핑하는 외래 키를 변경하는 것도 가능하다. 일대일 관계에서는 일반 컬럼을 매핑하는 것과 동일하다. 예를 들면 다음과 같다:<p class="paragraph"/><div class="code"><pre>class Person &#123;
  <span class="java&#45;object">String</span> firstName
  Address address
  <span class="java&#45;keyword">static</span> mapping = &#123;
      table 'people'
      firstName column:'First_Name'
	  address column:'Person_Adress_Id'
  &#125;
&#125;</pre></div><p class="paragraph"/>기본적으로 <code>address</code> 관계는 외래키 컬럼 <code>address_id</code>에 매핑된다. 그러나 <code>Person_Adress_Id</code> 컬럼에 매핑하도록 변경했다.<p class="paragraph"/><h4>One-to-Many Mapping(일대다 매핑)</h4><p class="paragraph"/>양방향 일대다 관계에서는 '다'쪽의 컬럼이름을 변경하는 것만으로도 외래키 컬럼을 변경할 수 있다. 하지만 단방향 관계에서는 관계 자체에 외래키를 명시해야 한다. 다음은 <code>Person</code>과 <code>Address</code>사이의 단방향 일대다 관계에서 <code>address</code> 테이블의 외래키를 변경시키는 예제이다:<p class="paragraph"/><div class="code"><pre>class Person &#123;
  <span class="java&#45;object">String</span> firstName
  <span class="java&#45;keyword">static</span> hasMany = &#91;addresses:Address&#93;
  <span class="java&#45;keyword">static</span> mapping = &#123;
      table 'people'
      firstName column:'First_Name'
	  addresses column:'Person_Address_Id'
  &#125;
&#125;</pre></div><p class="paragraph"/><code>joinTable</code> 파라미터를 이용하면 <code>address</code> 테이블에 있는 컬럼이 아니라 테이블을 조인할 수 있다:<p class="paragraph"/><div class="code"><pre>class Person &#123;
  <span class="java&#45;object">String</span> firstName
  <span class="java&#45;keyword">static</span> hasMany = &#91;addresses:Address&#93;
  <span class="java&#45;keyword">static</span> mapping = &#123;
      table 'people'
      firstName column:'First_Name'
      addresses joinTable:&#91;name:'Person_Addresses', key:'Person_Id', column:'Address_Id'&#93;
  &#125;
&#125;</pre></div><p class="paragraph"/><h4>Many-to-Many Mapping(다대다 매핑)</h4><p class="paragraph"/>Grails에서는 기본적으로 n-n 관계를 조인 테이블으로 매핑한다. 다음은 n-n 관계의 예제이다:<p class="paragraph"/><div class="code"><pre>class Group &#123;
	&#8230;
	<span class="java&#45;keyword">static</span> hasMany = &#91;people:Person&#93;
&#125;
class Person &#123;
	&#8230;
	<span class="java&#45;keyword">static</span> belongsTo = Group
	<span class="java&#45;keyword">static</span> hasMany = &#91;groups:Group&#93;
&#125;</pre></div><p class="paragraph"/>이 예제에서 Grails는 <code>person</code>과 <code>group</code> 테이블을 참조하는 외래키 <code>person_id</code>와 <code>group_id</code>을 사용하여 <code>group_person</code>이라는 조인 테이블을 만든다. 각 클래스를 매핑할 때 mapping 블럭에 컬럼을 명시하여 매핑하는 컬럼도 변경할 수 있다:<p class="paragraph"/><div class="code"><pre>class Group &#123;
   &#8230;
   <span class="java&#45;keyword">static</span> mapping = &#123;
       people column:'Group_Person_Id'
   &#125;	
&#125;
class Person &#123;
   &#8230;
   <span class="java&#45;keyword">static</span> mapping = &#123;
       groups column:'Group_Group_Id'
   &#125;	
&#125;</pre></div><p class="paragraph"/>사용할 조인 테이블의 이름도 명시할 수 있다:<p class="paragraph"/><div class="code"><pre>class Group &#123;
   &#8230;
   <span class="java&#45;keyword">static</span> mapping = &#123;
       people column:'Group_Person_Id',joinTable:'PERSON_GROUP_ASSOCIATIONS'
   &#125;	
&#125;
class Person &#123;
   &#8230;
   <span class="java&#45;keyword">static</span> mapping = &#123;
       groups column:'Group_Group_Id',joinTable:'PERSON_GROUP_ASSOCIATIONS'
   &#125;	
&#125;</pre></div><h2><a name="5.5.2.2 Caching Strategy">5.5.2.2 Caching Strategy</a></h2><h4>Setting up caching(캐싱 설정하기)</h4><p class="paragraph"/><a href="http://www.hibernate.org/" target="blank">Hibernate</a> 는 사용자가 정의 가능한 캐시 프로바이더(cache provider)를 지원하는 2차 캐시 second-level cache를 가지고 있다. 다음의 예처럼 <code>grails-app/conf/DataSource.groovy</code>에 설정한다:<p class="paragraph"/><div class="code"><pre>hibernate &#123;
    cache.use_second_level_cache=<span class="java&#45;keyword">true</span>
    cache.use_query_cache=<span class="java&#45;keyword">true</span>
    cache.provider_class='org.hibernate.cache.EhCacheProvider'
&#125;</pre></div><p class="paragraph"/>당연히 원하는 대로 설정할 수 있다. 예를 들어, 분산 캐시 매커니즘을 사용하고 싶다면 그렇게 할 수 있다.<p class="paragraph"/><blockquote class="note">
캐시에 대하여, 특히 Hibernate의 2차 캐시second-level cache에 대하여 더 알고 싶으면 <a href="http://www.hibernate.org/hib_docs/reference/en/html/performance.html#performance-cache" target="blank">Hibernate 문서</a>에서 관련 주제를 참고하라.
</blockquote><p class="paragraph"/><h4>Caching instances(인스턴스 캐싱하기)</h4><p class="paragraph"/>기본적으로 캐싱되게 하려면 mapping 블럭에 <code>cache</code> 매소드를 호출한다:<p class="paragraph"/><div class="code"><pre>class Person &#123;
  ..
  <span class="java&#45;keyword">static</span> mapping = &#123;
      table 'people'
      cache <span class="java&#45;keyword">true</span>
  &#125;
&#125;</pre></div><p class="paragraph"/>이 예제에서는 lazy든 아니든 상관하지 않고 'read-write'로 캐싱한다. 물론 이 전략도 변경할 수 있다:<p class="paragraph"/><div class="code"><pre>class Person &#123;
  ..
  <span class="java&#45;keyword">static</span> mapping = &#123;
      table 'people'
      cache usage:'read&#45;only', include:'non&#45;lazy'
  &#125;
&#125;</pre></div><p class="paragraph"/><h4>Caching associations(관계 캐싱하기)</h4><p class="paragraph"/>인스턴스를 캐싱할 때 Hibernate의 2차 캐시를 사용하도록 할 수 있을 뿐만 아니라 객체의 컬렉션도 캐싱할 수 있다. 다음의 코드를 보면:<p class="paragraph"/><div class="code"><pre>class Person &#123;
  <span class="java&#45;object">String</span> firstName
  <span class="java&#45;keyword">static</span> hasMany = &#91;addresses:Address&#93;
  <span class="java&#45;keyword">static</span> mapping = &#123;
      table 'people'
      version <span class="java&#45;keyword">false</span>
      addresses column:'Address', cache:<span class="java&#45;keyword">true</span>
  &#125;
&#125;
class Address &#123;
   <span class="java&#45;object">String</span> number
   <span class="java&#45;object">String</span> postCode
&#125;</pre></div><p class="paragraph"/>이 예제는 addresses 컬렉션에 대해 'read-write'로 캐싱한다. 'read-write'뿐만 아니라 다른 것도 사용할 수 있다:<p class="paragraph"/><div class="code"><pre>cache:'read&#45;write' // or 'read&#45;only' or 'transactional'</pre></div><p class="paragraph"/>캐시 사용법에서 보다 자세히 설명한다.<p class="paragraph"/><h4>Cache usages(캐시 사용법)</h4><p class="paragraph"/>다음은 설정할 수 있는 캐싱 정책과 그 사용법에 대한 설명이다.
<ul class="star">
<li><code>read-only</code> - 영속 클래스를 전혀 수정하지 않고 읽기만 한다면 'read-only' 캐시를 사용하라.</li>
<li><code>read-write</code> - 데이터를 수정할 것이라면 'read-write' 캐시가 적절하다.</li>
<li><code>nonstrict-read-write</code> - 가끔 데이터를 수정하고(두 트랜젝션에서 동일한 아이템을 동시에 수정하지 않을 것 같다면) 엄격한 트랜젝션 격리(strict transaction isolation)가 필요없다면 <code>nonstrict-read-write</code>를 사용하는 것이 좋다.</li>
<li><code>transactional</code> - 이 전략은 JBoss의 TreeCache같은 완벽한 트랜젝션 지향 캐시 공급자(fully transactional cache providers)를 사용할 수 있게 해준다. 그런 캐시는 JTA 환경에서만 사용되고 <code>grails-app/conf/DataSource.groovy</code>파일에서의 <code>Hiberate</code> 설정에 <code>hibernate.transaction.manager_lookup_class</code>를 명시해야만 한다.</li>
</ul><p class="paragraph"/><h2><a name="5.5.2.3 Inheritance Strategies">5.5.2.3 Inheritance Strategies</a></h2>GORM은 기본적으로 상속 구조당 하나의 테이블(table-per-hierarchy)로 매핑시킨다. 이것은 데이터베이스의 컬럼이 <code>NOT-NULL</code> 제약조건을 따르도록 하지 못하는 단점이 있다. 클래스당 하나의 테이블(table-per-subclass)을 사용하는 전략을 취하려면 다음처럼 한다:<p class="paragraph"/><div class="code"><pre>class Payment &#123;
    <span class="java&#45;object">Long</span> id
    <span class="java&#45;object">Long</span> version
    <span class="java&#45;object">Integer</span> amount<p class="paragraph"/>    <span class="java&#45;keyword">static</span> mapping = &#123;
        tablePerHierarchy <span class="java&#45;keyword">false</span>
    &#125;
&#125;
class CreditCardPayment <span class="java&#45;keyword">extends</span> Payment  &#123;
    <span class="java&#45;object">String</span> cardNumber
&#125;</pre></div><p class="paragraph"/>기본 클래스인 <code>Payment</code>를 상속받은 모든 클래스는 상속 구조당 하나의 테이블(table-per-hierarchy)로 매핑되지 않을 것이다.<p class="paragraph"/><h2><a name="5.5.2.4 Custom Database Identity">5.5.2.4 Custom Database Identity</a></h2>DSL을 사용하여 GORM이 데이터베이스 식별자를 생성하는 방법을 정의할 수 있다. GORM은 사용하는 데이터베이스가 메커니즘에 따라 id를 생성한다. 이 것은 분명 최상의 방법인데 아직도 다른 방법으로 접근해야 하는 스키마들이 많이 있다.<p class="paragraph"/>Hibernate의 식별자 생성기id generator를 정의해야 한다. 입맛에 맞는 식별자 생성기(id generator)를 정의하고 그에 따라 매핑되게 할 수 있다.<p class="paragraph"/><div class="code"><pre>class Person &#123;
  ..
  <span class="java&#45;keyword">static</span> mapping = &#123;
      table 'people'
      version <span class="java&#45;keyword">false</span>
      id generator:'hilo', params:&#91;table:'hi_value',column:'next_value',max_lo:100&#93;
  &#125;
&#125;</pre></div><p class="paragraph"/>이 예에서는 Hibernate에 기본적으로 포함된 'hilo' 생성기를 사용한다. 'hilo' 생성기는 식별자를 생성하기 위해 별도의 테이블을 사용한다.<p class="paragraph"/><blockquote class="note">
Hibernate 생성기에 대한 정보가 더 필요하면 <a href="http://www.hibernate.org/hib_docs/reference/en/html/mapping.html#mapping-declaration-id-generator" target="blank">Hibernate reference documentation</a>를 참고하라
</blockquote><p class="paragraph"/>식별자가 사용하는 컬럼을 명시하려면 다음과 같이 할 수 있다:<p class="paragraph"/><div class="code"><pre>class Person &#123;
  ..
  <span class="java&#45;keyword">static</span> mapping = &#123;
      table 'people'
      version <span class="java&#45;keyword">false</span>
      id column:'person_id'
  &#125;
&#125;</pre></div>
<h2><a name="5.5.2.5 Composite Primary Keys">5.5.2.5 Composite Primary Keys</a></h2>GORM은 두 개 이상의 속성으로 구성되는 복합 식별자의 개념을 지원한다. 권장되는 방법이 아니지만 할 수 있다:<p class="paragraph"/><div class="code"><pre>class Person &#123;
  <span class="java&#45;object">String</span> firstName
  <span class="java&#45;object">String</span> lastName<p class="paragraph"/>  <span class="java&#45;keyword">static</span> mapping = &#123;
      id composite:&#91;'firstName', 'lastName'&#93;
  &#125;
&#125;</pre></div><p class="paragraph"/>이 예는 Person클래스의 <code>firstName</code>과 <code>lastName</code> 속성을 이용하는 복합 식별자를 만든다. 나중에 식별자로 인스턴스를 얻어와야 한다면 다음처럼 객체의 프로토타입을 이용해야 한다:<p class="paragraph"/><div class="code"><pre>def p = Person.get(<span class="java&#45;keyword">new</span> Person(firstName:<span class="java&#45;quote">"Fred"</span>, lastName:<span class="java&#45;quote">"Flintstone"</span>))
println p.firstName</pre></div>
<h2><a name="5.5.2.6 Database Indices">5.5.2.6 Database Indices</a></h2>우리는 종종 쿼리를 최적화 하기위해 테이블 인덱스를 사용해야 한다. 어떻게 사용해야 하는 가는 문제 도메인에 따라 다르고 쿼리가 사용되는 패턴에 따라 다르다. GORM의 DSL로 컬럼을 어떤 인덱스에 태워야 할지를 명시 할 수 있다:<p class="paragraph"/>
<div class="code"><pre>class Person &#123;
  <span class="java&#45;object">String</span> firstName
  <span class="java&#45;object">String</span> address
  <span class="java&#45;keyword">static</span> mapping = &#123;
      table 'people'
      version <span class="java&#45;keyword">false</span>
      id column:'person_id'
      firstName column:'First_Name', index:'Name_Idx'
      address column:'Address', index:'Name_Idx, Address_Index'
  &#125;
&#125;</pre></div><p class="paragraph"/><p class="paragraph"/><h2><a name="5.5.2.7 Optimistic Locking and Versioning">5.5.2.7 Optimistic Locking and Versioning</a></h2><a href="../guide/single.html#5.3.5 Pessimistic and Optimistic Locking" class="guide">낙관적 잠금과 비관적 잠금</a>에 대해 이미 살펴보았듯이 기본적으로 GORM은 낙관적 작금을 사용하고 자동으로 <code>version</code> 속성을 모든 클래스에 주입(inject)한다. 그리고 이 <code>version</code> 속성은 데이터베이스의 <code>version</code> 컬럼에 매핑된다.<p class="paragraph"/>레거시 스키마에 이대로 매핑한다면 골칫거리가 될 뿐이다. 레거시 스키마에 매핑할 때에는 이 기능을 끌 수 있다:<p class="paragraph"/><div class="code"><pre>class Person &#123;
  ..
  <span class="java&#45;keyword">static</span> mapping = &#123;
      table 'people'
      version <span class="java&#45;keyword">false</span>
  &#125;
&#125;</pre></div><p class="paragraph"/><blockquote class="note">
낙관적 잠금을 사용하지 않으면 근본적으로 동시 업데이트를 고려해야 한다. 그리고 <a href="../guide/single.html#5.3.5 Pessimistic and Optimistic Locking" class="guide">비관적 잠금</a>을 사용하지 않으면 사용자가 데이터를 덮어 쓸수도 있기 때문에 언제라도 데이터를 잃어 버릴 수 있다.
</blockquote>
<h2><a name="5.5.2.8 Eager and Lazy Fetching">5.5.2.8 Eager and Lazy Fetching</a></h2><h5>Lazy Collections(Lazy 컬렉션)</h5><p class="paragraph"/>
<a href="../guide/single.html#5.3.4 Eager and Lazy Fetching" class="guide">Eager 패칭과 Lazy 패칭</a>에서 이미 살펴봤듯이 GORM은 기본적으로 컬렉션에대해 lazy 패칭을 사용한다. 이 것은 <code>fetchMode</code> 설정으로 변경할 수 있다. 그러나 ORM DSL을 이용하여 모든 매핑 설정을 한데 모을 수 있다:<p class="paragraph"/><div class="code"><pre>class Person &#123;
  <span class="java&#45;object">String</span> firstName
  <span class="java&#45;keyword">static</span> hasMany = &#91;addresses:Address&#93;
  <span class="java&#45;keyword">static</span> mapping = &#123;
      addresses lazy:<span class="java&#45;keyword">false</span>
  &#125;
&#125;
class Address &#123;
  <span class="java&#45;object">String</span> street
  <span class="java&#45;object">String</span> postCode
&#125;</pre></div><p class="paragraph"/><h4>Lazy Single-Ended Associations(한 쪽의 관계에서의 Lazy 패칭)</h4><p class="paragraph"/>GORM에서 1-1 과 n-1 association은 기본적으로 lazy 패칭이 아니다. 다른 엔터티와의 관계가 많은 엔터티를 로드하는 경우에 골칫거리가 될 수 있다. 엔터티를 로드할 때마다 새로운 SELECT 문이 수행되기 때문에 문제가 된다. 1-n, n-n association에서 lazy 컬렉션을 이용하여 lazy 패칭을 하게 할 수 있다:<p class="paragraph"/><div class="code"><pre>class Person &#123;
	<span class="java&#45;object">String</span> firstName
	<span class="java&#45;keyword">static</span> belongsTo = &#91;address:Address&#93;
	<span class="java&#45;keyword">static</span> mapping = &#123;
		address lazy:<span class="java&#45;keyword">true</span> // lazily fetch the address
	&#125;
&#125;
class Address &#123;
	<span class="java&#45;object">String</span> street
	<span class="java&#45;object">String</span> postCode
&#125;</pre></div><p class="paragraph"/><code>Person</code> 클래스의 <code>address</code> 속성이 필요할 때(lazily) Load되도록 설정했다.<p class="paragraph"/><h2><a name="5.6 Programmatic Transactions">5.6 Programmatic Transactions</a></h2>Grails는 Spring을 기반으로 만들었고 Spring의 Transaction 추상화 기술을 사용하여 트랜젝션 프로그래밍을 지원한다. GORM은 클래스에 <a href="../ref/Domain Classes/withTransaction.html" class="domainClasses">withTransaction</a> 메소드를 추가하여 사용하기 쉽도록 개선했다. withTransaction 메소드는 첫 번째 인자로 Spring의 <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/transaction/TransactionStatus.html" class="api">TransactionStatus</a> 객체를 넘겨 받는다.<p class="paragraph"/>일반적인 사용법은 다음과 같다:<p class="paragraph"/><div class="code"><pre>def transferFunds = &#123;
	Account.withTransaction &#123; status &#45;&#62;
		def source = Account.get(params.from)
		def dest = Account.get(params.to)<p class="paragraph"/>		def amount = params.amount.toInteger()
		<span class="java&#45;keyword">if</span>(source.active) &#123;
			source.balance &#45;= amount
			<span class="java&#45;keyword">if</span>(dest.active) &#123;
				dest.amount += amount
			&#125;
			<span class="java&#45;keyword">else</span> &#123;
				status.setRollbackOnly()
			&#125;
		&#125;<p class="paragraph"/>		
	&#125;<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/>이 예제에서 dest 계좌가 active가 아니면 트랜젝션이 롤백되고 트랜젝션이 처리되는 중간에 예외가 발생하면 자동으로 롤백된다.<p class="paragraph"/>트랜젝션이 통째로 롤백되지 않고 특정 시점으로 트랜젝션이 롤백되도록 “save points”를 사용할 수 있다. 이 것은 Spring의 <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/transaction/SavepointManager.html" class="api">SavePointManager</a> 인터페이스를 사용하여 구현됐다.<p class="paragraph"/>
<a href="../ref/Domain Classes/withTransaction.html" class="domainClasses">withTransaction</a> 메소드의 블럭내에서만 begin/commit/rollback 로직을 수행할 수 있다.
<h2><a name="5.7 GORM and Constraints">5.7 GORM and Constraints</a></h2>유효성 검사(<a href="../guide/single.html#7.1 Declaring Constraints" class="guide">Validation</a>)에서도 제약조건이 언급되지만 어떤 제약조건은 테이터베이스 스키마를 생성하는 방법에 영향을 준다. 그래서 여기에서도 검토할 필요가 있다.<p class="paragraph"/>운 좋게도 Grails의 제약조건은 도메인 클래스의 속성과 관련된 데이터베이스 컬럼을 생성하는 방법에 관여한다.<p class="paragraph"/>다음 예를 보자. 다음 속성을 갖는 도메인 모델을 만들었다.<p class="paragraph"/><div class="code"><pre><span class="java&#45;object">String</span> name
<span class="java&#45;object">String</span> description</pre></div><p class="paragraph"/>MySQL의 경우에 기본적으로 GORM은 이 컬럼을 다음과 같이 정의한다.<p class="paragraph"/><div class="code"><pre>컬럼 이름 | 데이터 타입
 description | varchar(255)</pre></div><p class="paragraph"/>그러나 도메인 클래스의 비지니스 로직은 description의 길이가 1000자가 될 수도 있다. 이 경우에 SQL로 테이블을 생성한다면 다음처럼 할 것이다.<p class="paragraph"/><div class="code"><pre>컬럼 이름 | 데이터 타입 
 description | TEXT</pre></div><p class="paragraph"/>데이터를 저장하기 전에 어플리케이션에서 1000자를 초과하지 못하도록 하는 유효성 검사를 했으면 좋겠다. Grails에서는 <a href="../guide/single.html#7.1 Declaring Constraints" class="guide">constraints</a>로 이 일을 할 수 있다. 도메인 클래스에 다음과 같이 코드를 추가한다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">static</span> constraints = &#123;
        description(maxSize:1000)
&#125;</pre></div><p class="paragraph"/>이 제약조건은 어플리케이션에서 유효성을 검사하도록 할뿐만 아니라 위에서 설명한 대로 스키마를 생성한다. 이제부터는 스키마 생성에 관여하는 다른 제약조건들을 살펴볼 것이다.<p class="paragraph"/><h4>Constraints Affecting String Properties(문자열 속성에 관여하는 제약조건들)</h4>
<ul class="star">
<li><a href="../ref/Constraints/inList.html" class="constraints">inList</a></li>
<li><a href="../ref/Constraints/maxSize.html" class="constraints">maxSize</a></li>
<li><a href="../ref/Constraints/size.html" class="constraints">size</a></li>
</ul><p class="paragraph"/><code>maxSize</code>나 <code>size</code> 제약조건이 있으면 Grails는 제약조건의 값을 참조하여 최대 컬럼 길이를 결정한다.<p class="paragraph"/>일반적으로 동일한 도메인 클래스의 속성에 이 두개의 제약조건 동시에 사용하는 것을 권장하지 않는다. 그러나 <code>maxSize</code> 제약조건과 <code>size</code> 제약조건이 둘 다 정의되면 Grails는 <code>maxSize</code> 제약조건의 값과 <code>size</code> 제약조건의 상한 값중에서 작은 수에 따라 컬럼의 길이를 결정한다(이 값을 초과하면 유효성 검사에서 에러를 발생시키기 때문에 Grails는 두 값 중에서 최소값을 사용한다).<p class="paragraph"/>inList 제약조건이 정의되면(그리고 <code>maxSize</code>와 <code>size</code> 제약조건이 정의되어있지 않다면) Grails는 유요한 값 중에서 가장 긴 문자열의 길이를 컬럼의 최대 길이로 설정한다. 예를 들어, "Java", "Groovy", "C++"들이 있을 때 Grails는 컬럼의 길이를 6으로 설정한다("Groovy" 문자열의 길이가 6이다).<p class="paragraph"/><h4>Constraints Affecting Numeric Properties(숫자 속성에 관여하는 제약조건들)</h4>
<ul class="star">
<li><a href="../ref/Constraints/min.html" class="constraints">min</a></li>
<li><a href="../ref/Constraints/max.html" class="constraints">max</a></li>
<li><a href="../ref/Constraints/range.html" class="constraints">range</a></li>
</ul><p class="paragraph"/>max 제약조건, min 제약조건, range 제약조건이 정의되면 Grails는 이 제약조건들에 따라 컬럼의 전체 자릿수(<a href="http://uk.builder.com/architecture/db/0,39026552,20268520,00.htm" target="blank">precision</a>)를 결정한다. 이 제약조건의 적용 여부는 Hibernate가 사용하는 DBMS를 어떻게 연동되는 가에 달려있다.<p class="paragraph"/>일반적으로 동일한 도메인 클래스의 속성에 min/max 제약조건과 range 제약조건을 동시에 사용하는 것을 권장하지 않는다. 만약 이 제약조건이 동시에 사용되면 Grails는 제약조건중 가장 작은 값을 사용한다(최소 전체 자릿수precision를 벗어나는 값은 유효성 검사에서 에러를 발생시키기 때문에 Grails는 두 개중 작은 값을 사용한다).
<ul class="star">
<li><a href="../ref/Constraints/scale.html" class="constraints">scale</a></li>
</ul><p class="paragraph"/>scale 제약조건이 정의되면 Grails는 이 제약조건의 값에 따라 컬럼의 소수 자릿수(<a href="http://uk.builder.com/architecture/db/0,39026552,20268520,00.htm" target="blank">scale</a>)를 결정한다(예를 들면, java.lang.Float, java.Lang.Double, java.lang.BigDecimal, or subclasses of java.lang.BigDecimal). 이 제약조건의 적용 여부는 Hibernate가 사용하는 DBMS를 어떻게 연동되는 가에 달려있다.<p class="paragraph"/>제약조건에 최대, 최소 값을 정의하면 Grails는 전체 자리수(precision)에 사용할 최대 값을 산출해낸다. 'max:100'만 설정되면 매우 큰 음수가 있을 수 있기 때문에 min/max 제약조건은 둘 다 설정되지 않으면 스키마 생성에 관여하지 않는다는 것을 잊지마라. 제약조건의 값이 Hibernate 컬럼의 전체 자릿수(현재는 기본값이 19다)보다 크지 않으면 Hibernate의 기본값이 사용된다. 예를 들면:<p class="paragraph"/><div class="code"><pre>someFloatValue(max:1000000, scale:3)</pre></div><p class="paragraph"/>이 것은 다음과 같은 의미이다:<p class="paragraph"/><div class="code"><pre>someFloatValue DECIMAL(19, 3) // 기본 전체 자릿수(precision)가 적용됐다.</pre></div><p class="paragraph"/>그러나 다음과 같은 경우엔:<p class="paragraph"/><div class="code"><pre>someFloatValue(max:12345678901234567890, scale:5)</pre></div><p class="paragraph"/>다음과 같은 의미를 가진다:<p class="paragraph"/><div class="code"><pre>someFloatValue DECIMAL(25, 5) // 전체 자릿수(precision) = max 값의 자릿수 + 소수 자릿수(scale)</pre></div><p class="paragraph"/>또 다음처럼 min, max 제약조건이 동시에 사용하는 경우에는:<p class="paragraph"/><div class="code"><pre>someFloatValue(max:100, min:&#45;100000)</pre></div><p class="paragraph"/>다음과 같은 의미를 가진다:<p class="paragraph"/><div class="code"><pre>someFloatValue DECIMAL(8, 2) // 전체 자릿수(precision) = min 값의 자릿수 + 기본 소수자릿수(scale:2)</pre></div>
	</body>
</html>