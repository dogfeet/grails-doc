<html>
     <head>
     	<meta http-equiv="Content-type" content="text/html; charset=utf-8">
     	<title>13. Web Services</title>
     	<link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8">
     </head>
	<body class="body">
		<h1><a name="13. Web Services">13. Web Services</a></h1>Web services are all about providing a web API onto your web application and are typically implemented in either <a href="http://en.wikipedia.org/wiki/SOAP" target="blank">SOAP</a> or <a href="http://en.wikipedia.org/wiki/Representational_State_Transfer" target="blank">REST</a>.<p class="paragraph"/>웹서비스라는것은 웹 어플리케이션에 대한 웹 API를 제공하는 것에 대한 모든것을 말한다. 이것은 일반적으로 <a href="http://en.wikipedia.org/wiki/SOAP" target="blank">SOAP</a> 나 <a href="http://en.wikipedia.org/wiki/Representational_State_Transfer" target="blank">REST</a>로 구현한다.<p class="paragraph"/><h2><a name="13.1 REST">13.1 REST</a></h2>REST는 사실 그 자체로는 어떠한 기술도 아니고 구조적인 형태이다. REST는 매우 간단하고 URL형태와 결합된 보통의 XML이나 JSON을 통신 매체로 사용하는 것이다. 이 URL 형태은 기존(underlying) 시스템의 “표현(representational)“과 GET, PUT, POST, DELETE와 같은 HTTP 메소드을 의미한다.<p class="paragraph"/>각 HTTP메소드는 하나의 액션에 연결된다. 예를들어 GET은 데이터를 얻어오기위해, PUT은 데이터를 생성하기위해, POST는 데이터를 수정하기위해, DELETE는 데이터를 삭제하기위해 사용한다. 이러한 점에서, REST는 <a href="../guide/single.html#16. Scaffolding" class="guide">CRUD</a>에 매우 잘 들어맞는다.<p class="paragraph"/><h4>URL patterns(URL 패턴)</h4><p class="paragraph"/>Grails로 REST를 구현하기위한 첫번째 과정은 RESTful URL 매핑(<a href="../guide/single.html#6.4 URL Mappings" class="guide">URL mappings</a>)을 제공하는것이다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">static</span> mappings = &#123;
   <span class="java&#45;quote">"/product/$id?"</span>(controller:<span class="java&#45;quote">"product"</span>)&#123;
       action = &#91;GET:<span class="java&#45;quote">"show"</span>, PUT:<span class="java&#45;quote">"update"</span>, DELETE:<span class="java&#45;quote">"delete"</span>, POST:<span class="java&#45;quote">"save"</span>&#93;
   &#125;	
&#125;</pre></div><p class="paragraph"/>컨트롤러에게 RESTful API를 제공하기 위해 HTTP메소드에 매핑하는 URL 매핑(<a href="../guide/single.html#6.4.5 Mapping to HTTP methods" class="guide">map to HTTP methods</a>)의 기능을 사용했다. GET, PUT, POST, DELETE 같은 각 HTTP 메소드들은 Controller의 액션에 매핑된다.<p class="paragraph"/><h4>XML Marshaling - Reading(XML 마샬링 - 읽기)</h4><p class="paragraph"/>컨트롤러의 GET 메소드 액션은 Grail의 XML 마셜링(<a href="../guide/single.html#6.1.7 XML and JSON Responses" class="guide">XML marshaling</a>) 기능을 사용하여 구현할 수 있다:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> grails.converters.&#42;
class ProductController &#123;
	def show = &#123;
		<span class="java&#45;keyword">if</span>(params.id &#38;&#38; Product.exists(params.id)) &#123;
			def p = Product.findByName(params.id)
			render p as XML
		&#125;
		<span class="java&#45;keyword">else</span> &#123;
			def all = Product.list()
			render all as XML
		&#125;
	&#125;
	..
&#125;</pre></div><p class="paragraph"/>이제 만약 좀 더 해야 할 일이 있다면 이름으로 제품의 id을 찾아 반환하거나 모든 제품을 반한하는 것이다. 이 방식에서 /products 로 간다면 모든 제품을 얻을 것이고, 아니면 /products/MacBook으로 간다면 하나의 MacBook만을 얻을 것이다.<p class="paragraph"/><h4>XML Marshalling - Updating(XMl 마샬링 - 업데이트)</h4><p class="paragraph"/>PUT과 POST 같은 업데이트를 지원하기 위해서 params 객체를 쓸 수 있다. <a href="../ref/Controllers/params.html" class="controllers">params</a> 객체는 XML로부터 들어오는 정보를 Grails가 접근하기 쉽도록 개선해놓은 것이다. 다음과 같은 들어오는 XML 패킷이 있다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;?xml version=<span class="xml&#45;quote">"1.0"</span> encoding=<span class="xml&#45;quote">"ISO&#45;8859&#45;1"</span>?&#62;</span>
<span class="xml&#45;tag">&#60;product&#62;</span>
	<span class="xml&#45;tag">&#60;name&#62;</span>MacBook<span class="xml&#45;tag">&#60;/name&#62;</span>
	<span class="xml&#45;tag">&#60;vendor id=<span class="xml&#45;quote">"12"</span>&#62;</span>
		<span class="xml&#45;tag">&#60;name&#62;</span>Apple<span class="xml&#45;tag">&#60;/name&#62;</span>
     <span class="xml&#45;tag">&#60;/vender&#62;</span>
<span class="xml&#45;tag">&#60;/product&#62;</span></pre></div><p class="paragraph"/>데이터 바인딩 절에서 설명한 기술을 이용하는 params 객체를 통해 이 XML 패킷을 읽을 수 있다:<p class="paragraph"/><div class="code"><pre>def save = &#123;
	def p = <span class="java&#45;keyword">new</span> Product(params&#91;'product'&#93;)<p class="paragraph"/>	<span class="java&#45;keyword">if</span>(p.save()) &#123;
		render p as XML
	&#125;
	<span class="java&#45;keyword">else</span> &#123;
		def errors = p.errors.allErrors.collect &#123; g.message(error:it) &#125;
		render(contentType:<span class="java&#45;quote">"text/xml"</span>) &#123;
			error &#123;
				<span class="java&#45;keyword">for</span>(err in errors) &#123;
					message(error:err)
				&#125;
			&#125;
		&#125;
	&#125;
&#125;</pre></div><p class="paragraph"/>이 예제에서 params 객체속에서 'project'키를 사용하여 인덱싱함으로써 Product 클래스의 생성자를 이용하여 xml을 자동으로 생성하고 바인딩할 수 있다. 아래 코드는 그 예제이다:<p class="paragraph"/><div class="code"><pre>def p = <span class="java&#45;keyword">new</span> Product(params&#91;'product'&#93;)</pre></div><p class="paragraph"/>폼 데이터를 전송하는 코드와 XML 요청을 다루는 코드 모두 수정할 필요 없고 XML 요청 뿐만아니라 JSON 요청에도 동일한 방법을 사용할 수 있다.<p class="paragraph"/><blockquote class="note">
만약 여러 클라이언트(REST, HTML 기타)에 대해 여러 응답이 필요하다면 컨텐츠 협상(<a href="../guide/single.html#6.8 Content Negotiation" class="guide">content negotation</a>)을 사용할 수 있음
</blockquote><p class="paragraph"/>그래서 Product 객체는 XML로 저장되고 표현되며, 그렇지 않으면 오류 메시지가 생성된다. 오류 메시지는 Grails의 검증(<a href="../guide/single.html#7. Validation" class="guide">validation</a>)지원을 사용하여 아래와 같은 형식으로 표현된다:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;error&#62;</span>
   <span class="xml&#45;tag">&#60;message&#62;</span>The property 'title' of class 'Person' must be specified<span class="xml&#45;tag">&#60;/message&#62;</span>
<span class="xml&#45;tag">&#60;/error&#62;</span></pre></div> <h2><a name="13.2 SOAP">13.2 SOAP</a></h2>Grails는 XFire 플러그인을 통해 SOAP를 지원한다. XFire플러그인은 많이 쓰이는 XFire SOAP스택을 사용하여 Grails에 SOAP지원을 통합시켜준다. XFire 플러그인은 expose 속성을 사용하여 Grails 서비스를 SOAP 서비스(<a href="../guide/single.html#8. The Service Layer" class="guide">services</a>)로 노출시켜준다:<p class="paragraph"/><div class="code"><pre>class BookService &#123;<p class="paragraph"/>  <span class="java&#45;keyword">static</span> expose=&#91;'xfire'&#93;<p class="paragraph"/>  Book&#91;&#93; getBooks()&#123;
    Book.list() as Book&#91;&#93;
  &#125;
&#125;</pre></div><p class="paragraph"/>WSDL은 다음과 같은 URL로 접근가능하다.<p class="paragraph"/>XFire 플러그인에 대한 정보는 <a href="http://grails.org/XFire+plugin" target="blank">위키의 문서</a>를 참고하라.
<h2><a name="13.3 RSS and Atom">13.3 RSS and Atom</a></h2>Grails에서 RSS나 Atom에 대한 직접적인 지원은 없다. <a href="../ref/Controllers/render.html" class="controllers">render</a>의 xml 지원을 사용하여 RSS나 ATOM 피드를 만들 수 있다. 하지만 Grails에서 사용할 수 있는 <a href="http://docs.codehaus.org/display/GRAILS/Feeds+Plugin" target="blank">Feed 플러그인</a> 을 사용하여 RSS나 Atom피드를 제공할 수 있다. 이 플러그인은 "ROME"":https://rome.dev.java.net/ 라이브러리를 이용하여 피드를 생성한다. 아래에 그 사용 예제가 있다:<p class="paragraph"/><div class="code"><pre>def feed = &#123;
    render(feedType:<span class="java&#45;quote">"rss"</span>, feedVersion:<span class="java&#45;quote">"2.0"</span>) &#123;
        title = <span class="java&#45;quote">"My test feed"</span>
        link = <span class="java&#45;quote">"http://your.test.server/yourController/feed"</span><p class="paragraph"/>        Article.list().each() &#123;
            entry(it.title) &#123;
                link = <span class="java&#45;quote">"http://your.test.server/article/$&#123;it.id&#125;"</span>
                it.content // <span class="java&#45;keyword">return</span> the content
            &#125;
        &#125;
    &#125;
&#125;</pre></div>
	</body>
</html>